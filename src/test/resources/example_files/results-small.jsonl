{"test_method": "@Test\n    public void testNaturalNumber() throws Exception {\n        Object ret = reader.read(\"123\");\n        assertNotNull(ret);\n        assertEquals(Long.class, ret.getClass());\n        assertEquals(123L, ret);\n    }", "focal_method": "public Object read(String string) throws JSONException {\n        this.it = new StringCharacterIterator(string);\n        this.c = this.it.first();\n\n        return this.read();\n    }", "test_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.json;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\n\n/**\n * User: mcucchiara\n * Date: 10/11/11\n * Time: 17.26\n */\npublic class JSONReaderTest {\n    private JSONReader reader = new JSONReader();\n\n    @Test\n    public void testExponentialNumber() throws Exception {\n        Object ret = reader.read(\"5e-5\");\n        assertNotNull(ret);\n        assertEquals(Double.class, ret.getClass());\n        assertEquals(5.0E-5, ret);\n    }\n\n    @Test\n    public void testExponentialNumber2() throws Exception {\n        Object ret = reader.read(\"123.4e10\");\n        assertNotNull(ret);\n        assertEquals(Double.class, ret.getClass());\n        assertEquals(123.4e10, ret);\n    }\n\n    @Test\n    public void testDecimalNumber() throws Exception {\n        Object ret = reader.read(\"3.2\");\n        assertNotNull(ret);\n        assertEquals(Double.class, ret.getClass());\n        assertEquals(3.2, ret);\n    }\n\n    @Test\n    public void testNaturalNumber() throws Exception {\n        Object ret = reader.read(\"123\");\n        assertNotNull(ret);\n        assertEquals(Long.class, ret.getClass());\n        assertEquals(123L, ret);\n    }\n}\n", "focal_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.json;\n\nimport java.text.CharacterIterator;\nimport java.text.StringCharacterIterator;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * <p>\n * Deserializes and object from a JSON string\n * </p>\n */\npublic class JSONReader {\n    private static final Object OBJECT_END = new Object();\n    private static final Object ARRAY_END = new Object();\n    private static final Object COLON = new Object();\n    private static final Object COMMA = new Object();\n    private static Map<Character, Character> escapes = new HashMap<Character, Character>();\n\n    static {\n        escapes.put('\"', '\"');\n        escapes.put('\\\\', '\\\\');\n        escapes.put('/', '/');\n        escapes.put('b', '\\b');\n        escapes.put('f', '\\f');\n        escapes.put('n', '\\n');\n        escapes.put('r', '\\r');\n        escapes.put('t', '\\t');\n    }\n\n    private CharacterIterator it;\n    private char c;\n    private Object token;\n    private StringBuilder buf = new StringBuilder();\n\n    protected char next() {\n        this.c = this.it.next();\n\n        return this.c;\n    }\n\n    protected void skipWhiteSpace() {\n        while (Character.isWhitespace(this.c)) {\n            this.next();\n        }\n    }\n\n    public Object read(String string) throws JSONException {\n        this.it = new StringCharacterIterator(string);\n        this.c = this.it.first();\n\n        return this.read();\n    }\n\n    protected Object read() throws JSONException {\n        Object ret;\n\n        this.skipWhiteSpace();\n\n        if (this.c == '\"') {\n            this.next();\n            ret = this.string('\"');\n        } else if (this.c == '\\'') {\n            this.next();\n            ret = this.string('\\'');\n        } else if (this.c == '[') {\n            this.next();\n            ret = this.array();\n        } else if (this.c == ']') {\n            ret = ARRAY_END;\n            this.next();\n        } else if (this.c == ',') {\n            ret = COMMA;\n            this.next();\n        } else if (this.c == '{') {\n            this.next();\n            ret = this.object();\n        } else if (this.c == '}') {\n            ret = OBJECT_END;\n            this.next();\n        } else if (this.c == ':') {\n            ret = COLON;\n            this.next();\n        } else if ((this.c == 't') && (this.next() == 'r') && (this.next() == 'u') && (this.next() == 'e')) {\n            ret = Boolean.TRUE;\n            this.next();\n        } else if ((this.c == 'f') && (this.next() == 'a') && (this.next() == 'l') && (this.next() == 's')\n                && (this.next() == 'e')) {\n            ret = Boolean.FALSE;\n            this.next();\n        } else if ((this.c == 'n') && (this.next() == 'u') && (this.next() == 'l') && (this.next() == 'l')) {\n            ret = null;\n            this.next();\n        } else if (Character.isDigit(this.c) || (this.c == '-')) {\n            ret = this.number();\n        } else {\n            throw buildInvalidInputException();\n        }\n\n        this.token = ret;\n\n        return ret;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected Map object() throws JSONException {\n        Map ret = new HashMap();\n        Object next = this.read();\n        if (next != OBJECT_END) {\n            String key = (String) next;\n            while (this.token != OBJECT_END) {\n                this.read(); // should be a colon\n\n                if (this.token != OBJECT_END) {\n                    ret.put(key, this.read());\n\n                    if (this.read() == COMMA) {\n                        Object name = this.read();\n\n                        if (name instanceof String) {\n                            key = (String) name;\n                        } else\n                            throw buildInvalidInputException();\n                    }\n                }\n            }\n        }\n\n        return ret;\n    }\n\n    protected JSONException buildInvalidInputException() {\n        return new JSONException(\"Input string is not well formed JSON (invalid char \" + this.c + \")\");\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    protected List array() throws JSONException {\n        List ret = new ArrayList();\n        Object value = this.read();\n\n        while (this.token != ARRAY_END) {\n            ret.add(value);\n\n            Object read = this.read();\n            if (read == COMMA) {\n                value = this.read();\n            } else if (read != ARRAY_END) {\n                throw buildInvalidInputException();\n            }\n        }\n\n        return ret;\n    }\n\n    protected Object number() throws JSONException {\n        this.buf.setLength(0);\n        boolean toDouble = false;\n\n        if (this.c == '-') {\n            this.add();\n        }\n\n        this.addDigits();\n\n        if (this.c == '.') {\n            toDouble = true;\n            this.add();\n            this.addDigits();\n        }\n\n        if ((this.c == 'e') || (this.c == 'E')) {\n            toDouble = true;\n            this.add();\n\n            if ((this.c == '+') || (this.c == '-')) {\n                this.add();\n            }\n\n            this.addDigits();\n        }\n\n        if (toDouble) {\n            try {\n                return Double.parseDouble(this.buf.toString());\n            } catch (NumberFormatException e) {\n                throw buildInvalidInputException();\n            }\n        } else {\n            try {\n                return Long.parseLong(this.buf.toString());\n            } catch (NumberFormatException e) {\n                throw buildInvalidInputException();\n            }\n        }\n    }\n\n    protected Object string(char quote) {\n        this.buf.setLength(0);\n\n        while ((this.c != quote) && (this.c != CharacterIterator.DONE)) {\n            if (this.c == '\\\\') {\n                this.next();\n\n                if (this.c == 'u') {\n                    this.add(this.unicode());\n                } else {\n                    Object value = escapes.get(this.c);\n\n                    if (value != null) {\n                        this.add((Character) value);\n                    }\n                }\n            } else {\n                this.add();\n            }\n        }\n\n        this.next();\n\n        return this.buf.toString();\n    }\n\n    protected void add(char cc) {\n        this.buf.append(cc);\n        this.next();\n    }\n\n    protected void add() {\n        this.add(this.c);\n    }\n\n    protected void addDigits() {\n        while (Character.isDigit(this.c)) {\n            this.add();\n        }\n    }\n\n    protected char unicode() {\n        int value = 0;\n\n        for (int i = 0; i < 4; ++i) {\n            switch (this.next()) {\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n                value = (value << 4) + (this.c - '0');\n\n                break;\n\n            case 'a':\n            case 'b':\n            case 'c':\n            case 'd':\n            case 'e':\n            case 'f':\n                value = (value << 4) + (this.c - 'W');\n\n                break;\n\n            case 'A':\n            case 'B':\n            case 'C':\n            case 'D':\n            case 'E':\n            case 'F':\n                value = (value << 4) + (this.c - '7');\n\n                break;\n            }\n        }\n\n        return (char) value;\n    }\n}\n"}
{"test_method": "@Test\n\tpublic void testSanitizeInputPathShouldReturnNullForLeadingWebInf() throws Exception {\n\t\tassertNull(fileDownloadAction.sanitizeInputPath(\"WEB-INF/foo\"));\n\t}", "focal_method": "String sanitizeInputPath( String value ) {\n\t\tif (value != null && value.toUpperCase().contains(\"WEB-INF\")) {\n\t\t\treturn null;\n\t\t}\n\t\treturn value;\n\t}", "test_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.showcase.filedownload;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static junit.framework.Assert.assertEquals;\nimport static junit.framework.Assert.assertNull;\n\npublic class FileDownloadActionTest {\n\n\tprivate FileDownloadAction fileDownloadAction;\n\n\t@Before\n\tpublic void setUp() {\n\t    this.fileDownloadAction = new FileDownloadAction();\n\t}\n\n\t@Test\n\tpublic void testSanitizeInputPathShouldAllowSimpleParameter() throws Exception {\n\t\tassertEquals(\"foo\", fileDownloadAction.sanitizeInputPath(\"foo\"));\n\t}\n\n\t@Test\n\tpublic void testSanitizeInputPathShouldReturnNullForNullInput() throws Exception {\n\t\tassertNull(fileDownloadAction.sanitizeInputPath(null));\n\t}\n\n\t@Test\n\tpublic void testSanitizeInputPathShouldReturnNullForLeadingWebInf() throws Exception {\n\t\tassertNull(fileDownloadAction.sanitizeInputPath(\"WEB-INF/foo\"));\n\t}\n\n\t@Test\n\tpublic void testSanitizeInputPathShouldReturnNullForNonLeadingWebInf() throws Exception {\n\t\tassertNull(fileDownloadAction.sanitizeInputPath(\"./WEB-INF/foo\"));\n\t}\n\n\t@Test\n\tpublic void testSanitizeInputPathShouldReturnNullForNonUppercaseWebInf() throws Exception {\n\t\tassertNull(fileDownloadAction.sanitizeInputPath(\"./wEB-Inf/foo\"));\n\t}\n}\n", "focal_file": "/*\n * $Id$\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.showcase.filedownload;\n\nimport com.opensymphony.xwork2.Action;\nimport org.apache.struts2.ServletActionContext;\n\nimport java.io.InputStream;\n\n/**\n * Demonstrates file resource download.\n * Set filePath to the local file resource to download,\n * relative to the application root (\"/images/struts.gif\").\n */\npublic class FileDownloadAction implements Action {\n\n\tprivate String inputPath;\n\n\tpublic String execute() throws Exception {\n\t\treturn SUCCESS;\n\t}\n\n\tpublic void setInputPath(String value) {\n\t\tinputPath = sanitizeInputPath(value);\n\t}\n\n\t/**\n\t * As the user modifiable parameter inputPath will be used to access server side resources, we want the path to be\n\t * sanitized - in this case it is demonstrated to disallow inputPath parameter values containing \"WEB-INF\". Consider to\n\t * use even stricter rules in production environments.\n\t *\n\t * @param value the raw parameter input value to sanitize\n\t *\n\t * @return the sanitized value; <tt>null</tt> if value contains an invalid path segment like WEB-INF\n\t */\n\tString sanitizeInputPath( String value ) {\n\t\tif (value != null && value.toUpperCase().contains(\"WEB-INF\")) {\n\t\t\treturn null;\n\t\t}\n\t\treturn value;\n\t}\n\n\tpublic InputStream getInputStream() throws Exception {\n\t\treturn ServletActionContext.getServletContext().getResourceAsStream(inputPath);\n\t}\n}\n"}
{"test_method": "@Test\n    public void testRegister() throws Exception {\n        final ConstantConfig constantConfig = new ConstantConfig();\n        constantConfig.setDevMode(true);\n\n        final String expectedUnknownHandler = \"expectedUnknownHandler\";\n\n        StrutsJavaConfiguration javaConfig = new StrutsJavaConfiguration() {\n            @Override\n            public List<String> unknownHandlerStack() {\n                return Collections.singletonList(expectedUnknownHandler);\n            }\n\n            @Override\n            public List<ConstantConfig> constants() {\n                return Collections.singletonList(constantConfig);\n            }\n\n            @Override\n            public List<BeanConfig> beans() {\n                return Arrays.asList(\n                    new BeanConfig(TestBean.class, \"struts\"),\n                    new BeanConfig(TestBean.class, \"struts.static\", TestBean.class, Scope.PROTOTYPE, true, true),\n                    new BeanConfig(TestBean.class, \"struts.test.bean\", TestBean.class)\n                );\n            }\n\n            @Override\n            public Optional<BeanSelectionConfig> beanSelection() {\n                return Optional.of(new BeanSelectionConfig(TestBeanSelectionProvider.class, \"testBeans\"));\n            }\n        };\n        StrutsJavaConfigurationProvider provider = new StrutsJavaConfigurationProvider(javaConfig);\n\n        Configuration configuration = new MockConfiguration();\n\n        provider.init(configuration);\n\n        ContainerBuilder builder = new ContainerBuilder();\n        LocatableProperties props = new LocatableProperties();\n\n        provider.register(builder, props);\n\n        // constant\n        Assert.assertEquals(String.valueOf(constantConfig.getDevMode()), props.get(StrutsConstants.STRUTS_DEVMODE));\n\n        // unknown-handler-stack\n        Assert.assertNotNull(configuration.getUnknownHandlerStack());\n        Assert.assertEquals(1, configuration.getUnknownHandlerStack().size());\n        Assert.assertEquals(expectedUnknownHandler, configuration.getUnknownHandlerStack().get(0).getName());\n\n        // bean\n        Container container = builder.create(true);\n        TestBean testBean = container.getInstance(TestBean.class);\n        Assert.assertNotNull(testBean);\n\n        testBean = container.getInstance(TestBean.class, \"struts\");\n        Assert.assertNotNull(testBean);\n\n        // bean selection\n        Set<String> names = container.getInstanceNames(TestBean.class);\n        Assert.assertTrue(names.contains(\"struts\"));\n        Assert.assertTrue(names.contains(\"struts.test.bean\"));\n    }", "focal_method": "@Override\n    public void register(ContainerBuilder builder, LocatableProperties props) throws ConfigurationException {\n        Map<String, Object> loadedBeans = new HashMap<>();\n\n        // bean\n        List<BeanConfig> beanConfigs = javaConfig.beans();\n        if (beanConfigs != null) {\n            for (BeanConfig bc : beanConfigs) {\n                if (bc != null) {\n                    registerBean(loadedBeans, builder, bc);\n                }\n            }\n        }\n\n        // constant\n        List<ConstantConfig> constantConfigList = javaConfig.constants();\n        if (constantConfigList != null) {\n            for (ConstantConfig constantConf : constantConfigList) {\n                if (constantConf != null) {\n                    Map<String, String> constantMap = constantConf.getAllAsStringsMap();\n                    for (Entry<String, String> entr : constantMap.entrySet()) {\n                        if (entr.getKey() != null && entr.getValue() != null) {\n                            registerConstant(props, entr.getKey(), entr.getValue());\n                        }\n                    }\n                }\n            }\n        }\n\n        // bean-selection\n        javaConfig.beanSelection().ifPresent(beanSelectionConfig -> {\n            try {\n                LOG.debug(\"Registering bean selection provider {} of type {}\",\n                    beanSelectionConfig.getName(), beanSelectionConfig.getClazz().getName());\n\n                BeanSelectionProvider provider = beanSelectionConfig.getClazz().newInstance();\n                provider.register(builder, props);\n            } catch (IllegalAccessException | InstantiationException e) {\n                throw new ConfigurationException(\"Unable to load : name:\" + beanSelectionConfig.getName()\n                    + \" class:\" + beanSelectionConfig.getClazz().getName());\n            }\n        });\n\n        // unknown-handler-stack\n        List<String> unknownHandlers = javaConfig.unknownHandlerStack();\n        if (unknownHandlers != null) {\n            List<UnknownHandlerConfig> unknownHandlerStack = new ArrayList<>();\n            for (String unknownHandler : unknownHandlers) {\n                Location location = LocationUtils.getLocation(unknownHandler);\n                unknownHandlerStack.add(new UnknownHandlerConfig(unknownHandler, location));\n            }\n\n            if (!unknownHandlerStack.isEmpty()) {\n                configuration.setUnknownHandlerStack(unknownHandlerStack);\n            }\n        }\n    }", "test_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.config;\n\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.Set;\n\nimport org.apache.struts2.StrutsConstants;\nimport org.apache.struts2.config.entities.BeanConfig;\nimport org.apache.struts2.config.entities.BeanSelectionConfig;\nimport org.apache.struts2.config.entities.ConstantConfig;\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport com.opensymphony.xwork2.TestBean;\nimport com.opensymphony.xwork2.config.Configuration;\nimport com.opensymphony.xwork2.config.impl.MockConfiguration;\nimport com.opensymphony.xwork2.inject.Container;\nimport com.opensymphony.xwork2.inject.ContainerBuilder;\nimport com.opensymphony.xwork2.inject.Scope;\nimport com.opensymphony.xwork2.util.location.LocatableProperties;\n\npublic class StrutsJavaConfigurationProviderTest {\n    @Test\n    public void testRegister() throws Exception {\n        final ConstantConfig constantConfig = new ConstantConfig();\n        constantConfig.setDevMode(true);\n\n        final String expectedUnknownHandler = \"expectedUnknownHandler\";\n\n        StrutsJavaConfiguration javaConfig = new StrutsJavaConfiguration() {\n            @Override\n            public List<String> unknownHandlerStack() {\n                return Collections.singletonList(expectedUnknownHandler);\n            }\n\n            @Override\n            public List<ConstantConfig> constants() {\n                return Collections.singletonList(constantConfig);\n            }\n\n            @Override\n            public List<BeanConfig> beans() {\n                return Arrays.asList(\n                    new BeanConfig(TestBean.class, \"struts\"),\n                    new BeanConfig(TestBean.class, \"struts.static\", TestBean.class, Scope.PROTOTYPE, true, true),\n                    new BeanConfig(TestBean.class, \"struts.test.bean\", TestBean.class)\n                );\n            }\n\n            @Override\n            public Optional<BeanSelectionConfig> beanSelection() {\n                return Optional.of(new BeanSelectionConfig(TestBeanSelectionProvider.class, \"testBeans\"));\n            }\n        };\n        StrutsJavaConfigurationProvider provider = new StrutsJavaConfigurationProvider(javaConfig);\n\n        Configuration configuration = new MockConfiguration();\n\n        provider.init(configuration);\n\n        ContainerBuilder builder = new ContainerBuilder();\n        LocatableProperties props = new LocatableProperties();\n\n        provider.register(builder, props);\n\n        // constant\n        Assert.assertEquals(String.valueOf(constantConfig.getDevMode()), props.get(StrutsConstants.STRUTS_DEVMODE));\n\n        // unknown-handler-stack\n        Assert.assertNotNull(configuration.getUnknownHandlerStack());\n        Assert.assertEquals(1, configuration.getUnknownHandlerStack().size());\n        Assert.assertEquals(expectedUnknownHandler, configuration.getUnknownHandlerStack().get(0).getName());\n\n        // bean\n        Container container = builder.create(true);\n        TestBean testBean = container.getInstance(TestBean.class);\n        Assert.assertNotNull(testBean);\n\n        testBean = container.getInstance(TestBean.class, \"struts\");\n        Assert.assertNotNull(testBean);\n\n        // bean selection\n        Set<String> names = container.getInstanceNames(TestBean.class);\n        Assert.assertTrue(names.contains(\"struts\"));\n        Assert.assertTrue(names.contains(\"struts.test.bean\"));\n    }\n\n    @Test\n    /**\n     * This test is purely to provide code coverage for {@link AbstractBeanSelectionProvider}.\n     * It uses an arbitrary setup to ensure a code path not followed in the registration test\n     * is traversed.\n     */\n    public void testAbstractBeanProviderCoverage() throws Exception {\n        final ConstantConfig constantConfig = new ConstantConfig();\n        final String expectedUnknownHandler = \"expectedUnknownHandler\";\n\n        StrutsJavaConfiguration javaConfig = new StrutsJavaConfiguration() {\n            @Override\n            public List<String> unknownHandlerStack() {\n                return Collections.singletonList(expectedUnknownHandler);\n            }\n\n            @Override\n            public List<ConstantConfig> constants() {\n                return Collections.singletonList(constantConfig);\n            }\n\n            @Override\n            public List<BeanConfig> beans() {\n                return Arrays.asList(\n                    new BeanConfig(TestBean.class, \"struts\")\n                );\n            }\n\n            @Override\n            public Optional<BeanSelectionConfig> beanSelection() {\n                return Optional.of(new BeanSelectionConfig(TestBeanSelectionProvider.class, \"testBeans\"));\n            }\n        };\n\n        StrutsJavaConfigurationProvider provider = new StrutsJavaConfigurationProvider(javaConfig);\n        Configuration configuration = new MockConfiguration();\n        ContainerBuilder builder = new ContainerBuilder();\n        LocatableProperties props = new LocatableProperties();\n\n        provider.init(configuration);\n        provider.register(builder, props);\n\n        props.put(CodeCoverageTestClass1.ALIAS_KEY, CodeCoverageTestClass1.ALIAS_VALUE);\n        TestBeanSelectionProvider testBeanSelectionProvider = new TestBeanSelectionProvider();\n        testBeanSelectionProvider.aliasCallCoverage(CodeCoverageTestClass1.class, builder, props, CodeCoverageTestClass1.ALIAS_KEY, Scope.THREAD);\n    }\n\n    final class CodeCoverageTestClass1 extends Object {\n        public static final String ALIAS_KEY = \"testAliasKey\";\n        public static final String ALIAS_VALUE  = \"testAliasValue\";\n\n        public CodeCoverageTestClass1() {\n            super();\n        }\n    }\n}\n", "focal_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.config;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\nimport com.opensymphony.xwork2.config.BeanSelectionProvider;\nimport com.opensymphony.xwork2.util.ClassLoaderUtil;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.struts2.config.entities.BeanConfig;\nimport org.apache.struts2.config.entities.BeanSelectionConfig;\nimport org.apache.struts2.config.entities.ConstantConfig;\n\nimport com.opensymphony.xwork2.config.Configuration;\nimport com.opensymphony.xwork2.config.ConfigurationException;\nimport com.opensymphony.xwork2.config.ConfigurationProvider;\nimport com.opensymphony.xwork2.config.entities.UnknownHandlerConfig;\nimport com.opensymphony.xwork2.config.impl.LocatableFactory;\nimport com.opensymphony.xwork2.config.providers.ValueSubstitutor;\nimport com.opensymphony.xwork2.inject.ContainerBuilder;\nimport com.opensymphony.xwork2.inject.Inject;\nimport com.opensymphony.xwork2.util.location.LocatableProperties;\nimport com.opensymphony.xwork2.util.location.Location;\nimport com.opensymphony.xwork2.util.location.LocationUtils;\n\npublic class StrutsJavaConfigurationProvider implements ConfigurationProvider {\n    private static final Logger LOG = LogManager.getLogger(StrutsJavaConfigurationProvider.class);\n\n    private final StrutsJavaConfiguration javaConfig;\n    private Configuration configuration;\n    private boolean throwExceptionOnDuplicateBeans = true;\n    private ValueSubstitutor valueSubstitutor;\n\n    public StrutsJavaConfigurationProvider(StrutsJavaConfiguration javaConfig) {\n        this.javaConfig = javaConfig;\n    }\n\n    public void setThrowExceptionOnDuplicateBeans(boolean val) {\n        this.throwExceptionOnDuplicateBeans = val;\n    }\n\n    @Inject(required = false)\n    public void setValueSubstitutor(ValueSubstitutor valueSubstitutor) {\n        this.valueSubstitutor = valueSubstitutor;\n    }\n\n    @Override\n    public void register(ContainerBuilder builder, LocatableProperties props) throws ConfigurationException {\n        Map<String, Object> loadedBeans = new HashMap<>();\n\n        // bean\n        List<BeanConfig> beanConfigs = javaConfig.beans();\n        if (beanConfigs != null) {\n            for (BeanConfig bc : beanConfigs) {\n                if (bc != null) {\n                    registerBean(loadedBeans, builder, bc);\n                }\n            }\n        }\n\n        // constant\n        List<ConstantConfig> constantConfigList = javaConfig.constants();\n        if (constantConfigList != null) {\n            for (ConstantConfig constantConf : constantConfigList) {\n                if (constantConf != null) {\n                    Map<String, String> constantMap = constantConf.getAllAsStringsMap();\n                    for (Entry<String, String> entr : constantMap.entrySet()) {\n                        if (entr.getKey() != null && entr.getValue() != null) {\n                            registerConstant(props, entr.getKey(), entr.getValue());\n                        }\n                    }\n                }\n            }\n        }\n\n        // bean-selection\n        javaConfig.beanSelection().ifPresent(beanSelectionConfig -> {\n            try {\n                LOG.debug(\"Registering bean selection provider {} of type {}\",\n                    beanSelectionConfig.getName(), beanSelectionConfig.getClazz().getName());\n\n                BeanSelectionProvider provider = beanSelectionConfig.getClazz().newInstance();\n                provider.register(builder, props);\n            } catch (IllegalAccessException | InstantiationException e) {\n                throw new ConfigurationException(\"Unable to load : name:\" + beanSelectionConfig.getName()\n                    + \" class:\" + beanSelectionConfig.getClazz().getName());\n            }\n        });\n\n        // unknown-handler-stack\n        List<String> unknownHandlers = javaConfig.unknownHandlerStack();\n        if (unknownHandlers != null) {\n            List<UnknownHandlerConfig> unknownHandlerStack = new ArrayList<>();\n            for (String unknownHandler : unknownHandlers) {\n                Location location = LocationUtils.getLocation(unknownHandler);\n                unknownHandlerStack.add(new UnknownHandlerConfig(unknownHandler, location));\n            }\n\n            if (!unknownHandlerStack.isEmpty()) {\n                configuration.setUnknownHandlerStack(unknownHandlerStack);\n            }\n        }\n    }\n\n    private void registerConstant(LocatableProperties props, String key, String value) {\n        if (valueSubstitutor != null) {\n            LOG.debug(\"Substituting value [{}] using [{}]\", value, valueSubstitutor.getClass().getName());\n            value = valueSubstitutor.substitute(value);\n        }\n\n        props.setProperty(key, value, javaConfig);\n    }\n\n    private void registerBean(Map<String, Object> loadedBeans, ContainerBuilder containerBuilder, BeanConfig beanConf) {\n        try {\n            if (beanConf.isOnlyStatic()) {\n                // Force loading of class to detect no class def found\n                // exceptions\n                beanConf.getClazz().getDeclaredClasses();\n                containerBuilder.injectStatics(beanConf.getClazz());\n            } else {\n                if (containerBuilder.contains(beanConf.getType(), beanConf.getName())) {\n                    Location loc = LocationUtils\n                        .getLocation(loadedBeans.get(beanConf.getType().getName() + beanConf.getName()));\n                    if (throwExceptionOnDuplicateBeans) {\n                        throw new ConfigurationException(\"Bean type \" + beanConf.getType() + \" with the name \"\n                            + beanConf.getName() + \" has already been loaded by \" + loc, javaConfig);\n                    }\n                }\n\n                // Force loading of class to detect no class def found\n                // exceptions\n                beanConf.getClazz().getDeclaredConstructors();\n\n                LOG.debug(\"Loaded type: {} name: {} clazz: {}\", beanConf.getType(), beanConf.getName(),\n                    beanConf.getClazz());\n\n                containerBuilder.factory(\n                    beanConf.getType(),\n                    beanConf.getName(),\n                    new LocatableFactory(\n                        beanConf.getName(), beanConf.getType(), beanConf.getClazz(), beanConf.getScope(), javaConfig\n                    ),\n                    beanConf.getScope());\n            }\n            loadedBeans.put(beanConf.getType().getName() + beanConf.getName(), javaConfig);\n        } catch (Throwable ex) {\n            if (!beanConf.isOptional()) {\n                throw new ConfigurationException(\n                    \"Unable to load bean: type:\" + beanConf.getType() + \" class:\" + beanConf.getClazz(), ex);\n            } else {\n                LOG.debug(\"Unable to load optional class: {}\", beanConf.getClazz());\n            }\n        }\n    }\n\n    @Override\n    public void init(Configuration configuration) throws ConfigurationException {\n        this.configuration = configuration;\n    }\n\n    @Override\n    public boolean needsReload() {\n        return false;\n    }\n\n    @Override\n    public void loadPackages() throws ConfigurationException {\n    }\n\n    @Override\n    public void destroy() {\n    }\n}\n"}
{"test_method": "@Test\n    public void testDecimalNumber() throws Exception {\n        Object ret = reader.read(\"3.2\");\n        assertNotNull(ret);\n        assertEquals(Double.class, ret.getClass());\n        assertEquals(3.2, ret);\n    }", "focal_method": "public Object read(String string) throws JSONException {\n        this.it = new StringCharacterIterator(string);\n        this.c = this.it.first();\n\n        return this.read();\n    }", "test_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.json;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\n\n/**\n * User: mcucchiara\n * Date: 10/11/11\n * Time: 17.26\n */\npublic class JSONReaderTest {\n    private JSONReader reader = new JSONReader();\n\n    @Test\n    public void testExponentialNumber() throws Exception {\n        Object ret = reader.read(\"5e-5\");\n        assertNotNull(ret);\n        assertEquals(Double.class, ret.getClass());\n        assertEquals(5.0E-5, ret);\n    }\n\n    @Test\n    public void testExponentialNumber2() throws Exception {\n        Object ret = reader.read(\"123.4e10\");\n        assertNotNull(ret);\n        assertEquals(Double.class, ret.getClass());\n        assertEquals(123.4e10, ret);\n    }\n\n    @Test\n    public void testDecimalNumber() throws Exception {\n        Object ret = reader.read(\"3.2\");\n        assertNotNull(ret);\n        assertEquals(Double.class, ret.getClass());\n        assertEquals(3.2, ret);\n    }\n\n    @Test\n    public void testNaturalNumber() throws Exception {\n        Object ret = reader.read(\"123\");\n        assertNotNull(ret);\n        assertEquals(Long.class, ret.getClass());\n        assertEquals(123L, ret);\n    }\n}\n", "focal_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.json;\n\nimport java.text.CharacterIterator;\nimport java.text.StringCharacterIterator;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * <p>\n * Deserializes and object from a JSON string\n * </p>\n */\npublic class JSONReader {\n    private static final Object OBJECT_END = new Object();\n    private static final Object ARRAY_END = new Object();\n    private static final Object COLON = new Object();\n    private static final Object COMMA = new Object();\n    private static Map<Character, Character> escapes = new HashMap<Character, Character>();\n\n    static {\n        escapes.put('\"', '\"');\n        escapes.put('\\\\', '\\\\');\n        escapes.put('/', '/');\n        escapes.put('b', '\\b');\n        escapes.put('f', '\\f');\n        escapes.put('n', '\\n');\n        escapes.put('r', '\\r');\n        escapes.put('t', '\\t');\n    }\n\n    private CharacterIterator it;\n    private char c;\n    private Object token;\n    private StringBuilder buf = new StringBuilder();\n\n    protected char next() {\n        this.c = this.it.next();\n\n        return this.c;\n    }\n\n    protected void skipWhiteSpace() {\n        while (Character.isWhitespace(this.c)) {\n            this.next();\n        }\n    }\n\n    public Object read(String string) throws JSONException {\n        this.it = new StringCharacterIterator(string);\n        this.c = this.it.first();\n\n        return this.read();\n    }\n\n    protected Object read() throws JSONException {\n        Object ret;\n\n        this.skipWhiteSpace();\n\n        if (this.c == '\"') {\n            this.next();\n            ret = this.string('\"');\n        } else if (this.c == '\\'') {\n            this.next();\n            ret = this.string('\\'');\n        } else if (this.c == '[') {\n            this.next();\n            ret = this.array();\n        } else if (this.c == ']') {\n            ret = ARRAY_END;\n            this.next();\n        } else if (this.c == ',') {\n            ret = COMMA;\n            this.next();\n        } else if (this.c == '{') {\n            this.next();\n            ret = this.object();\n        } else if (this.c == '}') {\n            ret = OBJECT_END;\n            this.next();\n        } else if (this.c == ':') {\n            ret = COLON;\n            this.next();\n        } else if ((this.c == 't') && (this.next() == 'r') && (this.next() == 'u') && (this.next() == 'e')) {\n            ret = Boolean.TRUE;\n            this.next();\n        } else if ((this.c == 'f') && (this.next() == 'a') && (this.next() == 'l') && (this.next() == 's')\n                && (this.next() == 'e')) {\n            ret = Boolean.FALSE;\n            this.next();\n        } else if ((this.c == 'n') && (this.next() == 'u') && (this.next() == 'l') && (this.next() == 'l')) {\n            ret = null;\n            this.next();\n        } else if (Character.isDigit(this.c) || (this.c == '-')) {\n            ret = this.number();\n        } else {\n            throw buildInvalidInputException();\n        }\n\n        this.token = ret;\n\n        return ret;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected Map object() throws JSONException {\n        Map ret = new HashMap();\n        Object next = this.read();\n        if (next != OBJECT_END) {\n            String key = (String) next;\n            while (this.token != OBJECT_END) {\n                this.read(); // should be a colon\n\n                if (this.token != OBJECT_END) {\n                    ret.put(key, this.read());\n\n                    if (this.read() == COMMA) {\n                        Object name = this.read();\n\n                        if (name instanceof String) {\n                            key = (String) name;\n                        } else\n                            throw buildInvalidInputException();\n                    }\n                }\n            }\n        }\n\n        return ret;\n    }\n\n    protected JSONException buildInvalidInputException() {\n        return new JSONException(\"Input string is not well formed JSON (invalid char \" + this.c + \")\");\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    protected List array() throws JSONException {\n        List ret = new ArrayList();\n        Object value = this.read();\n\n        while (this.token != ARRAY_END) {\n            ret.add(value);\n\n            Object read = this.read();\n            if (read == COMMA) {\n                value = this.read();\n            } else if (read != ARRAY_END) {\n                throw buildInvalidInputException();\n            }\n        }\n\n        return ret;\n    }\n\n    protected Object number() throws JSONException {\n        this.buf.setLength(0);\n        boolean toDouble = false;\n\n        if (this.c == '-') {\n            this.add();\n        }\n\n        this.addDigits();\n\n        if (this.c == '.') {\n            toDouble = true;\n            this.add();\n            this.addDigits();\n        }\n\n        if ((this.c == 'e') || (this.c == 'E')) {\n            toDouble = true;\n            this.add();\n\n            if ((this.c == '+') || (this.c == '-')) {\n                this.add();\n            }\n\n            this.addDigits();\n        }\n\n        if (toDouble) {\n            try {\n                return Double.parseDouble(this.buf.toString());\n            } catch (NumberFormatException e) {\n                throw buildInvalidInputException();\n            }\n        } else {\n            try {\n                return Long.parseLong(this.buf.toString());\n            } catch (NumberFormatException e) {\n                throw buildInvalidInputException();\n            }\n        }\n    }\n\n    protected Object string(char quote) {\n        this.buf.setLength(0);\n\n        while ((this.c != quote) && (this.c != CharacterIterator.DONE)) {\n            if (this.c == '\\\\') {\n                this.next();\n\n                if (this.c == 'u') {\n                    this.add(this.unicode());\n                } else {\n                    Object value = escapes.get(this.c);\n\n                    if (value != null) {\n                        this.add((Character) value);\n                    }\n                }\n            } else {\n                this.add();\n            }\n        }\n\n        this.next();\n\n        return this.buf.toString();\n    }\n\n    protected void add(char cc) {\n        this.buf.append(cc);\n        this.next();\n    }\n\n    protected void add() {\n        this.add(this.c);\n    }\n\n    protected void addDigits() {\n        while (Character.isDigit(this.c)) {\n            this.add();\n        }\n    }\n\n    protected char unicode() {\n        int value = 0;\n\n        for (int i = 0; i < 4; ++i) {\n            switch (this.next()) {\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n                value = (value << 4) + (this.c - '0');\n\n                break;\n\n            case 'a':\n            case 'b':\n            case 'c':\n            case 'd':\n            case 'e':\n            case 'f':\n                value = (value << 4) + (this.c - 'W');\n\n                break;\n\n            case 'A':\n            case 'B':\n            case 'C':\n            case 'D':\n            case 'E':\n            case 'F':\n                value = (value << 4) + (this.c - '7');\n\n                break;\n            }\n        }\n\n        return (char) value;\n    }\n}\n"}
{"test_method": "@Test\n    public void findAnnotationMultipleActionNotFound() {\n        StrutsTilesAnnotationProcessor annotationProcessor = new StrutsTilesAnnotationProcessor();\n        TilesDefinition tilesDefinition = annotationProcessor.findAnnotation(new TilesTestActionMultipleAnnotations(), \"def3\");\n        Assert.assertNull(tilesDefinition);\n    }", "focal_method": "public TilesDefinition findAnnotation(Object action, String tileName) {\n        Class<?> clazz = action.getClass();\n        TilesDefinition tilesDefinition = clazz.getAnnotation(TilesDefinition.class);\n        TilesDefinitions tilesDefinitions = clazz.getAnnotation(TilesDefinitions.class);\n\n        if (tilesDefinition == null && tilesDefinitions != null) {\n            if (!StringUtils.isEmpty(tileName)) {\n                for (TilesDefinition i : tilesDefinitions.value()) {\n                    if (i.name().equals(tileName)) {\n                        tilesDefinition = i;\n                        break;\n                    }\n                }\n            } else {\n                if (tilesDefinitions.value().length > 0) {\n                    tilesDefinition = tilesDefinitions.value()[0];\n                }\n            }\n        }\n\n        return tilesDefinition;\n    }", "test_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.tiles;\n\nimport java.util.List;\nimport java.util.Set;\n\nimport org.apache.struts2.tiles.annotation.TilesDefinition;\nimport org.apache.tiles.api.Attribute;\nimport org.apache.tiles.api.Definition;\nimport org.apache.tiles.api.Expression;\nimport org.junit.Test;\n\nimport org.junit.Assert;\n\npublic class StrutsTilesAnnotationProcessorTest {\n\n    @Test\n    public void findAnnotationSingleAction() {\n        StrutsTilesAnnotationProcessor annotationProcessor = new StrutsTilesAnnotationProcessor();\n        TilesDefinition tilesDefinition = annotationProcessor.findAnnotation(new TilesTestActionSingleAnnotation(), null);\n        Assert.assertNotNull(tilesDefinition);\n        Assert.assertEquals(\"definition-name\", tilesDefinition.name());\n    }\n\n    @Test\n    public void findAnnotationMultipleActionNameNull() {\n        StrutsTilesAnnotationProcessor annotationProcessor = new StrutsTilesAnnotationProcessor();\n        TilesDefinition tilesDefinition = annotationProcessor.findAnnotation(new TilesTestActionMultipleAnnotations(), null);\n        Assert.assertNotNull(tilesDefinition);\n        Assert.assertEquals(\"def1\", tilesDefinition.name());\n    }\n\n    @Test\n    public void findAnnotationMultipleActionNameGiven() {\n        StrutsTilesAnnotationProcessor annotationProcessor = new StrutsTilesAnnotationProcessor();\n        TilesDefinition tilesDefinition = annotationProcessor.findAnnotation(new TilesTestActionMultipleAnnotations(), \"def2\");\n        Assert.assertNotNull(tilesDefinition);\n        Assert.assertEquals(\"def2\", tilesDefinition.name());\n    }\n\n    @Test\n    public void findAnnotationMultipleActionNotFound() {\n        StrutsTilesAnnotationProcessor annotationProcessor = new StrutsTilesAnnotationProcessor();\n        TilesDefinition tilesDefinition = annotationProcessor.findAnnotation(new TilesTestActionMultipleAnnotations(), \"def3\");\n        Assert.assertNull(tilesDefinition);\n    }\n\n    @Test\n    public void buildDefiniton() {\n        StrutsTilesAnnotationProcessor annotationProcessor = new StrutsTilesAnnotationProcessor();\n        TilesDefinition tilesDefinition = annotationProcessor.findAnnotation(new TilesTestActionSingleAnnotation(), null);\n\n        Definition definition = annotationProcessor.buildTilesDefinition(\"tileName\", tilesDefinition);\n\n        Assert.assertNotNull(definition);\n        Assert.assertEquals(\"tileName\", definition.getName());\n        Assert.assertEquals(\"preparer\", definition.getPreparer());\n        Assert.assertEquals(\"base-definition\", definition.getExtends());\n        Attribute templateAttribute = definition.getTemplateAttribute();\n        Assert.assertEquals(\"template\", templateAttribute.getValue());\n        Assert.assertEquals(\"type\", templateAttribute.getRenderer());\n        Assert.assertEquals(\"role\", templateAttribute.getRole());\n        Expression definitionExpressionObject = templateAttribute.getExpressionObject();\n        Assert.assertEquals(\"templ*\", definitionExpressionObject.getExpression());\n        Assert.assertNull(definitionExpressionObject.getLanguage());\n\n        Attribute putAttribute = definition.getAttribute(\"put-attr\");\n        Assert.assertNotNull(putAttribute);\n        Assert.assertEquals(\"attr-val\", putAttribute.getValue());\n        Assert.assertEquals(\"attr-type\", putAttribute.getRenderer());\n        Assert.assertEquals(\"attr-role\", putAttribute.getRole());\n        Expression putAttrExpressionObject = putAttribute.getExpressionObject();\n        Assert.assertEquals(\"expr\", putAttrExpressionObject.getExpression());\n        Assert.assertEquals(\"lang\", putAttrExpressionObject.getLanguage());\n\n        Attribute listAttribute = definition.getAttribute(\"list-name\");\n        Assert.assertEquals(\"list-role\", listAttribute.getRole());\n        List<Attribute> listValue = getListValue(listAttribute);\n        Assert.assertEquals(2, listValue.size());\n\n        Attribute addAttribute = listValue.get(0);\n        Assert.assertEquals(\"list-attr-role\", addAttribute.getRole());\n        Assert.assertEquals(\"list-attr-val\", addAttribute.getValue());\n        Assert.assertEquals(\"list-attr-type\", addAttribute.getRenderer());\n        Expression addAttrExpressionObject = addAttribute.getExpressionObject();\n        Assert.assertEquals(\"list-attr-expr\", addAttrExpressionObject.getExpression());\n\n        Attribute addListAttribute = listValue.get(1);\n        Assert.assertEquals(\"list-list-attr-role\", addListAttribute.getRole());\n        List<Attribute> addListValue = getListValue(addListAttribute);\n        Assert.assertEquals(1, addListValue.size());\n        Assert.assertEquals(\"list-list-add-attr\", addListValue.get(0).getValue());\n\n        Set<String> cascadedAttributeNames = definition.getCascadedAttributeNames();\n        Assert.assertEquals(2, cascadedAttributeNames.size());\n        Assert.assertTrue(cascadedAttributeNames.contains(\"put-attr\"));\n        Assert.assertTrue(cascadedAttributeNames.contains(\"list-name\"));\n    }\n\n    @Test\n    public void buildDefinitonAllEmpty() {\n        StrutsTilesAnnotationProcessor annotationProcessor = new StrutsTilesAnnotationProcessor();\n        TilesDefinition tilesDefinition = annotationProcessor.findAnnotation(new TilesTestActionSingleAnnotationAllEmpty(), null);\n\n        Definition definition = annotationProcessor.buildTilesDefinition(null, tilesDefinition);\n\n        Assert.assertNotNull(definition);\n        Assert.assertNull(definition.getName());\n        Assert.assertNull(definition.getPreparer());\n        Assert.assertNull(definition.getExtends());\n        Attribute templateAttribute = definition.getTemplateAttribute();\n        Assert.assertNull(templateAttribute.getValue());\n        Assert.assertNull(templateAttribute.getRole());\n        Assert.assertNull(templateAttribute.getExpressionObject());\n\n        Attribute putAttribute = definition.getAttribute(\"put-attr\");\n        Assert.assertNotNull(putAttribute);\n        Assert.assertNull(putAttribute.getValue());\n        Assert.assertNull(putAttribute.getRenderer());\n        Assert.assertNull(putAttribute.getRole());\n        Assert.assertNull(putAttribute.getExpressionObject());\n\n        Attribute listAttribute = definition.getAttribute(\"list-name\");\n        Assert.assertNull(listAttribute.getRole());\n        List<Attribute> listValue = getListValue(listAttribute);\n        Assert.assertEquals(2, listValue.size());\n\n        Attribute addAttribute = listValue.get(0);\n        Assert.assertNull(addAttribute.getRole());\n        Assert.assertNull(addAttribute.getValue());\n        Assert.assertNull(addAttribute.getRenderer());\n        Assert.assertNull(addAttribute.getExpressionObject());\n\n        Attribute addListAttribute = listValue.get(1);\n        Assert.assertNull(addListAttribute.getRole());\n        List<Attribute> addListValue = getListValue(addListAttribute);\n        Assert.assertEquals(1, addListValue.size());\n        Assert.assertNull(addListValue.get(0).getValue());\n\n        Set<String> cascadedAttributeNames = definition.getCascadedAttributeNames();\n        Assert.assertNull(cascadedAttributeNames);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected List<Attribute> getListValue(Attribute listAttribute) {\n        return (List<Attribute>) listAttribute.getValue();\n    }\n}\n", "focal_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.tiles;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.struts2.tiles.annotation.TilesAddAttribute;\nimport org.apache.struts2.tiles.annotation.TilesAddListAttribute;\nimport org.apache.struts2.tiles.annotation.TilesDefinition;\nimport org.apache.struts2.tiles.annotation.TilesDefinitions;\nimport org.apache.struts2.tiles.annotation.TilesPutAttribute;\nimport org.apache.struts2.tiles.annotation.TilesPutListAttribute;\nimport org.apache.tiles.api.Attribute;\nimport org.apache.tiles.api.Definition;\nimport org.apache.tiles.api.Expression;\nimport org.apache.tiles.api.ListAttribute;\n\n/**\n * Processes tiles annotations to create {@link Definition}s and\n * {@link Attribute}s in a way as close to <code>tiles.xml</code> as possible.\n *\n */\npublic class StrutsTilesAnnotationProcessor {\n\n    /**\n     * Search strategy is as follows:\n     * <ul>\n     *   <li>Check if action has Annotation {@link TilesDefinition}</li>\n     *   <li>If not, check if action has Annotation {@link TilesDefinitions}</li>\n     *   <li>If given tileName is not null and present in {@link TilesDefinitions}, return it</li>\n     *   <li>Return first element of {@link TilesDefinitions}</li>\n     *   <li>Return null</li>\n     * </ul>\n     *\n     * @param action\n     *            Annotated action.\n     * @param tileName\n     *            Tilename to search for. May be null in some circumstances.\n     * @return {@link TilesDefinition}\n     */\n    public TilesDefinition findAnnotation(Object action, String tileName) {\n        Class<?> clazz = action.getClass();\n        TilesDefinition tilesDefinition = clazz.getAnnotation(TilesDefinition.class);\n        TilesDefinitions tilesDefinitions = clazz.getAnnotation(TilesDefinitions.class);\n\n        if (tilesDefinition == null && tilesDefinitions != null) {\n            if (!StringUtils.isEmpty(tileName)) {\n                for (TilesDefinition i : tilesDefinitions.value()) {\n                    if (i.name().equals(tileName)) {\n                        tilesDefinition = i;\n                        break;\n                    }\n                }\n            } else {\n                if (tilesDefinitions.value().length > 0) {\n                    tilesDefinition = tilesDefinitions.value()[0];\n                }\n            }\n        }\n\n        return tilesDefinition;\n    }\n\n    /**\n     * Builds a {@link Definition} based on given {@link TilesDefinition} with\n     * given name.\n     *\n     * @param tileName\n     *            name for resulting {@link Definition}.\n     * @param tilesDefinition\n     *            {@link TilesDefinition} to process.\n     * @return {@link Definition} represented by given {@link TilesDefinition}.\n     */\n    public Definition buildTilesDefinition(String tileName, TilesDefinition tilesDefinition) {\n        Definition definition = new Definition();\n\n        definition.setName(tileName);\n\n        String extend = getValueOrNull(tilesDefinition.extend());\n        if (extend != null) {\n            definition.setExtends(extend);\n        }\n        String preparer = getValueOrNull(tilesDefinition.preparer());\n        if (preparer != null) {\n            definition.setPreparer(preparer);\n        }\n        definition.setTemplateAttribute(buildTemplateAttribute(tilesDefinition));\n\n        for (TilesPutAttribute putAttribute : tilesDefinition.putAttributes()) {\n            Attribute attribute = buildPutAttribute(putAttribute);\n            definition.putAttribute(putAttribute.name(), attribute, putAttribute.cascade());\n        }\n        for (TilesPutListAttribute putListAttribute : tilesDefinition.putListAttributes()) {\n            Attribute attribute = buildPutListAttribute(putListAttribute);\n            definition.putAttribute(putListAttribute.name(), attribute, putListAttribute.cascade());\n        }\n\n        return definition;\n    }\n\n    protected Attribute buildTemplateAttribute(TilesDefinition tilesDef) {\n        // see tiles DigesterDefinitionsReader\n        Attribute attribute = Attribute.createTemplateAttribute(getValueOrNull(tilesDef.template()));\n        String templateExpression = getValueOrNull(tilesDef.templateExpression());\n        Expression expression = Expression.createExpressionFromDescribedExpression(templateExpression);\n        attribute.setExpressionObject(expression);\n        attribute.setRole(getValueOrNull(tilesDef.role()));\n        String templateType = getValueOrNull(tilesDef.templateType());\n        if (templateType != null) {\n            attribute.setRenderer(templateType);\n        } else if (getValueOrNull(tilesDef.extend()) != null) {\n            attribute.setRenderer(null);\n        }\n        return attribute;\n    }\n\n    protected Attribute buildPutAttribute(TilesPutAttribute putAttribute) {\n        Attribute attribute = new Attribute();\n        attribute.setValue(getValueOrNull(putAttribute.value()));\n        String expression = getValueOrNull(putAttribute.expression());\n        attribute.setExpressionObject(Expression.createExpressionFromDescribedExpression(expression));\n        attribute.setRole(getValueOrNull(putAttribute.role()));\n        attribute.setRenderer(getValueOrNull(putAttribute.type()));\n        return attribute;\n    }\n\n    protected Attribute buildPutListAttribute(TilesPutListAttribute putListAttribute) {\n        ListAttribute attribute = new ListAttribute();\n        attribute.setRole(getValueOrNull(putListAttribute.role()));\n        attribute.setInherit(putListAttribute.inherit());\n        for (TilesAddAttribute addAttribute : putListAttribute.addAttributes()) {\n            attribute.add(buildAddAttribute(addAttribute));\n        }\n        for (TilesAddListAttribute addListAttribute : putListAttribute.addListAttributes()) {\n            attribute.add(buildAddListAttribute(addListAttribute));\n        }\n        return attribute;\n    }\n\n    protected Attribute buildAddAttribute(TilesAddAttribute addAttribute) {\n        Attribute attribute = new Attribute();\n        attribute.setValue(getValueOrNull(addAttribute.value()));\n        String expression = getValueOrNull(addAttribute.expression());\n        attribute.setExpressionObject(Expression.createExpressionFromDescribedExpression(expression));\n        attribute.setRole(getValueOrNull(addAttribute.role()));\n        attribute.setRenderer(getValueOrNull(addAttribute.type()));\n        return attribute;\n    }\n\n    protected Attribute buildAddListAttribute(TilesAddListAttribute addListAttribute) {\n        ListAttribute attribute = new ListAttribute();\n        attribute.setRole(getValueOrNull(addListAttribute.role()));\n        for (TilesAddAttribute addAttribute : addListAttribute.addAttributes()) {\n            attribute.add(buildAddAttribute(addAttribute));\n        }\n        return attribute;\n    }\n\n    protected String getValueOrNull(String value) {\n        return value != null && value.length() > 0 ? value : null;\n    }\n}\n"}
{"test_method": "@Test\n    public void findAnnotationMultipleActionNameNull() {\n        StrutsTilesAnnotationProcessor annotationProcessor = new StrutsTilesAnnotationProcessor();\n        TilesDefinition tilesDefinition = annotationProcessor.findAnnotation(new TilesTestActionMultipleAnnotations(), null);\n        Assert.assertNotNull(tilesDefinition);\n        Assert.assertEquals(\"def1\", tilesDefinition.name());\n    }", "focal_method": "public TilesDefinition findAnnotation(Object action, String tileName) {\n        Class<?> clazz = action.getClass();\n        TilesDefinition tilesDefinition = clazz.getAnnotation(TilesDefinition.class);\n        TilesDefinitions tilesDefinitions = clazz.getAnnotation(TilesDefinitions.class);\n\n        if (tilesDefinition == null && tilesDefinitions != null) {\n            if (!StringUtils.isEmpty(tileName)) {\n                for (TilesDefinition i : tilesDefinitions.value()) {\n                    if (i.name().equals(tileName)) {\n                        tilesDefinition = i;\n                        break;\n                    }\n                }\n            } else {\n                if (tilesDefinitions.value().length > 0) {\n                    tilesDefinition = tilesDefinitions.value()[0];\n                }\n            }\n        }\n\n        return tilesDefinition;\n    }", "test_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.tiles;\n\nimport java.util.List;\nimport java.util.Set;\n\nimport org.apache.struts2.tiles.annotation.TilesDefinition;\nimport org.apache.tiles.api.Attribute;\nimport org.apache.tiles.api.Definition;\nimport org.apache.tiles.api.Expression;\nimport org.junit.Test;\n\nimport org.junit.Assert;\n\npublic class StrutsTilesAnnotationProcessorTest {\n\n    @Test\n    public void findAnnotationSingleAction() {\n        StrutsTilesAnnotationProcessor annotationProcessor = new StrutsTilesAnnotationProcessor();\n        TilesDefinition tilesDefinition = annotationProcessor.findAnnotation(new TilesTestActionSingleAnnotation(), null);\n        Assert.assertNotNull(tilesDefinition);\n        Assert.assertEquals(\"definition-name\", tilesDefinition.name());\n    }\n\n    @Test\n    public void findAnnotationMultipleActionNameNull() {\n        StrutsTilesAnnotationProcessor annotationProcessor = new StrutsTilesAnnotationProcessor();\n        TilesDefinition tilesDefinition = annotationProcessor.findAnnotation(new TilesTestActionMultipleAnnotations(), null);\n        Assert.assertNotNull(tilesDefinition);\n        Assert.assertEquals(\"def1\", tilesDefinition.name());\n    }\n\n    @Test\n    public void findAnnotationMultipleActionNameGiven() {\n        StrutsTilesAnnotationProcessor annotationProcessor = new StrutsTilesAnnotationProcessor();\n        TilesDefinition tilesDefinition = annotationProcessor.findAnnotation(new TilesTestActionMultipleAnnotations(), \"def2\");\n        Assert.assertNotNull(tilesDefinition);\n        Assert.assertEquals(\"def2\", tilesDefinition.name());\n    }\n\n    @Test\n    public void findAnnotationMultipleActionNotFound() {\n        StrutsTilesAnnotationProcessor annotationProcessor = new StrutsTilesAnnotationProcessor();\n        TilesDefinition tilesDefinition = annotationProcessor.findAnnotation(new TilesTestActionMultipleAnnotations(), \"def3\");\n        Assert.assertNull(tilesDefinition);\n    }\n\n    @Test\n    public void buildDefiniton() {\n        StrutsTilesAnnotationProcessor annotationProcessor = new StrutsTilesAnnotationProcessor();\n        TilesDefinition tilesDefinition = annotationProcessor.findAnnotation(new TilesTestActionSingleAnnotation(), null);\n\n        Definition definition = annotationProcessor.buildTilesDefinition(\"tileName\", tilesDefinition);\n\n        Assert.assertNotNull(definition);\n        Assert.assertEquals(\"tileName\", definition.getName());\n        Assert.assertEquals(\"preparer\", definition.getPreparer());\n        Assert.assertEquals(\"base-definition\", definition.getExtends());\n        Attribute templateAttribute = definition.getTemplateAttribute();\n        Assert.assertEquals(\"template\", templateAttribute.getValue());\n        Assert.assertEquals(\"type\", templateAttribute.getRenderer());\n        Assert.assertEquals(\"role\", templateAttribute.getRole());\n        Expression definitionExpressionObject = templateAttribute.getExpressionObject();\n        Assert.assertEquals(\"templ*\", definitionExpressionObject.getExpression());\n        Assert.assertNull(definitionExpressionObject.getLanguage());\n\n        Attribute putAttribute = definition.getAttribute(\"put-attr\");\n        Assert.assertNotNull(putAttribute);\n        Assert.assertEquals(\"attr-val\", putAttribute.getValue());\n        Assert.assertEquals(\"attr-type\", putAttribute.getRenderer());\n        Assert.assertEquals(\"attr-role\", putAttribute.getRole());\n        Expression putAttrExpressionObject = putAttribute.getExpressionObject();\n        Assert.assertEquals(\"expr\", putAttrExpressionObject.getExpression());\n        Assert.assertEquals(\"lang\", putAttrExpressionObject.getLanguage());\n\n        Attribute listAttribute = definition.getAttribute(\"list-name\");\n        Assert.assertEquals(\"list-role\", listAttribute.getRole());\n        List<Attribute> listValue = getListValue(listAttribute);\n        Assert.assertEquals(2, listValue.size());\n\n        Attribute addAttribute = listValue.get(0);\n        Assert.assertEquals(\"list-attr-role\", addAttribute.getRole());\n        Assert.assertEquals(\"list-attr-val\", addAttribute.getValue());\n        Assert.assertEquals(\"list-attr-type\", addAttribute.getRenderer());\n        Expression addAttrExpressionObject = addAttribute.getExpressionObject();\n        Assert.assertEquals(\"list-attr-expr\", addAttrExpressionObject.getExpression());\n\n        Attribute addListAttribute = listValue.get(1);\n        Assert.assertEquals(\"list-list-attr-role\", addListAttribute.getRole());\n        List<Attribute> addListValue = getListValue(addListAttribute);\n        Assert.assertEquals(1, addListValue.size());\n        Assert.assertEquals(\"list-list-add-attr\", addListValue.get(0).getValue());\n\n        Set<String> cascadedAttributeNames = definition.getCascadedAttributeNames();\n        Assert.assertEquals(2, cascadedAttributeNames.size());\n        Assert.assertTrue(cascadedAttributeNames.contains(\"put-attr\"));\n        Assert.assertTrue(cascadedAttributeNames.contains(\"list-name\"));\n    }\n\n    @Test\n    public void buildDefinitonAllEmpty() {\n        StrutsTilesAnnotationProcessor annotationProcessor = new StrutsTilesAnnotationProcessor();\n        TilesDefinition tilesDefinition = annotationProcessor.findAnnotation(new TilesTestActionSingleAnnotationAllEmpty(), null);\n\n        Definition definition = annotationProcessor.buildTilesDefinition(null, tilesDefinition);\n\n        Assert.assertNotNull(definition);\n        Assert.assertNull(definition.getName());\n        Assert.assertNull(definition.getPreparer());\n        Assert.assertNull(definition.getExtends());\n        Attribute templateAttribute = definition.getTemplateAttribute();\n        Assert.assertNull(templateAttribute.getValue());\n        Assert.assertNull(templateAttribute.getRole());\n        Assert.assertNull(templateAttribute.getExpressionObject());\n\n        Attribute putAttribute = definition.getAttribute(\"put-attr\");\n        Assert.assertNotNull(putAttribute);\n        Assert.assertNull(putAttribute.getValue());\n        Assert.assertNull(putAttribute.getRenderer());\n        Assert.assertNull(putAttribute.getRole());\n        Assert.assertNull(putAttribute.getExpressionObject());\n\n        Attribute listAttribute = definition.getAttribute(\"list-name\");\n        Assert.assertNull(listAttribute.getRole());\n        List<Attribute> listValue = getListValue(listAttribute);\n        Assert.assertEquals(2, listValue.size());\n\n        Attribute addAttribute = listValue.get(0);\n        Assert.assertNull(addAttribute.getRole());\n        Assert.assertNull(addAttribute.getValue());\n        Assert.assertNull(addAttribute.getRenderer());\n        Assert.assertNull(addAttribute.getExpressionObject());\n\n        Attribute addListAttribute = listValue.get(1);\n        Assert.assertNull(addListAttribute.getRole());\n        List<Attribute> addListValue = getListValue(addListAttribute);\n        Assert.assertEquals(1, addListValue.size());\n        Assert.assertNull(addListValue.get(0).getValue());\n\n        Set<String> cascadedAttributeNames = definition.getCascadedAttributeNames();\n        Assert.assertNull(cascadedAttributeNames);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected List<Attribute> getListValue(Attribute listAttribute) {\n        return (List<Attribute>) listAttribute.getValue();\n    }\n}\n", "focal_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.tiles;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.struts2.tiles.annotation.TilesAddAttribute;\nimport org.apache.struts2.tiles.annotation.TilesAddListAttribute;\nimport org.apache.struts2.tiles.annotation.TilesDefinition;\nimport org.apache.struts2.tiles.annotation.TilesDefinitions;\nimport org.apache.struts2.tiles.annotation.TilesPutAttribute;\nimport org.apache.struts2.tiles.annotation.TilesPutListAttribute;\nimport org.apache.tiles.api.Attribute;\nimport org.apache.tiles.api.Definition;\nimport org.apache.tiles.api.Expression;\nimport org.apache.tiles.api.ListAttribute;\n\n/**\n * Processes tiles annotations to create {@link Definition}s and\n * {@link Attribute}s in a way as close to <code>tiles.xml</code> as possible.\n *\n */\npublic class StrutsTilesAnnotationProcessor {\n\n    /**\n     * Search strategy is as follows:\n     * <ul>\n     *   <li>Check if action has Annotation {@link TilesDefinition}</li>\n     *   <li>If not, check if action has Annotation {@link TilesDefinitions}</li>\n     *   <li>If given tileName is not null and present in {@link TilesDefinitions}, return it</li>\n     *   <li>Return first element of {@link TilesDefinitions}</li>\n     *   <li>Return null</li>\n     * </ul>\n     *\n     * @param action\n     *            Annotated action.\n     * @param tileName\n     *            Tilename to search for. May be null in some circumstances.\n     * @return {@link TilesDefinition}\n     */\n    public TilesDefinition findAnnotation(Object action, String tileName) {\n        Class<?> clazz = action.getClass();\n        TilesDefinition tilesDefinition = clazz.getAnnotation(TilesDefinition.class);\n        TilesDefinitions tilesDefinitions = clazz.getAnnotation(TilesDefinitions.class);\n\n        if (tilesDefinition == null && tilesDefinitions != null) {\n            if (!StringUtils.isEmpty(tileName)) {\n                for (TilesDefinition i : tilesDefinitions.value()) {\n                    if (i.name().equals(tileName)) {\n                        tilesDefinition = i;\n                        break;\n                    }\n                }\n            } else {\n                if (tilesDefinitions.value().length > 0) {\n                    tilesDefinition = tilesDefinitions.value()[0];\n                }\n            }\n        }\n\n        return tilesDefinition;\n    }\n\n    /**\n     * Builds a {@link Definition} based on given {@link TilesDefinition} with\n     * given name.\n     *\n     * @param tileName\n     *            name for resulting {@link Definition}.\n     * @param tilesDefinition\n     *            {@link TilesDefinition} to process.\n     * @return {@link Definition} represented by given {@link TilesDefinition}.\n     */\n    public Definition buildTilesDefinition(String tileName, TilesDefinition tilesDefinition) {\n        Definition definition = new Definition();\n\n        definition.setName(tileName);\n\n        String extend = getValueOrNull(tilesDefinition.extend());\n        if (extend != null) {\n            definition.setExtends(extend);\n        }\n        String preparer = getValueOrNull(tilesDefinition.preparer());\n        if (preparer != null) {\n            definition.setPreparer(preparer);\n        }\n        definition.setTemplateAttribute(buildTemplateAttribute(tilesDefinition));\n\n        for (TilesPutAttribute putAttribute : tilesDefinition.putAttributes()) {\n            Attribute attribute = buildPutAttribute(putAttribute);\n            definition.putAttribute(putAttribute.name(), attribute, putAttribute.cascade());\n        }\n        for (TilesPutListAttribute putListAttribute : tilesDefinition.putListAttributes()) {\n            Attribute attribute = buildPutListAttribute(putListAttribute);\n            definition.putAttribute(putListAttribute.name(), attribute, putListAttribute.cascade());\n        }\n\n        return definition;\n    }\n\n    protected Attribute buildTemplateAttribute(TilesDefinition tilesDef) {\n        // see tiles DigesterDefinitionsReader\n        Attribute attribute = Attribute.createTemplateAttribute(getValueOrNull(tilesDef.template()));\n        String templateExpression = getValueOrNull(tilesDef.templateExpression());\n        Expression expression = Expression.createExpressionFromDescribedExpression(templateExpression);\n        attribute.setExpressionObject(expression);\n        attribute.setRole(getValueOrNull(tilesDef.role()));\n        String templateType = getValueOrNull(tilesDef.templateType());\n        if (templateType != null) {\n            attribute.setRenderer(templateType);\n        } else if (getValueOrNull(tilesDef.extend()) != null) {\n            attribute.setRenderer(null);\n        }\n        return attribute;\n    }\n\n    protected Attribute buildPutAttribute(TilesPutAttribute putAttribute) {\n        Attribute attribute = new Attribute();\n        attribute.setValue(getValueOrNull(putAttribute.value()));\n        String expression = getValueOrNull(putAttribute.expression());\n        attribute.setExpressionObject(Expression.createExpressionFromDescribedExpression(expression));\n        attribute.setRole(getValueOrNull(putAttribute.role()));\n        attribute.setRenderer(getValueOrNull(putAttribute.type()));\n        return attribute;\n    }\n\n    protected Attribute buildPutListAttribute(TilesPutListAttribute putListAttribute) {\n        ListAttribute attribute = new ListAttribute();\n        attribute.setRole(getValueOrNull(putListAttribute.role()));\n        attribute.setInherit(putListAttribute.inherit());\n        for (TilesAddAttribute addAttribute : putListAttribute.addAttributes()) {\n            attribute.add(buildAddAttribute(addAttribute));\n        }\n        for (TilesAddListAttribute addListAttribute : putListAttribute.addListAttributes()) {\n            attribute.add(buildAddListAttribute(addListAttribute));\n        }\n        return attribute;\n    }\n\n    protected Attribute buildAddAttribute(TilesAddAttribute addAttribute) {\n        Attribute attribute = new Attribute();\n        attribute.setValue(getValueOrNull(addAttribute.value()));\n        String expression = getValueOrNull(addAttribute.expression());\n        attribute.setExpressionObject(Expression.createExpressionFromDescribedExpression(expression));\n        attribute.setRole(getValueOrNull(addAttribute.role()));\n        attribute.setRenderer(getValueOrNull(addAttribute.type()));\n        return attribute;\n    }\n\n    protected Attribute buildAddListAttribute(TilesAddListAttribute addListAttribute) {\n        ListAttribute attribute = new ListAttribute();\n        attribute.setRole(getValueOrNull(addListAttribute.role()));\n        for (TilesAddAttribute addAttribute : addListAttribute.addAttributes()) {\n            attribute.add(buildAddAttribute(addAttribute));\n        }\n        return attribute;\n    }\n\n    protected String getValueOrNull(String value) {\n        return value != null && value.length() > 0 ? value : null;\n    }\n}\n"}
{"test_method": "@Test\n    public void testExponentialNumber2() throws Exception {\n        Object ret = reader.read(\"123.4e10\");\n        assertNotNull(ret);\n        assertEquals(Double.class, ret.getClass());\n        assertEquals(123.4e10, ret);\n    }", "focal_method": "public Object read(String string) throws JSONException {\n        this.it = new StringCharacterIterator(string);\n        this.c = this.it.first();\n\n        return this.read();\n    }", "test_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.json;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\n\n/**\n * User: mcucchiara\n * Date: 10/11/11\n * Time: 17.26\n */\npublic class JSONReaderTest {\n    private JSONReader reader = new JSONReader();\n\n    @Test\n    public void testExponentialNumber() throws Exception {\n        Object ret = reader.read(\"5e-5\");\n        assertNotNull(ret);\n        assertEquals(Double.class, ret.getClass());\n        assertEquals(5.0E-5, ret);\n    }\n\n    @Test\n    public void testExponentialNumber2() throws Exception {\n        Object ret = reader.read(\"123.4e10\");\n        assertNotNull(ret);\n        assertEquals(Double.class, ret.getClass());\n        assertEquals(123.4e10, ret);\n    }\n\n    @Test\n    public void testDecimalNumber() throws Exception {\n        Object ret = reader.read(\"3.2\");\n        assertNotNull(ret);\n        assertEquals(Double.class, ret.getClass());\n        assertEquals(3.2, ret);\n    }\n\n    @Test\n    public void testNaturalNumber() throws Exception {\n        Object ret = reader.read(\"123\");\n        assertNotNull(ret);\n        assertEquals(Long.class, ret.getClass());\n        assertEquals(123L, ret);\n    }\n}\n", "focal_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.json;\n\nimport java.text.CharacterIterator;\nimport java.text.StringCharacterIterator;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * <p>\n * Deserializes and object from a JSON string\n * </p>\n */\npublic class JSONReader {\n    private static final Object OBJECT_END = new Object();\n    private static final Object ARRAY_END = new Object();\n    private static final Object COLON = new Object();\n    private static final Object COMMA = new Object();\n    private static Map<Character, Character> escapes = new HashMap<Character, Character>();\n\n    static {\n        escapes.put('\"', '\"');\n        escapes.put('\\\\', '\\\\');\n        escapes.put('/', '/');\n        escapes.put('b', '\\b');\n        escapes.put('f', '\\f');\n        escapes.put('n', '\\n');\n        escapes.put('r', '\\r');\n        escapes.put('t', '\\t');\n    }\n\n    private CharacterIterator it;\n    private char c;\n    private Object token;\n    private StringBuilder buf = new StringBuilder();\n\n    protected char next() {\n        this.c = this.it.next();\n\n        return this.c;\n    }\n\n    protected void skipWhiteSpace() {\n        while (Character.isWhitespace(this.c)) {\n            this.next();\n        }\n    }\n\n    public Object read(String string) throws JSONException {\n        this.it = new StringCharacterIterator(string);\n        this.c = this.it.first();\n\n        return this.read();\n    }\n\n    protected Object read() throws JSONException {\n        Object ret;\n\n        this.skipWhiteSpace();\n\n        if (this.c == '\"') {\n            this.next();\n            ret = this.string('\"');\n        } else if (this.c == '\\'') {\n            this.next();\n            ret = this.string('\\'');\n        } else if (this.c == '[') {\n            this.next();\n            ret = this.array();\n        } else if (this.c == ']') {\n            ret = ARRAY_END;\n            this.next();\n        } else if (this.c == ',') {\n            ret = COMMA;\n            this.next();\n        } else if (this.c == '{') {\n            this.next();\n            ret = this.object();\n        } else if (this.c == '}') {\n            ret = OBJECT_END;\n            this.next();\n        } else if (this.c == ':') {\n            ret = COLON;\n            this.next();\n        } else if ((this.c == 't') && (this.next() == 'r') && (this.next() == 'u') && (this.next() == 'e')) {\n            ret = Boolean.TRUE;\n            this.next();\n        } else if ((this.c == 'f') && (this.next() == 'a') && (this.next() == 'l') && (this.next() == 's')\n                && (this.next() == 'e')) {\n            ret = Boolean.FALSE;\n            this.next();\n        } else if ((this.c == 'n') && (this.next() == 'u') && (this.next() == 'l') && (this.next() == 'l')) {\n            ret = null;\n            this.next();\n        } else if (Character.isDigit(this.c) || (this.c == '-')) {\n            ret = this.number();\n        } else {\n            throw buildInvalidInputException();\n        }\n\n        this.token = ret;\n\n        return ret;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected Map object() throws JSONException {\n        Map ret = new HashMap();\n        Object next = this.read();\n        if (next != OBJECT_END) {\n            String key = (String) next;\n            while (this.token != OBJECT_END) {\n                this.read(); // should be a colon\n\n                if (this.token != OBJECT_END) {\n                    ret.put(key, this.read());\n\n                    if (this.read() == COMMA) {\n                        Object name = this.read();\n\n                        if (name instanceof String) {\n                            key = (String) name;\n                        } else\n                            throw buildInvalidInputException();\n                    }\n                }\n            }\n        }\n\n        return ret;\n    }\n\n    protected JSONException buildInvalidInputException() {\n        return new JSONException(\"Input string is not well formed JSON (invalid char \" + this.c + \")\");\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    protected List array() throws JSONException {\n        List ret = new ArrayList();\n        Object value = this.read();\n\n        while (this.token != ARRAY_END) {\n            ret.add(value);\n\n            Object read = this.read();\n            if (read == COMMA) {\n                value = this.read();\n            } else if (read != ARRAY_END) {\n                throw buildInvalidInputException();\n            }\n        }\n\n        return ret;\n    }\n\n    protected Object number() throws JSONException {\n        this.buf.setLength(0);\n        boolean toDouble = false;\n\n        if (this.c == '-') {\n            this.add();\n        }\n\n        this.addDigits();\n\n        if (this.c == '.') {\n            toDouble = true;\n            this.add();\n            this.addDigits();\n        }\n\n        if ((this.c == 'e') || (this.c == 'E')) {\n            toDouble = true;\n            this.add();\n\n            if ((this.c == '+') || (this.c == '-')) {\n                this.add();\n            }\n\n            this.addDigits();\n        }\n\n        if (toDouble) {\n            try {\n                return Double.parseDouble(this.buf.toString());\n            } catch (NumberFormatException e) {\n                throw buildInvalidInputException();\n            }\n        } else {\n            try {\n                return Long.parseLong(this.buf.toString());\n            } catch (NumberFormatException e) {\n                throw buildInvalidInputException();\n            }\n        }\n    }\n\n    protected Object string(char quote) {\n        this.buf.setLength(0);\n\n        while ((this.c != quote) && (this.c != CharacterIterator.DONE)) {\n            if (this.c == '\\\\') {\n                this.next();\n\n                if (this.c == 'u') {\n                    this.add(this.unicode());\n                } else {\n                    Object value = escapes.get(this.c);\n\n                    if (value != null) {\n                        this.add((Character) value);\n                    }\n                }\n            } else {\n                this.add();\n            }\n        }\n\n        this.next();\n\n        return this.buf.toString();\n    }\n\n    protected void add(char cc) {\n        this.buf.append(cc);\n        this.next();\n    }\n\n    protected void add() {\n        this.add(this.c);\n    }\n\n    protected void addDigits() {\n        while (Character.isDigit(this.c)) {\n            this.add();\n        }\n    }\n\n    protected char unicode() {\n        int value = 0;\n\n        for (int i = 0; i < 4; ++i) {\n            switch (this.next()) {\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n                value = (value << 4) + (this.c - '0');\n\n                break;\n\n            case 'a':\n            case 'b':\n            case 'c':\n            case 'd':\n            case 'e':\n            case 'f':\n                value = (value << 4) + (this.c - 'W');\n\n                break;\n\n            case 'A':\n            case 'B':\n            case 'C':\n            case 'D':\n            case 'E':\n            case 'F':\n                value = (value << 4) + (this.c - '7');\n\n                break;\n            }\n        }\n\n        return (char) value;\n    }\n}\n"}
{"test_method": "@Test\n    public void testArrayObject() throws Exception {\n        // given\n        RequiredFieldValidator rfv = container.inject(RequiredFieldValidator.class);\n        rfv.setValueStack(ActionContext.getContext().getValueStack());\n        rfv.setFieldName(\"ints\");\n        rfv.setDefaultMessage(\"${fieldName} field is required!\");\n        ValidationAction action = new ValidationAction();\n        action.setInts(new Integer[]{});\n        DummyValidatorContext context = new DummyValidatorContext(action, container.getInstance(TextProviderFactory.class));\n        rfv.setValidatorContext(context);\n\n        // when\n        rfv.validate(action);\n\n        // then\n        assertTrue(context.hasFieldErrors());\n        assertEquals(1, context.getFieldErrors().size());\n        assertNotNull(context.getFieldErrors().get(\"ints\"));\n        assertEquals(\"ints field is required!\", context.getFieldErrors().get(\"ints\").get(0));\n    }", "focal_method": "public void validate(Object object) throws ValidationException {\n        String fieldName = getFieldName();\n        Object value = this.getFieldValue(fieldName, object);\n\n        if (value == null) {\n            addFieldError(fieldName, object);\n        } else if (value.getClass().isArray() && Array.getLength(value) == 0) {\n            addFieldError(fieldName, object);\n        } else if (Collection.class.isAssignableFrom(value.getClass()) && ((Collection) value).size() == 0) {\n            addFieldError(fieldName, object);\n        }\n    }", "test_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2.validator.validators;\n\nimport com.opensymphony.xwork2.ActionContext;\nimport com.opensymphony.xwork2.TextProviderFactory;\nimport com.opensymphony.xwork2.validator.DummyValidatorContext;\nimport org.apache.struts2.StrutsInternalTestCase;\nimport org.junit.Test;\n\nimport java.util.ArrayList;\n\npublic class RequiredFieldValidatorTest extends StrutsInternalTestCase {\n\n    @Test\n    public void testNullObject() throws Exception {\n        // given\n        RequiredFieldValidator rfv = container.inject(RequiredFieldValidator.class);\n        rfv.setValueStack(ActionContext.getContext().getValueStack());\n        rfv.setFieldName(\"stringValue\");\n        rfv.setDefaultMessage(\"${fieldName} field is required!\");\n        ValidationAction action = new ValidationAction();\n        DummyValidatorContext context = new DummyValidatorContext(action, container.getInstance(TextProviderFactory.class));\n        rfv.setValidatorContext(context);\n\n        // when\n        rfv.validate(action);\n\n        // then\n        assertTrue(context.hasFieldErrors());\n        assertEquals(1, context.getFieldErrors().size());\n        assertNotNull(context.getFieldErrors().get(\"stringValue\"));\n        assertEquals(\"stringValue field is required!\", context.getFieldErrors().get(\"stringValue\").get(0));\n    }\n\n    @Test\n    public void testArrayObject() throws Exception {\n        // given\n        RequiredFieldValidator rfv = container.inject(RequiredFieldValidator.class);\n        rfv.setValueStack(ActionContext.getContext().getValueStack());\n        rfv.setFieldName(\"ints\");\n        rfv.setDefaultMessage(\"${fieldName} field is required!\");\n        ValidationAction action = new ValidationAction();\n        action.setInts(new Integer[]{});\n        DummyValidatorContext context = new DummyValidatorContext(action, container.getInstance(TextProviderFactory.class));\n        rfv.setValidatorContext(context);\n\n        // when\n        rfv.validate(action);\n\n        // then\n        assertTrue(context.hasFieldErrors());\n        assertEquals(1, context.getFieldErrors().size());\n        assertNotNull(context.getFieldErrors().get(\"ints\"));\n        assertEquals(\"ints field is required!\", context.getFieldErrors().get(\"ints\").get(0));\n    }\n    \n    @Test\n    public void testCollectionObject() throws Exception {\n        // given\n        RequiredFieldValidator rfv = container.inject(RequiredFieldValidator.class);\n        rfv.setValueStack(ActionContext.getContext().getValueStack());\n        rfv.setFieldName(\"shorts\");\n        rfv.setDefaultMessage(\"${fieldName} field is required!\");\n        ValidationAction action = new ValidationAction();\n        action.setShorts(new ArrayList<Short>());\n        DummyValidatorContext context = new DummyValidatorContext(action, container.getInstance(TextProviderFactory.class));\n        rfv.setValidatorContext(context);\n\n        // when\n        rfv.validate(action);\n\n        // then\n        assertTrue(context.hasFieldErrors());\n        assertEquals(1, context.getFieldErrors().size());\n        assertNotNull(context.getFieldErrors().get(\"shorts\"));\n        assertEquals(\"shorts field is required!\", context.getFieldErrors().get(\"shorts\").get(0));\n    }\n\n}", "focal_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2.validator.validators;\n\nimport com.opensymphony.xwork2.validator.ValidationException;\n\nimport java.lang.reflect.Array;\nimport java.util.Collection;\n\n/**\n * <!-- START SNIPPET: javadoc -->\n * RequiredFieldValidator checks if the specified field is not null.\n * <!-- END SNIPPET: javadoc -->\n *\n * <!-- START SNIPPET: parameters -->\n * <ul>\n * \t\t<li>fieldName - field name if plain-validator syntax is used, not needed if field-validator syntax is used</li>\n * </ul>\n * <!-- END SNIPPET: parameters -->\n *\n * <pre>\n * <!-- START SNIPPET: example -->\n * \t   &lt;validators&gt;\n * \n *         &lt;!-- Plain Validator Syntax --&gt;\n *         &lt;validator type=\"required\"&gt;\n *             &lt;param name=\"fieldName\"&gt;username&lt;/param&gt;\n *             &lt;message&gt;username must not be null&lt;/message&gt;\n *         &lt;/validator&gt;\n * \n * \n *         &lt;!-- Field Validator Syntax --&gt;\n *         &lt;field name=\"username\"&gt;\n *             &lt;field-validator type=\"required\"&gt;\n *             \t   &lt;message&gt;username must not be null&lt;/message&gt;\n *             &lt;/field-validator&gt;\n *         &lt;/field&gt;\n * \n *     &lt;/validators&gt;\n * <!-- END SNIPPET: example -->\n * </pre>\n * \n * \n *\n * @author rainerh\n */\npublic class RequiredFieldValidator extends FieldValidatorSupport {\n\n    public void validate(Object object) throws ValidationException {\n        String fieldName = getFieldName();\n        Object value = this.getFieldValue(fieldName, object);\n\n        if (value == null) {\n            addFieldError(fieldName, object);\n        } else if (value.getClass().isArray() && Array.getLength(value) == 0) {\n            addFieldError(fieldName, object);\n        } else if (Collection.class.isAssignableFrom(value.getClass()) && ((Collection) value).size() == 0) {\n            addFieldError(fieldName, object);\n        }\n    }\n}\n"}
{"test_method": "@Test\n    public void testNullObject() throws Exception {\n        // given\n        RequiredFieldValidator rfv = container.inject(RequiredFieldValidator.class);\n        rfv.setValueStack(ActionContext.getContext().getValueStack());\n        rfv.setFieldName(\"stringValue\");\n        rfv.setDefaultMessage(\"${fieldName} field is required!\");\n        ValidationAction action = new ValidationAction();\n        DummyValidatorContext context = new DummyValidatorContext(action, container.getInstance(TextProviderFactory.class));\n        rfv.setValidatorContext(context);\n\n        // when\n        rfv.validate(action);\n\n        // then\n        assertTrue(context.hasFieldErrors());\n        assertEquals(1, context.getFieldErrors().size());\n        assertNotNull(context.getFieldErrors().get(\"stringValue\"));\n        assertEquals(\"stringValue field is required!\", context.getFieldErrors().get(\"stringValue\").get(0));\n    }", "focal_method": "public void validate(Object object) throws ValidationException {\n        String fieldName = getFieldName();\n        Object value = this.getFieldValue(fieldName, object);\n\n        if (value == null) {\n            addFieldError(fieldName, object);\n        } else if (value.getClass().isArray() && Array.getLength(value) == 0) {\n            addFieldError(fieldName, object);\n        } else if (Collection.class.isAssignableFrom(value.getClass()) && ((Collection) value).size() == 0) {\n            addFieldError(fieldName, object);\n        }\n    }", "test_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2.validator.validators;\n\nimport com.opensymphony.xwork2.ActionContext;\nimport com.opensymphony.xwork2.TextProviderFactory;\nimport com.opensymphony.xwork2.validator.DummyValidatorContext;\nimport org.apache.struts2.StrutsInternalTestCase;\nimport org.junit.Test;\n\nimport java.util.ArrayList;\n\npublic class RequiredFieldValidatorTest extends StrutsInternalTestCase {\n\n    @Test\n    public void testNullObject() throws Exception {\n        // given\n        RequiredFieldValidator rfv = container.inject(RequiredFieldValidator.class);\n        rfv.setValueStack(ActionContext.getContext().getValueStack());\n        rfv.setFieldName(\"stringValue\");\n        rfv.setDefaultMessage(\"${fieldName} field is required!\");\n        ValidationAction action = new ValidationAction();\n        DummyValidatorContext context = new DummyValidatorContext(action, container.getInstance(TextProviderFactory.class));\n        rfv.setValidatorContext(context);\n\n        // when\n        rfv.validate(action);\n\n        // then\n        assertTrue(context.hasFieldErrors());\n        assertEquals(1, context.getFieldErrors().size());\n        assertNotNull(context.getFieldErrors().get(\"stringValue\"));\n        assertEquals(\"stringValue field is required!\", context.getFieldErrors().get(\"stringValue\").get(0));\n    }\n\n    @Test\n    public void testArrayObject() throws Exception {\n        // given\n        RequiredFieldValidator rfv = container.inject(RequiredFieldValidator.class);\n        rfv.setValueStack(ActionContext.getContext().getValueStack());\n        rfv.setFieldName(\"ints\");\n        rfv.setDefaultMessage(\"${fieldName} field is required!\");\n        ValidationAction action = new ValidationAction();\n        action.setInts(new Integer[]{});\n        DummyValidatorContext context = new DummyValidatorContext(action, container.getInstance(TextProviderFactory.class));\n        rfv.setValidatorContext(context);\n\n        // when\n        rfv.validate(action);\n\n        // then\n        assertTrue(context.hasFieldErrors());\n        assertEquals(1, context.getFieldErrors().size());\n        assertNotNull(context.getFieldErrors().get(\"ints\"));\n        assertEquals(\"ints field is required!\", context.getFieldErrors().get(\"ints\").get(0));\n    }\n    \n    @Test\n    public void testCollectionObject() throws Exception {\n        // given\n        RequiredFieldValidator rfv = container.inject(RequiredFieldValidator.class);\n        rfv.setValueStack(ActionContext.getContext().getValueStack());\n        rfv.setFieldName(\"shorts\");\n        rfv.setDefaultMessage(\"${fieldName} field is required!\");\n        ValidationAction action = new ValidationAction();\n        action.setShorts(new ArrayList<Short>());\n        DummyValidatorContext context = new DummyValidatorContext(action, container.getInstance(TextProviderFactory.class));\n        rfv.setValidatorContext(context);\n\n        // when\n        rfv.validate(action);\n\n        // then\n        assertTrue(context.hasFieldErrors());\n        assertEquals(1, context.getFieldErrors().size());\n        assertNotNull(context.getFieldErrors().get(\"shorts\"));\n        assertEquals(\"shorts field is required!\", context.getFieldErrors().get(\"shorts\").get(0));\n    }\n\n}", "focal_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2.validator.validators;\n\nimport com.opensymphony.xwork2.validator.ValidationException;\n\nimport java.lang.reflect.Array;\nimport java.util.Collection;\n\n/**\n * <!-- START SNIPPET: javadoc -->\n * RequiredFieldValidator checks if the specified field is not null.\n * <!-- END SNIPPET: javadoc -->\n *\n * <!-- START SNIPPET: parameters -->\n * <ul>\n * \t\t<li>fieldName - field name if plain-validator syntax is used, not needed if field-validator syntax is used</li>\n * </ul>\n * <!-- END SNIPPET: parameters -->\n *\n * <pre>\n * <!-- START SNIPPET: example -->\n * \t   &lt;validators&gt;\n * \n *         &lt;!-- Plain Validator Syntax --&gt;\n *         &lt;validator type=\"required\"&gt;\n *             &lt;param name=\"fieldName\"&gt;username&lt;/param&gt;\n *             &lt;message&gt;username must not be null&lt;/message&gt;\n *         &lt;/validator&gt;\n * \n * \n *         &lt;!-- Field Validator Syntax --&gt;\n *         &lt;field name=\"username\"&gt;\n *             &lt;field-validator type=\"required\"&gt;\n *             \t   &lt;message&gt;username must not be null&lt;/message&gt;\n *             &lt;/field-validator&gt;\n *         &lt;/field&gt;\n * \n *     &lt;/validators&gt;\n * <!-- END SNIPPET: example -->\n * </pre>\n * \n * \n *\n * @author rainerh\n */\npublic class RequiredFieldValidator extends FieldValidatorSupport {\n\n    public void validate(Object object) throws ValidationException {\n        String fieldName = getFieldName();\n        Object value = this.getFieldValue(fieldName, object);\n\n        if (value == null) {\n            addFieldError(fieldName, object);\n        } else if (value.getClass().isArray() && Array.getLength(value) == 0) {\n            addFieldError(fieldName, object);\n        } else if (Collection.class.isAssignableFrom(value.getClass()) && ((Collection) value).size() == 0) {\n            addFieldError(fieldName, object);\n        }\n    }\n}\n"}
{"test_method": "@Test\n\tpublic void testSanitizeInputPathShouldReturnNullForNullInput() throws Exception {\n\t\tassertNull(fileDownloadAction.sanitizeInputPath(null));\n\t}", "focal_method": "String sanitizeInputPath( String value ) {\n\t\tif (value != null && value.toUpperCase().contains(\"WEB-INF\")) {\n\t\t\treturn null;\n\t\t}\n\t\treturn value;\n\t}", "test_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.showcase.filedownload;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static junit.framework.Assert.assertEquals;\nimport static junit.framework.Assert.assertNull;\n\npublic class FileDownloadActionTest {\n\n\tprivate FileDownloadAction fileDownloadAction;\n\n\t@Before\n\tpublic void setUp() {\n\t    this.fileDownloadAction = new FileDownloadAction();\n\t}\n\n\t@Test\n\tpublic void testSanitizeInputPathShouldAllowSimpleParameter() throws Exception {\n\t\tassertEquals(\"foo\", fileDownloadAction.sanitizeInputPath(\"foo\"));\n\t}\n\n\t@Test\n\tpublic void testSanitizeInputPathShouldReturnNullForNullInput() throws Exception {\n\t\tassertNull(fileDownloadAction.sanitizeInputPath(null));\n\t}\n\n\t@Test\n\tpublic void testSanitizeInputPathShouldReturnNullForLeadingWebInf() throws Exception {\n\t\tassertNull(fileDownloadAction.sanitizeInputPath(\"WEB-INF/foo\"));\n\t}\n\n\t@Test\n\tpublic void testSanitizeInputPathShouldReturnNullForNonLeadingWebInf() throws Exception {\n\t\tassertNull(fileDownloadAction.sanitizeInputPath(\"./WEB-INF/foo\"));\n\t}\n\n\t@Test\n\tpublic void testSanitizeInputPathShouldReturnNullForNonUppercaseWebInf() throws Exception {\n\t\tassertNull(fileDownloadAction.sanitizeInputPath(\"./wEB-Inf/foo\"));\n\t}\n}\n", "focal_file": "/*\n * $Id$\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.showcase.filedownload;\n\nimport com.opensymphony.xwork2.Action;\nimport org.apache.struts2.ServletActionContext;\n\nimport java.io.InputStream;\n\n/**\n * Demonstrates file resource download.\n * Set filePath to the local file resource to download,\n * relative to the application root (\"/images/struts.gif\").\n */\npublic class FileDownloadAction implements Action {\n\n\tprivate String inputPath;\n\n\tpublic String execute() throws Exception {\n\t\treturn SUCCESS;\n\t}\n\n\tpublic void setInputPath(String value) {\n\t\tinputPath = sanitizeInputPath(value);\n\t}\n\n\t/**\n\t * As the user modifiable parameter inputPath will be used to access server side resources, we want the path to be\n\t * sanitized - in this case it is demonstrated to disallow inputPath parameter values containing \"WEB-INF\". Consider to\n\t * use even stricter rules in production environments.\n\t *\n\t * @param value the raw parameter input value to sanitize\n\t *\n\t * @return the sanitized value; <tt>null</tt> if value contains an invalid path segment like WEB-INF\n\t */\n\tString sanitizeInputPath( String value ) {\n\t\tif (value != null && value.toUpperCase().contains(\"WEB-INF\")) {\n\t\t\treturn null;\n\t\t}\n\t\treturn value;\n\t}\n\n\tpublic InputStream getInputStream() throws Exception {\n\t\treturn ServletActionContext.getServletContext().getResourceAsStream(inputPath);\n\t}\n}\n"}
{"test_method": "@Test\n    public void testWrite() throws Exception {\n        Bean bean1=new Bean();\n        bean1.setStringField(\"str\");\n        bean1.setBooleanField(true);\n        bean1.setCharField('s');\n        bean1.setDoubleField(10.1);\n        bean1.setFloatField(1.5f);\n        bean1.setIntField(10);\n        bean1.setLongField(100);\n        bean1.setEnumField(AnEnum.ValueA);\n        bean1.setEnumBean(AnEnumBean.Two);\n\n        JSONWriter jsonWriter = new DefaultJSONWriter();\n        jsonWriter.setEnumAsBean(false);\n        String json = jsonWriter.write(bean1);\n        TestUtils.assertEquals(DefaultJSONWriter.class.getResource(\"jsonwriter-write-bean-01.txt\"), json);\n    }", "focal_method": "@Override\n    public String write(Object object) throws JSONException {\n        return this.write(object, null, null, false);\n    }", "test_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.json;\n\nimport org.apache.struts2.json.annotations.JSONFieldBridge;\nimport org.apache.struts2.json.bridge.StringBridge;\nimport org.apache.struts2.junit.StrutsTestCase;\nimport org.apache.struts2.junit.util.TestUtils;\nimport org.junit.Test;\n\nimport java.net.URL;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TimeZone;\n\npublic class DefaultJSONWriterTest extends StrutsTestCase {\n    @Test\n    public void testWrite() throws Exception {\n        Bean bean1 = new Bean();\n        bean1.setStringField(\"str\");\n        bean1.setBooleanField(true);\n        bean1.setCharField('s');\n        bean1.setDoubleField(10.1);\n        bean1.setFloatField(1.5f);\n        bean1.setIntField(10);\n        bean1.setLongField(100);\n        bean1.setEnumField(AnEnum.ValueA);\n        bean1.setEnumBean(AnEnumBean.Two);\n\n        JSONWriter jsonWriter = new DefaultJSONWriter();\n        jsonWriter.setEnumAsBean(false);\n        String json = jsonWriter.write(bean1);\n        TestUtils.assertEquals(DefaultJSONWriter.class.getResource(\"jsonwriter-write-bean-01.txt\"), json);\n    }\n\n    @Test\n    public void testWriteExcludeNull() throws Exception {\n        BeanWithMap bean1 = new BeanWithMap();\n        bean1.setStringField(\"str\");\n        bean1.setBooleanField(true);\n        bean1.setCharField('s');\n        bean1.setDoubleField(10.1);\n        bean1.setFloatField(1.5f);\n        bean1.setIntField(10);\n        bean1.setLongField(100);\n        bean1.setEnumField(AnEnum.ValueA);\n        bean1.setEnumBean(AnEnumBean.Two);\n\n        Map m = new LinkedHashMap();\n        m.put(\"a\", \"x\");\n        m.put(\"b\", null);\n        m.put(\"c\", \"z\");\n        bean1.setMap(m);\n\n        JSONWriter jsonWriter = new DefaultJSONWriter();\n        jsonWriter.setEnumAsBean(false);\n        jsonWriter.setIgnoreHierarchy(false);\n        String json = jsonWriter.write(bean1, null, null, true);\n        TestUtils.assertEquals(DefaultJSONWriter.class.getResource(\"jsonwriter-write-bean-03.txt\"), json);\n    }\n\n    private class BeanWithMap extends Bean {\n        private Map map;\n\n        public Map getMap() {\n            return map;\n        }\n\n        public void setMap(Map map) {\n            this.map = map;\n        }\n    }\n\n    @Test\n    public void testWriteAnnotatedBean() throws Exception {\n        AnnotatedBean bean1 = new AnnotatedBean();\n        bean1.setStringField(\"str\");\n        bean1.setBooleanField(true);\n        bean1.setCharField('s');\n        bean1.setDoubleField(10.1);\n        bean1.setFloatField(1.5f);\n        bean1.setIntField(10);\n        bean1.setLongField(100);\n        bean1.setEnumField(AnEnum.ValueA);\n        bean1.setEnumBean(AnEnumBean.Two);\n        bean1.setUrl(new URL(\"http://www.google.com\"));\n\n        JSONWriter jsonWriter = new DefaultJSONWriter();\n        jsonWriter.setEnumAsBean(false);\n        jsonWriter.setIgnoreHierarchy(false);\n        String json = jsonWriter.write(bean1);\n        TestUtils.assertEquals(DefaultJSONWriter.class.getResource(\"jsonwriter-write-bean-02.txt\"), json);\n    }\n\n    @Test\n    public void testWriteBeanWithList() throws Exception {\n        BeanWithList bean1 = new BeanWithList();\n        bean1.setStringField(\"str\");\n        bean1.setBooleanField(true);\n        bean1.setCharField('s');\n        bean1.setDoubleField(10.1);\n        bean1.setFloatField(1.5f);\n        bean1.setIntField(10);\n        bean1.setLongField(100);\n        bean1.setEnumField(AnEnum.ValueA);\n        bean1.setEnumBean(AnEnumBean.Two);\n        List<String> errors = new ArrayList<String>();\n        errors.add(\"Field is required\");\n        bean1.setErrors(errors);\n\n        JSONWriter jsonWriter = new DefaultJSONWriter();\n        jsonWriter.setEnumAsBean(false);\n        jsonWriter.setIgnoreHierarchy(false);\n        String json = jsonWriter.write(bean1);\n        TestUtils.assertEquals(DefaultJSONWriter.class.getResource(\"jsonwriter-write-bean-04.txt\"), json);\n    }\n\n    private class BeanWithList extends Bean {\n        private List<String> errors;\n\n        public List<String> getErrors() {\n            return errors;\n        }\n\n        public void setErrors(List<String> errors) {\n            this.errors = errors;\n        }\n    }\n\n    private class AnnotatedBean extends Bean {\n        private URL url;\n\n        @JSONFieldBridge(impl = StringBridge.class)\n        public URL getUrl() {\n            return url;\n        }\n\n        public void setUrl(URL url) {\n            this.url = url;\n        }\n    }\n\n    @Test\n    public void testCanSerializeADate() throws Exception {\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss z\");\n\n        SingleDateBean dateBean = new SingleDateBean();\n        dateBean.setDate(sdf.parse(\"2012-12-23 10:10:10 GMT\"));\n\n        JSONWriter jsonWriter = new DefaultJSONWriter();\n        jsonWriter.setEnumAsBean(false);\n\n        TimeZone.setDefault(TimeZone.getTimeZone(\"GMT\"));\n        String json = jsonWriter.write(dateBean);\n        assertEquals(\"{\\\"date\\\":\\\"2012-12-23T10:10:10\\\"}\", json);\n    }\n\n    @Test\n    public void testCanSetDefaultDateFormat() throws Exception {\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss z\");\n\n        SingleDateBean dateBean = new SingleDateBean();\n        dateBean.setDate(sdf.parse(\"2012-12-23 10:10:10 GMT\"));\n\n        JSONWriter jsonWriter = new DefaultJSONWriter();\n        jsonWriter.setEnumAsBean(false);\n        jsonWriter.setDateFormatter(\"MM-dd-yyyy\");\n        String json = jsonWriter.write(dateBean);\n        assertEquals(\"{\\\"date\\\":\\\"12-23-2012\\\"}\", json);\n    }\n\n}\n", "focal_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.json;\n\nimport com.opensymphony.xwork2.inject.Inject;\nimport com.opensymphony.xwork2.util.ProxyUtil;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.struts2.json.annotations.JSON;\nimport org.apache.struts2.json.annotations.JSONFieldBridge;\nimport org.apache.struts2.json.annotations.JSONParameter;\nimport org.apache.struts2.json.bridge.FieldBridge;\nimport org.apache.struts2.json.bridge.ParameterizedBridge;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Method;\nimport java.text.CharacterIterator;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.text.StringCharacterIterator;\nimport java.util.Calendar;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Stack;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.regex.Pattern;\n\n/**\n * <p>\n * Serializes an object into JavaScript Object Notation (JSON). If cyclic\n * references are detected they will be nulled out.\n * </p>\n */\npublic class DefaultJSONWriter implements JSONWriter {\n\n    private static final Logger LOG = LogManager.getLogger(DefaultJSONWriter.class);\n\n    private static char[] hex = \"0123456789ABCDEF\".toCharArray();\n\n    private static final ConcurrentMap<Class<?>, BeanInfo> BEAN_INFO_CACHE_IGNORE_HIERARCHY = new ConcurrentHashMap<>();\n    private static final ConcurrentMap<Class<?>, BeanInfo> BEAN_INFO_CACHE = new ConcurrentHashMap<>();\n\n    private StringBuilder buf = new StringBuilder();\n    private Stack<Object> stack = new Stack<>();\n    private boolean ignoreHierarchy = true;\n    private Object root;\n    private boolean buildExpr = true;\n    private String exprStack = \"\";\n    private Collection<Pattern> excludeProperties;\n    private Collection<Pattern> includeProperties;\n    private DateFormat formatter;\n    private boolean enumAsBean = ENUM_AS_BEAN_DEFAULT;\n    private boolean excludeNullProperties;\n    private boolean cacheBeanInfo = true;\n    private boolean excludeProxyProperties;\n\n    @Inject(value = JSONConstants.RESULT_EXCLUDE_PROXY_PROPERTIES, required = false)\n    public void setExcludeProxyProperties(String excludeProxyProperties) {\n        setExcludeProxyProperties(Boolean.parseBoolean(excludeProxyProperties));\n    }\n\n    /**\n     * @param object Object to be serialized into JSON\n     * @return JSON string for object\n     * @throws JSONException in case of error during serialize\n     */\n    @Override\n    public String write(Object object) throws JSONException {\n        return this.write(object, null, null, false);\n    }\n\n    /**\n     * @param object\n     *            Object to be serialized into JSON\n     * @param excludeProperties\n     *            Patterns matching properties to ignore\n     * @param includeProperties\n     *            Patterns matching properties to include\n     * @param excludeNullProperties\n     *            enable/disable excluding of null properties\n     * @return JSON string for object\n     * @throws JSONException in case of error during serialize\n     */\n    @Override\n    public String write(Object object, Collection<Pattern> excludeProperties,\n                        Collection<Pattern> includeProperties, boolean excludeNullProperties) throws JSONException {\n        this.excludeNullProperties = excludeNullProperties;\n        this.buf.setLength(0);\n        this.stack.clear();\n        this.root = object;\n        this.exprStack = \"\";\n        this.buildExpr = ((excludeProperties != null) && !excludeProperties.isEmpty())\n                || ((includeProperties != null) && !includeProperties.isEmpty());\n        this.excludeProperties = excludeProperties;\n        this.includeProperties = includeProperties;\n        this.value(object, null);\n\n        return this.buf.toString();\n    }\n\n    /**\n     * Detect cyclic references\n     *\n     * @param object Object to be serialized into JSON\n     * @param method method\n     *\n     * @throws JSONException in case of error during serialize\n     */\n    protected void value(Object object, Method method) throws JSONException {\n        if (object == null) {\n            this.add(\"null\");\n            return;\n        }\n\n        if (this.stack.contains(object)) {\n            Class clazz = object.getClass();\n\n            // cyclic reference\n            if (clazz.isPrimitive() || clazz.equals(String.class)) {\n                this.process(object, method);\n            } else {\n                LOG.debug(\"Cyclic reference detected on {}\", object);\n                this.add(\"null\");\n            }\n\n            return;\n        }\n\n        this.process(object, method);\n    }\n\n    /**\n     * Serialize object into json\n     *\n     * @param object Object to be serialized into JSON\n     * @param method method\n     *\n     * @throws JSONException  in case of error during serialize\n     */\n    protected void process(Object object, Method method) throws JSONException {\n        this.stack.push(object);\n\n        if (object instanceof Class) {\n            this.string(object);\n        } else if (object instanceof Boolean) {\n            this.bool((Boolean) object);\n        } else if (object instanceof Number) {\n            this.add(object);\n        } else if (object instanceof String) {\n            this.string(object);\n        } else if (object instanceof Character) {\n            this.string(object);\n        } else if (object instanceof Map) {\n            this.map((Map) object, method);\n        } else if (object.getClass().isArray()) {\n            this.array(object, method);\n        } else if (object instanceof Iterable) {\n            this.array(((Iterable) object).iterator(), method);\n        } else if (object instanceof Date) {\n            this.date((Date) object, method);\n        } else if (object instanceof Calendar) {\n            this.date(((Calendar) object).getTime(), method);\n        } else if (object instanceof Locale) {\n            this.string(object);\n        } else if (object instanceof Enum) {\n            this.enumeration((Enum) object);\n        } else {\n            processCustom(object, method);\n        }\n\n        this.stack.pop();\n    }\n\n    /**\n     * Serialize custom object into json\n     *\n     * @param object object\n     * @param method method\n     *\n     * @throws JSONException  in case of error during serialize\n     */\n    protected void processCustom(Object object, Method method) throws JSONException {\n        this.bean(object);\n    }\n\n    /**\n     * Instrospect bean and serialize its properties\n     *\n     * @param object object\n     *\n     * @throws JSONException  in case of error during serialize\n     */\n    protected void bean(Object object) throws JSONException {\n        this.add(\"{\");\n\n        BeanInfo info;\n\n        try {\n            Class clazz = excludeProxyProperties ? ProxyUtil.ultimateTargetClass(object) : object.getClass();\n\n            info = ((object == this.root) && this.ignoreHierarchy)\n                    ? getBeanInfoIgnoreHierarchy(clazz)\n                    : getBeanInfo(clazz);\n\n            PropertyDescriptor[] props = info.getPropertyDescriptors();\n\n            boolean hasData = false;\n            for (PropertyDescriptor prop : props) {\n                String name = prop.getName();\n                Method accessor = prop.getReadMethod();\n                Method baseAccessor = findBaseAccessor(clazz, accessor);\n\n                if (baseAccessor != null) {\n                    if (baseAccessor.isAnnotationPresent(JSON.class)) {\n                        JSONAnnotationFinder jsonFinder = new JSONAnnotationFinder(baseAccessor).invoke();\n\n                        if (!jsonFinder.shouldSerialize()) continue;\n                        if (jsonFinder.getName() != null) {\n                            name = jsonFinder.getName();\n                        }\n                    }\n                    // ignore \"class\" and others\n                    if (this.shouldExcludeProperty(prop)) {\n                        continue;\n                    }\n                    String expr = null;\n                    if (this.buildExpr) {\n                        expr = this.expandExpr(name);\n                        if (this.shouldExcludeProperty(expr)) {\n                            continue;\n                        }\n                        expr = this.setExprStack(expr);\n                    }\n\n                    Object value = accessor.invoke(object);\n                    if (baseAccessor.isAnnotationPresent(JSONFieldBridge.class)) {\n                        value = getBridgedValue(baseAccessor, value);\n                    }\n\n                    boolean propertyPrinted = this.add(name, value, accessor, hasData);\n                    hasData = hasData || propertyPrinted;\n                    if (this.buildExpr) {\n                        this.setExprStack(expr);\n                    }\n                }\n            }\n\n            // special-case handling for an Enumeration - include the name() as\n            // a property */\n            if (object instanceof Enum) {\n                Object value = ((Enum) object).name();\n                this.add(\"_name\", value, object.getClass().getMethod(\"name\"), hasData);\n            }\n        } catch (Exception e) {\n            throw new JSONException(e);\n        }\n\n        this.add(\"}\");\n    }\n\n    protected BeanInfo getBeanInfoIgnoreHierarchy(final Class<?> clazz) throws IntrospectionException {\n        BeanInfo beanInfo = BEAN_INFO_CACHE_IGNORE_HIERARCHY.get(clazz);\n        if (beanInfo != null) {\n            return beanInfo;\n        }\n        beanInfo = Introspector.getBeanInfo(clazz, clazz.getSuperclass());\n        BEAN_INFO_CACHE_IGNORE_HIERARCHY.put(clazz, beanInfo);\n        return beanInfo;\n    }\n\n    protected BeanInfo getBeanInfo(final Class<?> clazz) throws IntrospectionException {\n        BeanInfo beanInfo = BEAN_INFO_CACHE.get(clazz);\n        if (beanInfo != null) {\n            return beanInfo;\n        }\n        beanInfo = Introspector.getBeanInfo(clazz);\n        BEAN_INFO_CACHE.put(clazz, beanInfo);\n        return beanInfo;\n    }\n\n    protected Object getBridgedValue(Method baseAccessor, Object value) throws InstantiationException, IllegalAccessException {\n        JSONFieldBridge fieldBridgeAnn = baseAccessor.getAnnotation(JSONFieldBridge.class);\n        if (fieldBridgeAnn != null) {\n            Class impl = fieldBridgeAnn.impl();\n            FieldBridge instance = (FieldBridge) impl.newInstance();\n\n            if (fieldBridgeAnn.params().length > 0 && ParameterizedBridge.class.isAssignableFrom(impl)) {\n                Map<String, String> params = new HashMap<>(fieldBridgeAnn.params().length);\n                for (JSONParameter param : fieldBridgeAnn.params()) {\n                    params.put(param.name(), param.value());\n                }\n                ((ParameterizedBridge) instance).setParameterValues(params);\n            }\n            value = instance.objectToString(value);\n        }\n        return value;\n    }\n\n    protected Method findBaseAccessor(Class clazz, Method accessor) {\n        Method baseAccessor = null;\n        if (clazz.getName().contains(\"$$EnhancerByCGLIB$$\")) {\n            try {\n                baseAccessor = Thread.currentThread().getContextClassLoader().loadClass(\n                        clazz.getName().substring(0, clazz.getName().indexOf(\"$$\"))).getMethod(\n                        accessor.getName(), accessor.getParameterTypes());\n            } catch (Exception ex) {\n                LOG.debug(ex.getMessage(), ex);\n            }\n        } else if (clazz.getName().contains(\"$$_javassist\")) {\n            try {\n                baseAccessor = Class.forName(\n                        clazz.getName().substring(0, clazz.getName().indexOf(\"_$$\")))\n                        .getMethod(accessor.getName(), accessor.getParameterTypes());\n            } catch (Exception ex) {\n                LOG.debug(ex.getMessage(), ex);\n            }\n            \n        //in hibernate4.3.7,because javassist3.18.1's class name generate rule is '_$$_jvst'+...\n        } else if(clazz.getName().contains(\"$$_jvst\")){\n            try {\n                baseAccessor = Class.forName(\n                        clazz.getName().substring(0, clazz.getName().indexOf(\"_$$\")))\n                        .getMethod(accessor.getName(), accessor.getParameterTypes());\n            } catch (Exception ex) {\n                LOG.debug(ex.getMessage(), ex);\n            }\n        }\n        else {\n            return accessor;\n        }\n        return baseAccessor;\n    }\n\n    /**\n     * Instrospect an Enum and serialize it as a name/value pair or as a bean\n     * including all its own properties\n     *\n     * @param enumeration the enum\n     *\n     * @throws JSONException  in case of error during serialize\n     */\n    protected void enumeration(Enum enumeration) throws JSONException {\n        if (enumAsBean) {\n            this.bean(enumeration);\n        } else {\n            this.string(enumeration.name());\n        }\n    }\n\n    protected boolean shouldExcludeProperty(PropertyDescriptor prop) throws SecurityException, NoSuchFieldException {\n        String name = prop.getName();\n        return name.equals(\"class\")\n                || name.equals(\"declaringClass\")\n                || name.equals(\"cachedSuperClass\")\n                || name.equals(\"metaClass\");\n    }\n\n    protected String expandExpr(int i) {\n        return this.exprStack + \"[\" + i + \"]\";\n    }\n\n    protected String expandExpr(String property) {\n        if (this.exprStack.length() == 0) {\n            return property;\n        }\n        return this.exprStack + \".\" + property;\n    }\n\n    protected String setExprStack(String expr) {\n        String s = this.exprStack;\n        this.exprStack = expr;\n        return s;\n    }\n\n    protected boolean shouldExcludeProperty(String expr) {\n        if (this.excludeProperties != null) {\n            for (Pattern pattern : this.excludeProperties) {\n                if (pattern.matcher(expr).matches()) {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Ignoring property because of exclude rule: \" + expr);\n                    }\n                    return true;\n                }\n            }\n        }\n\n        if (this.includeProperties != null) {\n            for (Pattern pattern : this.includeProperties) {\n                if (pattern.matcher(expr).matches()) {\n                    return false;\n                }\n            }\n            if (LOG.isDebugEnabled()){\n                LOG.debug(\"Ignoring property because of include rule:  \" + expr);\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /*\n     * Add name/value pair to buffer\n     */\n    protected boolean add(String name, Object value, Method method, boolean hasData) throws JSONException {\n        if (excludeNullProperties && value == null) {\n            return false;\n        }\n        if (hasData) {\n            this.add(',');\n        }\n        this.add('\"');\n        this.add(name);\n        this.add(\"\\\":\");\n        this.value(value, method);\n        return true;\n    }\n\n    /*\n     * Add map to buffer\n     */\n    protected void map(Map map, Method method) throws JSONException {\n        this.add(\"{\");\n\n        Iterator it = map.entrySet().iterator();\n\n        boolean warnedNonString = false; // one report per map\n        boolean hasData = false;\n        while (it.hasNext()) {\n            Map.Entry entry = (Map.Entry) it.next();\n            if (excludeNullProperties && entry.getValue() == null) {\n                continue;\n            }\n\n            Object key = entry.getKey();\n            if (key == null) {\n                LOG.error(\"Cannot build expression for null key in {}\", exprStack);\n                continue;\n            }\n\n            String expr = null;\n            if (this.buildExpr) {\n                expr = this.expandExpr(key.toString());\n                if (this.shouldExcludeProperty(expr)) {\n                    continue;\n                }\n                expr = this.setExprStack(expr);\n            }\n            if (hasData) {\n                this.add(',');\n            }\n            hasData = true;\n            if (!warnedNonString && !(key instanceof String)) {\n                if (LOG.isWarnEnabled()) {\n                    LOG.warn(\"JavaScript doesn't support non-String keys, using toString() on {}\", key.getClass().getName());\n                }\n                warnedNonString = true;\n            }\n            this.value(key.toString(), method);\n            this.add(\":\");\n            this.value(entry.getValue(), method);\n            if (this.buildExpr) {\n                this.setExprStack(expr);\n            }\n        }\n\n        this.add(\"}\");\n    }\n\n    /*\n     * Add date to buffer\n     */\n    protected void date(Date date, Method method) {\n        JSON json = null;\n        if (method != null)\n            json = method.getAnnotation(JSON.class);\n        if (this.formatter == null)\n            this.formatter = new SimpleDateFormat(JSONUtil.RFC3339_FORMAT);\n\n        DateFormat formatter = (json != null) && (json.format().length() > 0) ? new SimpleDateFormat(json\n                .format()) : this.formatter;\n        this.string(formatter.format(date));\n    }\n\n    /*\n     * Add array to buffer\n     */\n    protected void array(Iterator it, Method method) throws JSONException {\n        this.add(\"[\");\n\n        boolean hasData = false;\n        for (int i = 0; it.hasNext(); i++) {\n            String expr = null;\n            if (this.buildExpr) {\n                expr = this.expandExpr(i);\n                if (this.shouldExcludeProperty(expr)) {\n                    it.next();\n                    continue;\n                }\n                expr = this.setExprStack(expr);\n            }\n            if (hasData) {\n                this.add(',');\n            }\n            hasData = true;\n            this.value(it.next(), method);\n            if (this.buildExpr) {\n                this.setExprStack(expr);\n            }\n        }\n\n        this.add(\"]\");\n    }\n\n    /*\n     * Add array to buffer\n     */\n    protected void array(Object object, Method method) throws JSONException {\n        this.add(\"[\");\n\n        int length = Array.getLength(object);\n\n        boolean hasData = false;\n        for (int i = 0; i < length; ++i) {\n            String expr = null;\n            if (this.buildExpr) {\n                expr = this.expandExpr(i);\n                if (this.shouldExcludeProperty(expr)) {\n                    continue;\n                }\n                expr = this.setExprStack(expr);\n            }\n            if (hasData) {\n                this.add(',');\n            }\n            hasData = true;\n            this.value(Array.get(object, i), method);\n            if (this.buildExpr) {\n                this.setExprStack(expr);\n            }\n        }\n\n        this.add(\"]\");\n    }\n\n    /*\n     * Add boolean to buffer\n     */\n    protected void bool(boolean b) {\n        this.add(b ? \"true\" : \"false\");\n    }\n\n    /**\n     * escape characters\n     *\n     * @param obj the object to escape\n     */\n    protected void string(Object obj) {\n        this.add('\"');\n\n        CharacterIterator it = new StringCharacterIterator(obj.toString());\n\n        for (char c = it.first(); c != CharacterIterator.DONE; c = it.next()) {\n            if (c == '\"') {\n                this.add(\"\\\\\\\"\");\n            } else if (c == '\\\\') {\n                this.add(\"\\\\\\\\\");\n            } else if (c == '/') {\n                this.add(\"\\\\/\");\n            } else if (c == '\\b') {\n                this.add(\"\\\\b\");\n            } else if (c == '\\f') {\n                this.add(\"\\\\f\");\n            } else if (c == '\\n') {\n                this.add(\"\\\\n\");\n            } else if (c == '\\r') {\n                this.add(\"\\\\r\");\n            } else if (c == '\\t') {\n                this.add(\"\\\\t\");\n            } else if (Character.isISOControl(c)) {\n                this.unicode(c);\n            } else {\n                this.add(c);\n            }\n        }\n\n        this.add('\"');\n    }\n\n    /*\n     * Add object to buffer\n     */\n    protected void add(Object obj) {\n        this.buf.append(obj);\n    }\n\n    /*\n     * Add char to buffer\n     */\n    protected void add(char c) {\n        this.buf.append(c);\n    }\n\n    /**\n     * Represent as unicode\n     *\n     * @param c character to be encoded\n     */\n    protected void unicode(char c) {\n        this.add(\"\\\\u\");\n\n        int n = c;\n\n        for (int i = 0; i < 4; ++i) {\n            int digit = (n & 0xf000) >> 12;\n\n            this.add(hex[digit]);\n            n <<= 4;\n        }\n    }\n\n    @Override\n    public void setIgnoreHierarchy(boolean ignoreHierarchy) {\n        this.ignoreHierarchy = ignoreHierarchy;\n    }\n\n    /**\n     * If true, an Enum is serialized as a bean with a special property\n     * _name=name() as all as all other properties defined within the enum.<br>\n     * If false, an Enum is serialized as a name=value pair (name=name())\n     *\n     * @param enumAsBean true to serialize an enum as a bean instead of as a name=value\n     *                   pair (default=false)\n     */\n    @Override\n    public void setEnumAsBean(boolean enumAsBean) {\n        this.enumAsBean = enumAsBean;\n    }\n\n    @Override\n    public void setDateFormatter(String defaultDateFormat) {\n        if (defaultDateFormat != null) {\n            this.formatter = new SimpleDateFormat(defaultDateFormat);\n        }\n    }\n    \n    @Override\n    public void setCacheBeanInfo(boolean cacheBeanInfo) {\n    \tthis.cacheBeanInfo = cacheBeanInfo;\n    }\n\n    @Override\n    public void setExcludeProxyProperties(boolean excludeProxyProperties) {\n        this.excludeProxyProperties = excludeProxyProperties;\n    }\n\n    protected static class JSONAnnotationFinder {\n        private boolean serialize = true;\n        private Method accessor;\n        private String name;\n\n        public JSONAnnotationFinder(Method accessor) {\n            this.accessor = accessor;\n        }\n\n        public boolean shouldSerialize() {\n            return serialize;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n\n        public JSONAnnotationFinder invoke() {\n            JSON json = accessor.getAnnotation(JSON.class);\n            serialize = json.serialize();\n            if (serialize && json.name().length() > 0) {\n                name = json.name();\n            }\n            return this;\n        }\n    }\n\n}\n"}
{"test_method": "@Test\n    public void testExponentialNumber() throws Exception {\n        Object ret = reader.read(\"5e-5\");\n        assertNotNull(ret);\n        assertEquals(Double.class, ret.getClass());\n        assertEquals(5.0E-5, ret);\n    }", "focal_method": "public Object read(String string) throws JSONException {\n        this.it = new StringCharacterIterator(string);\n        this.c = this.it.first();\n\n        return this.read();\n    }", "test_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.json;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\n\n/**\n * User: mcucchiara\n * Date: 10/11/11\n * Time: 17.26\n */\npublic class JSONReaderTest {\n    private JSONReader reader = new JSONReader();\n\n    @Test\n    public void testExponentialNumber() throws Exception {\n        Object ret = reader.read(\"5e-5\");\n        assertNotNull(ret);\n        assertEquals(Double.class, ret.getClass());\n        assertEquals(5.0E-5, ret);\n    }\n\n    @Test\n    public void testExponentialNumber2() throws Exception {\n        Object ret = reader.read(\"123.4e10\");\n        assertNotNull(ret);\n        assertEquals(Double.class, ret.getClass());\n        assertEquals(123.4e10, ret);\n    }\n\n    @Test\n    public void testDecimalNumber() throws Exception {\n        Object ret = reader.read(\"3.2\");\n        assertNotNull(ret);\n        assertEquals(Double.class, ret.getClass());\n        assertEquals(3.2, ret);\n    }\n\n    @Test\n    public void testNaturalNumber() throws Exception {\n        Object ret = reader.read(\"123\");\n        assertNotNull(ret);\n        assertEquals(Long.class, ret.getClass());\n        assertEquals(123L, ret);\n    }\n}\n", "focal_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.json;\n\nimport java.text.CharacterIterator;\nimport java.text.StringCharacterIterator;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * <p>\n * Deserializes and object from a JSON string\n * </p>\n */\npublic class JSONReader {\n    private static final Object OBJECT_END = new Object();\n    private static final Object ARRAY_END = new Object();\n    private static final Object COLON = new Object();\n    private static final Object COMMA = new Object();\n    private static Map<Character, Character> escapes = new HashMap<Character, Character>();\n\n    static {\n        escapes.put('\"', '\"');\n        escapes.put('\\\\', '\\\\');\n        escapes.put('/', '/');\n        escapes.put('b', '\\b');\n        escapes.put('f', '\\f');\n        escapes.put('n', '\\n');\n        escapes.put('r', '\\r');\n        escapes.put('t', '\\t');\n    }\n\n    private CharacterIterator it;\n    private char c;\n    private Object token;\n    private StringBuilder buf = new StringBuilder();\n\n    protected char next() {\n        this.c = this.it.next();\n\n        return this.c;\n    }\n\n    protected void skipWhiteSpace() {\n        while (Character.isWhitespace(this.c)) {\n            this.next();\n        }\n    }\n\n    public Object read(String string) throws JSONException {\n        this.it = new StringCharacterIterator(string);\n        this.c = this.it.first();\n\n        return this.read();\n    }\n\n    protected Object read() throws JSONException {\n        Object ret;\n\n        this.skipWhiteSpace();\n\n        if (this.c == '\"') {\n            this.next();\n            ret = this.string('\"');\n        } else if (this.c == '\\'') {\n            this.next();\n            ret = this.string('\\'');\n        } else if (this.c == '[') {\n            this.next();\n            ret = this.array();\n        } else if (this.c == ']') {\n            ret = ARRAY_END;\n            this.next();\n        } else if (this.c == ',') {\n            ret = COMMA;\n            this.next();\n        } else if (this.c == '{') {\n            this.next();\n            ret = this.object();\n        } else if (this.c == '}') {\n            ret = OBJECT_END;\n            this.next();\n        } else if (this.c == ':') {\n            ret = COLON;\n            this.next();\n        } else if ((this.c == 't') && (this.next() == 'r') && (this.next() == 'u') && (this.next() == 'e')) {\n            ret = Boolean.TRUE;\n            this.next();\n        } else if ((this.c == 'f') && (this.next() == 'a') && (this.next() == 'l') && (this.next() == 's')\n                && (this.next() == 'e')) {\n            ret = Boolean.FALSE;\n            this.next();\n        } else if ((this.c == 'n') && (this.next() == 'u') && (this.next() == 'l') && (this.next() == 'l')) {\n            ret = null;\n            this.next();\n        } else if (Character.isDigit(this.c) || (this.c == '-')) {\n            ret = this.number();\n        } else {\n            throw buildInvalidInputException();\n        }\n\n        this.token = ret;\n\n        return ret;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected Map object() throws JSONException {\n        Map ret = new HashMap();\n        Object next = this.read();\n        if (next != OBJECT_END) {\n            String key = (String) next;\n            while (this.token != OBJECT_END) {\n                this.read(); // should be a colon\n\n                if (this.token != OBJECT_END) {\n                    ret.put(key, this.read());\n\n                    if (this.read() == COMMA) {\n                        Object name = this.read();\n\n                        if (name instanceof String) {\n                            key = (String) name;\n                        } else\n                            throw buildInvalidInputException();\n                    }\n                }\n            }\n        }\n\n        return ret;\n    }\n\n    protected JSONException buildInvalidInputException() {\n        return new JSONException(\"Input string is not well formed JSON (invalid char \" + this.c + \")\");\n    }\n\n    \n    @SuppressWarnings(\"unchecked\")\n    protected List array() throws JSONException {\n        List ret = new ArrayList();\n        Object value = this.read();\n\n        while (this.token != ARRAY_END) {\n            ret.add(value);\n\n            Object read = this.read();\n            if (read == COMMA) {\n                value = this.read();\n            } else if (read != ARRAY_END) {\n                throw buildInvalidInputException();\n            }\n        }\n\n        return ret;\n    }\n\n    protected Object number() throws JSONException {\n        this.buf.setLength(0);\n        boolean toDouble = false;\n\n        if (this.c == '-') {\n            this.add();\n        }\n\n        this.addDigits();\n\n        if (this.c == '.') {\n            toDouble = true;\n            this.add();\n            this.addDigits();\n        }\n\n        if ((this.c == 'e') || (this.c == 'E')) {\n            toDouble = true;\n            this.add();\n\n            if ((this.c == '+') || (this.c == '-')) {\n                this.add();\n            }\n\n            this.addDigits();\n        }\n\n        if (toDouble) {\n            try {\n                return Double.parseDouble(this.buf.toString());\n            } catch (NumberFormatException e) {\n                throw buildInvalidInputException();\n            }\n        } else {\n            try {\n                return Long.parseLong(this.buf.toString());\n            } catch (NumberFormatException e) {\n                throw buildInvalidInputException();\n            }\n        }\n    }\n\n    protected Object string(char quote) {\n        this.buf.setLength(0);\n\n        while ((this.c != quote) && (this.c != CharacterIterator.DONE)) {\n            if (this.c == '\\\\') {\n                this.next();\n\n                if (this.c == 'u') {\n                    this.add(this.unicode());\n                } else {\n                    Object value = escapes.get(this.c);\n\n                    if (value != null) {\n                        this.add((Character) value);\n                    }\n                }\n            } else {\n                this.add();\n            }\n        }\n\n        this.next();\n\n        return this.buf.toString();\n    }\n\n    protected void add(char cc) {\n        this.buf.append(cc);\n        this.next();\n    }\n\n    protected void add() {\n        this.add(this.c);\n    }\n\n    protected void addDigits() {\n        while (Character.isDigit(this.c)) {\n            this.add();\n        }\n    }\n\n    protected char unicode() {\n        int value = 0;\n\n        for (int i = 0; i < 4; ++i) {\n            switch (this.next()) {\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n                value = (value << 4) + (this.c - '0');\n\n                break;\n\n            case 'a':\n            case 'b':\n            case 'c':\n            case 'd':\n            case 'e':\n            case 'f':\n                value = (value << 4) + (this.c - 'W');\n\n                break;\n\n            case 'A':\n            case 'B':\n            case 'C':\n            case 'D':\n            case 'E':\n            case 'F':\n                value = (value << 4) + (this.c - '7');\n\n                break;\n            }\n        }\n\n        return (char) value;\n    }\n}\n"}
{"test_method": "@Test\n    public void testCollectionObject() throws Exception {\n        // given\n        RequiredFieldValidator rfv = container.inject(RequiredFieldValidator.class);\n        rfv.setValueStack(ActionContext.getContext().getValueStack());\n        rfv.setFieldName(\"shorts\");\n        rfv.setDefaultMessage(\"${fieldName} field is required!\");\n        ValidationAction action = new ValidationAction();\n        action.setShorts(new ArrayList<Short>());\n        DummyValidatorContext context = new DummyValidatorContext(action, container.getInstance(TextProviderFactory.class));\n        rfv.setValidatorContext(context);\n\n        // when\n        rfv.validate(action);\n\n        // then\n        assertTrue(context.hasFieldErrors());\n        assertEquals(1, context.getFieldErrors().size());\n        assertNotNull(context.getFieldErrors().get(\"shorts\"));\n        assertEquals(\"shorts field is required!\", context.getFieldErrors().get(\"shorts\").get(0));\n    }", "focal_method": "public void validate(Object object) throws ValidationException {\n        String fieldName = getFieldName();\n        Object value = this.getFieldValue(fieldName, object);\n\n        if (value == null) {\n            addFieldError(fieldName, object);\n        } else if (value.getClass().isArray() && Array.getLength(value) == 0) {\n            addFieldError(fieldName, object);\n        } else if (Collection.class.isAssignableFrom(value.getClass()) && ((Collection) value).size() == 0) {\n            addFieldError(fieldName, object);\n        }\n    }", "test_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2.validator.validators;\n\nimport com.opensymphony.xwork2.ActionContext;\nimport com.opensymphony.xwork2.TextProviderFactory;\nimport com.opensymphony.xwork2.validator.DummyValidatorContext;\nimport org.apache.struts2.StrutsInternalTestCase;\nimport org.junit.Test;\n\nimport java.util.ArrayList;\n\npublic class RequiredFieldValidatorTest extends StrutsInternalTestCase {\n\n    @Test\n    public void testNullObject() throws Exception {\n        // given\n        RequiredFieldValidator rfv = container.inject(RequiredFieldValidator.class);\n        rfv.setValueStack(ActionContext.getContext().getValueStack());\n        rfv.setFieldName(\"stringValue\");\n        rfv.setDefaultMessage(\"${fieldName} field is required!\");\n        ValidationAction action = new ValidationAction();\n        DummyValidatorContext context = new DummyValidatorContext(action, container.getInstance(TextProviderFactory.class));\n        rfv.setValidatorContext(context);\n\n        // when\n        rfv.validate(action);\n\n        // then\n        assertTrue(context.hasFieldErrors());\n        assertEquals(1, context.getFieldErrors().size());\n        assertNotNull(context.getFieldErrors().get(\"stringValue\"));\n        assertEquals(\"stringValue field is required!\", context.getFieldErrors().get(\"stringValue\").get(0));\n    }\n\n    @Test\n    public void testArrayObject() throws Exception {\n        // given\n        RequiredFieldValidator rfv = container.inject(RequiredFieldValidator.class);\n        rfv.setValueStack(ActionContext.getContext().getValueStack());\n        rfv.setFieldName(\"ints\");\n        rfv.setDefaultMessage(\"${fieldName} field is required!\");\n        ValidationAction action = new ValidationAction();\n        action.setInts(new Integer[]{});\n        DummyValidatorContext context = new DummyValidatorContext(action, container.getInstance(TextProviderFactory.class));\n        rfv.setValidatorContext(context);\n\n        // when\n        rfv.validate(action);\n\n        // then\n        assertTrue(context.hasFieldErrors());\n        assertEquals(1, context.getFieldErrors().size());\n        assertNotNull(context.getFieldErrors().get(\"ints\"));\n        assertEquals(\"ints field is required!\", context.getFieldErrors().get(\"ints\").get(0));\n    }\n    \n    @Test\n    public void testCollectionObject() throws Exception {\n        // given\n        RequiredFieldValidator rfv = container.inject(RequiredFieldValidator.class);\n        rfv.setValueStack(ActionContext.getContext().getValueStack());\n        rfv.setFieldName(\"shorts\");\n        rfv.setDefaultMessage(\"${fieldName} field is required!\");\n        ValidationAction action = new ValidationAction();\n        action.setShorts(new ArrayList<Short>());\n        DummyValidatorContext context = new DummyValidatorContext(action, container.getInstance(TextProviderFactory.class));\n        rfv.setValidatorContext(context);\n\n        // when\n        rfv.validate(action);\n\n        // then\n        assertTrue(context.hasFieldErrors());\n        assertEquals(1, context.getFieldErrors().size());\n        assertNotNull(context.getFieldErrors().get(\"shorts\"));\n        assertEquals(\"shorts field is required!\", context.getFieldErrors().get(\"shorts\").get(0));\n    }\n\n}", "focal_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2.validator.validators;\n\nimport com.opensymphony.xwork2.validator.ValidationException;\n\nimport java.lang.reflect.Array;\nimport java.util.Collection;\n\n/**\n * <!-- START SNIPPET: javadoc -->\n * RequiredFieldValidator checks if the specified field is not null.\n * <!-- END SNIPPET: javadoc -->\n *\n * <!-- START SNIPPET: parameters -->\n * <ul>\n * \t\t<li>fieldName - field name if plain-validator syntax is used, not needed if field-validator syntax is used</li>\n * </ul>\n * <!-- END SNIPPET: parameters -->\n *\n * <pre>\n * <!-- START SNIPPET: example -->\n * \t   &lt;validators&gt;\n * \n *         &lt;!-- Plain Validator Syntax --&gt;\n *         &lt;validator type=\"required\"&gt;\n *             &lt;param name=\"fieldName\"&gt;username&lt;/param&gt;\n *             &lt;message&gt;username must not be null&lt;/message&gt;\n *         &lt;/validator&gt;\n * \n * \n *         &lt;!-- Field Validator Syntax --&gt;\n *         &lt;field name=\"username\"&gt;\n *             &lt;field-validator type=\"required\"&gt;\n *             \t   &lt;message&gt;username must not be null&lt;/message&gt;\n *             &lt;/field-validator&gt;\n *         &lt;/field&gt;\n * \n *     &lt;/validators&gt;\n * <!-- END SNIPPET: example -->\n * </pre>\n * \n * \n *\n * @author rainerh\n */\npublic class RequiredFieldValidator extends FieldValidatorSupport {\n\n    public void validate(Object object) throws ValidationException {\n        String fieldName = getFieldName();\n        Object value = this.getFieldValue(fieldName, object);\n\n        if (value == null) {\n            addFieldError(fieldName, object);\n        } else if (value.getClass().isArray() && Array.getLength(value) == 0) {\n            addFieldError(fieldName, object);\n        } else if (Collection.class.isAssignableFrom(value.getClass()) && ((Collection) value).size() == 0) {\n            addFieldError(fieldName, object);\n        }\n    }\n}\n"}
{"test_method": "@Test\n\tpublic void testSanitizeInputPathShouldReturnNullForNonLeadingWebInf() throws Exception {\n\t\tassertNull(fileDownloadAction.sanitizeInputPath(\"./WEB-INF/foo\"));\n\t}", "focal_method": "String sanitizeInputPath( String value ) {\n\t\tif (value != null && value.toUpperCase().contains(\"WEB-INF\")) {\n\t\t\treturn null;\n\t\t}\n\t\treturn value;\n\t}", "test_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.showcase.filedownload;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static junit.framework.Assert.assertEquals;\nimport static junit.framework.Assert.assertNull;\n\npublic class FileDownloadActionTest {\n\n\tprivate FileDownloadAction fileDownloadAction;\n\n\t@Before\n\tpublic void setUp() {\n\t    this.fileDownloadAction = new FileDownloadAction();\n\t}\n\n\t@Test\n\tpublic void testSanitizeInputPathShouldAllowSimpleParameter() throws Exception {\n\t\tassertEquals(\"foo\", fileDownloadAction.sanitizeInputPath(\"foo\"));\n\t}\n\n\t@Test\n\tpublic void testSanitizeInputPathShouldReturnNullForNullInput() throws Exception {\n\t\tassertNull(fileDownloadAction.sanitizeInputPath(null));\n\t}\n\n\t@Test\n\tpublic void testSanitizeInputPathShouldReturnNullForLeadingWebInf() throws Exception {\n\t\tassertNull(fileDownloadAction.sanitizeInputPath(\"WEB-INF/foo\"));\n\t}\n\n\t@Test\n\tpublic void testSanitizeInputPathShouldReturnNullForNonLeadingWebInf() throws Exception {\n\t\tassertNull(fileDownloadAction.sanitizeInputPath(\"./WEB-INF/foo\"));\n\t}\n\n\t@Test\n\tpublic void testSanitizeInputPathShouldReturnNullForNonUppercaseWebInf() throws Exception {\n\t\tassertNull(fileDownloadAction.sanitizeInputPath(\"./wEB-Inf/foo\"));\n\t}\n}\n", "focal_file": "/*\n * $Id$\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.showcase.filedownload;\n\nimport com.opensymphony.xwork2.Action;\nimport org.apache.struts2.ServletActionContext;\n\nimport java.io.InputStream;\n\n/**\n * Demonstrates file resource download.\n * Set filePath to the local file resource to download,\n * relative to the application root (\"/images/struts.gif\").\n */\npublic class FileDownloadAction implements Action {\n\n\tprivate String inputPath;\n\n\tpublic String execute() throws Exception {\n\t\treturn SUCCESS;\n\t}\n\n\tpublic void setInputPath(String value) {\n\t\tinputPath = sanitizeInputPath(value);\n\t}\n\n\t/**\n\t * As the user modifiable parameter inputPath will be used to access server side resources, we want the path to be\n\t * sanitized - in this case it is demonstrated to disallow inputPath parameter values containing \"WEB-INF\". Consider to\n\t * use even stricter rules in production environments.\n\t *\n\t * @param value the raw parameter input value to sanitize\n\t *\n\t * @return the sanitized value; <tt>null</tt> if value contains an invalid path segment like WEB-INF\n\t */\n\tString sanitizeInputPath( String value ) {\n\t\tif (value != null && value.toUpperCase().contains(\"WEB-INF\")) {\n\t\t\treturn null;\n\t\t}\n\t\treturn value;\n\t}\n\n\tpublic InputStream getInputStream() throws Exception {\n\t\treturn ServletActionContext.getServletContext().getResourceAsStream(inputPath);\n\t}\n}\n"}
{"test_method": "@Test\n    public void testBeanConfToString() {\n        ConstantConfig constantConfig = new ConstantConfig();\n\n        String actual = constantConfig.beanConfToString(null);\n        Assert.assertNull(actual);\n\n        actual = constantConfig.beanConfToString(new BeanConfig(TestBean.class));\n        Assert.assertEquals(Container.DEFAULT_NAME, actual);\n\n        String expectedName = \"expectedTestBeanName\";\n        actual = constantConfig.beanConfToString(new BeanConfig(TestBean.class, expectedName));\n        Assert.assertEquals(expectedName, actual);\n    }", "focal_method": "protected String beanConfToString(BeanConfig beanConf) {\n        return beanConf == null ? null : beanConf.getName();\n    }", "test_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.config.entities;\n\nimport com.opensymphony.xwork2.TestBean;\nimport com.opensymphony.xwork2.inject.Container;\nimport org.apache.struts2.StrutsConstants;\nimport org.apache.struts2.dispatcher.StaticContentLoader;\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport java.util.Arrays;\nimport java.util.LinkedHashSet;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class ConstantConfigTest {\n\n    @Test\n    public void testBeanConfToString() {\n        ConstantConfig constantConfig = new ConstantConfig();\n\n        String actual = constantConfig.beanConfToString(null);\n        Assert.assertNull(actual);\n\n        actual = constantConfig.beanConfToString(new BeanConfig(TestBean.class));\n        Assert.assertEquals(Container.DEFAULT_NAME, actual);\n\n        String expectedName = \"expectedTestBeanName\";\n        actual = constantConfig.beanConfToString(new BeanConfig(TestBean.class, expectedName));\n        Assert.assertEquals(expectedName, actual);\n    }\n\n    @Test\n    public void testGetAllAsStringsMap() {\n        ConstantConfig constantConfig = new ConstantConfig();\n\n        boolean expectedDevMode = true;\n        constantConfig.setDevMode(expectedDevMode);\n\n        String expectedActionExtensions = \".action,.some,.another\";\n        constantConfig.setActionExtension(Arrays.asList(expectedActionExtensions.split(\",\")));\n\n        String expectedLanguage = \"fr\";\n        constantConfig.setLocale(new Locale(expectedLanguage));\n\n        Map<String, String> map = constantConfig.getAllAsStringsMap();\n\n        Assert.assertEquals(String.valueOf(expectedDevMode), map.get(StrutsConstants.STRUTS_DEVMODE));\n        Assert.assertEquals(expectedActionExtensions, map.get(StrutsConstants.STRUTS_ACTION_EXTENSION));\n        Assert.assertNull(map.get(StrutsConstants.STRUTS_I18N_RELOAD));\n        Assert.assertEquals(expectedLanguage, map.get(StrutsConstants.STRUTS_LOCALE));\n    }\n\n    @Test\n    public void testEmptyClassesToString() {\n        ConstantConfig constantConfig = new ConstantConfig();\n\n        constantConfig.setExcludedClasses(null);\n        constantConfig.setExcludedPackageNamePatterns(null);\n        constantConfig.setExcludedPackageNames(null);\n        constantConfig.setExcludedPackageExemptClasses(null);\n        constantConfig.setDevModeExcludedClasses(null);\n        constantConfig.setDevModeExcludedPackageNamePatterns(null);\n        constantConfig.setDevModeExcludedPackageNames(null);\n        constantConfig.setDevModeExcludedPackageExemptClasses(null);\n\n        Map<String, String> map = constantConfig.getAllAsStringsMap();\n        Assert.assertNull(map.get(StrutsConstants.STRUTS_EXCLUDED_CLASSES));\n        Assert.assertNull(map.get(StrutsConstants.STRUTS_EXCLUDED_PACKAGE_NAME_PATTERNS));\n        Assert.assertNull(map.get(StrutsConstants.STRUTS_EXCLUDED_PACKAGE_NAMES));\n        Assert.assertNull(map.get(StrutsConstants.STRUTS_DEV_MODE_EXCLUDED_CLASSES));\n        Assert.assertNull(map.get(StrutsConstants.STRUTS_DEV_MODE_EXCLUDED_PACKAGE_NAME_PATTERNS));\n        Assert.assertNull(map.get(StrutsConstants.STRUTS_DEV_MODE_EXCLUDED_PACKAGE_NAMES));\n    }\n\n    @Test\n    public void testClassesToString() {\n        ConstantConfig constantConfig = new ConstantConfig();\n\n        Set<Class<?>> excludedClasses = new LinkedHashSet<>();\n        excludedClasses.add(Object.class);\n        excludedClasses.add(Runtime.class);\n        excludedClasses.add(System.class);\n\n        constantConfig.setExcludedClasses(excludedClasses);\n        constantConfig.setDevModeExcludedClasses(excludedClasses);\n\n        Map<String, String> map = constantConfig.getAllAsStringsMap();\n        Assert.assertEquals(\"java.lang.Object,java.lang.Runtime,java.lang.System\",\n            map.get(StrutsConstants.STRUTS_EXCLUDED_CLASSES));\n        Assert.assertEquals(\"java.lang.Object,java.lang.Runtime,java.lang.System\",\n            map.get(StrutsConstants.STRUTS_DEV_MODE_EXCLUDED_CLASSES));\n    }\n\n    @Test\n    public void testExemptClassesToString() {\n        ConstantConfig constantConfig = new ConstantConfig();\n\n        Set<Class<?>> exemptClasses = new LinkedHashSet<>();\n        exemptClasses.add(Object.class);\n        exemptClasses.add(Runtime.class);\n        exemptClasses.add(System.class);\n\n        constantConfig.setExcludedPackageExemptClasses(exemptClasses);\n        constantConfig.setDevModeExcludedPackageExemptClasses(exemptClasses);\n\n        Map<String, String> map = constantConfig.getAllAsStringsMap();\n        Assert.assertEquals(\"java.lang.Object,java.lang.Runtime,java.lang.System\",\n                map.get(StrutsConstants.STRUTS_EXCLUDED_PACKAGE_EXEMPT_CLASSES));\n        Assert.assertEquals(\"java.lang.Object,java.lang.Runtime,java.lang.System\",\n                map.get(StrutsConstants.STRUTS_DEV_MODE_EXCLUDED_PACKAGE_EXEMPT_CLASSES));\n    }\n\n    @Test\n    public void testSettingStaticContentPath() {\n        // given\n        ConstantConfig config = new ConstantConfig();\n\n        // when\n        config.setStaticContentPath(null);\n        // then\n        Assert.assertEquals(StaticContentLoader.DEFAULT_STATIC_CONTENT_PATH, config.getStaticContentPath());\n\n        // when\n        config.setStaticContentPath(\" \");\n        // then\n        Assert.assertEquals(StaticContentLoader.DEFAULT_STATIC_CONTENT_PATH, config.getStaticContentPath());\n\n        // when\n        config.setStaticContentPath(\"content\");\n        // then\n        Assert.assertEquals(\"/content\", config.getStaticContentPath());\n\n        // when\n        config.setStaticContentPath(\"/content\");\n        // then\n        Assert.assertEquals(\"/content\", config.getStaticContentPath());\n    }\n\n}\n", "focal_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.config.entities;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.struts2.StrutsConstants;\nimport org.apache.struts2.dispatcher.StaticContentLoader;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\npublic class ConstantConfig {\n    private Boolean devMode;\n    private Boolean i18nReload;\n    private String i18nEncoding;\n    private Boolean configurationXmlReload;\n    private List<String> actionExtension;\n    private List<Pattern> actionExcludePattern;\n    private Integer urlHttpPort;\n    private Integer urlHttpsPort;\n    private String urlIncludeParams;\n    private BeanConfig urlRenderer;\n    private BeanConfig objectFactory;\n    private BeanConfig objectFactoryActionFactory;\n    private BeanConfig objectFactoryResultFactory;\n    private BeanConfig objectFactoryConverterFactory;\n    private BeanConfig objectFactoryInterceptorFactory;\n    private BeanConfig objectFactoryValidatorFactory;\n    private BeanConfig objectFactoryUnknownHandlerFactory;\n    private BeanConfig objectTypeDeterminer;\n    private Locale locale;\n    private Boolean dispatcherParametersWorkaround;\n    private BeanConfig freemarkerManagerClassname;\n    private String freemarkerTemplatesCacheUpdateDelay;\n    private Boolean freemarkerBeanwrapperCache;\n    private Integer freemarkerMruMaxStrongSize;\n    private BeanConfig velocityManagerClassname;\n    private String velocityConfigfile;\n    private String velocityToolboxlocation;\n    private List<String> velocityContexts;\n    private String uiTemplateDir;\n    private String uiTheme;\n    private String uiThemeExpansionToken;\n    private Long multipartMaxSize;\n    private Long multipartMaxFiles;\n    private Long multipartMaxFileSize;\n    private Long multipartMaxStringLength;\n    private String multipartSaveDir;\n    private Integer multipartBufferSize;\n    private BeanConfig multipartParser;\n    private Boolean multipartEnabled;\n    private Pattern multipartValidationRegex;\n    private String objectFactorySpringAutoWire;\n    private Boolean objectFactorySpringAutoWireAlwaysRespect;\n    private Boolean objectFactorySpringUseClassCache;\n    private Boolean objectFactorySpringEnableAopSupport;\n    private Boolean xsltNocache;\n    private List<String> customProperties;\n    private List<String> customI18nResources;\n    private BeanConfig mapperClass;\n    private List<String> mapperPrefixMapping;\n    private Boolean serveStatic;\n    private Boolean serveStaticBrowserCache;\n    private Boolean enableDynamicMethodInvocation;\n    private Boolean enableSlashesInActionNames;\n    private List<String> mapperComposite;\n    private BeanConfig actionProxyFactory;\n    private Boolean freemarkerWrapperAltMap;\n    private BeanConfig xworkConverter;\n    private Boolean mapperAlwaysSelectFullNamespace;\n    private BeanConfig localeProviderFactory;\n    private String mapperIdParameterName;\n    private Boolean ognlAllowStaticFieldAccess;\n    private BeanConfig actionValidatorManager;\n    private BeanConfig valueStackFactory;\n    private BeanConfig reflectionProvider;\n    private BeanConfig reflectionContextFactory;\n    private BeanConfig patternMatcher;\n    private BeanConfig staticContentLoader;\n    private BeanConfig unknownHandlerManager;\n    private Boolean elThrowExceptionOnFailure;\n    private Boolean ognlLogMissingProperties;\n    private Boolean ognlEnableExpressionCache;\n    private Boolean ognlEnableEvalExpression;\n    private Boolean disableRequestAttributeValueStackLookup;\n    private BeanConfig viewUrlHelper;\n    private BeanConfig converterCollection;\n    private BeanConfig converterArray;\n    private BeanConfig converterDate;\n    private BeanConfig converterNumber;\n    private BeanConfig converterString;\n    private Boolean handleException;\n    private BeanConfig converterPropertiesProcessor;\n    private BeanConfig converterFileProcessor;\n    private BeanConfig converterAnnotationProcessor;\n    private BeanConfig converterCreator;\n    private BeanConfig ConverterHolder;\n    private BeanConfig expressionParser;\n    private Pattern allowedActionNames;\n    private String defaultActionName;\n    private Pattern allowedMethodNames;\n    private String defaultMethodName;\n    private Boolean mapperActionPrefixEnabled;\n    private Boolean mapperActionPrefixCrossNamespaces;\n    private String uiTemplateSuffix;\n    private BeanConfig dispatcherErrorHandler;\n    private Set<Class<?>> excludedClasses;\n    private List<Pattern> excludedPackageNamePatterns;\n    private Set<String> excludedPackageNames;\n    private Set<Class<?>> excludedPackageExemptClasses;\n    private Set<Class<?>> devModeExcludedClasses;\n    private List<Pattern> devModeExcludedPackageNamePatterns;\n    private Set<String> devModeExcludedPackageNames;\n    private Set<Class<?>> devModeExcludedPackageExemptClasses;\n    private BeanConfig excludedPatternsChecker;\n    private BeanConfig acceptedPatternsChecker;\n    private BeanConfig notExcludedAcceptedPatternsChecker;\n    private Set<Pattern> overrideExcludedPatterns;\n    private Set<Pattern> overrideAcceptedPatterns;\n    private Set<Pattern> additionalExcludedPatterns;\n    private Set<Pattern> additionalAcceptedPatterns;\n    private BeanConfig contentTypeMatcher;\n    private String strictMethodInvocationMethodRegex;\n    private BeanConfig textProviderFactory;\n    private BeanConfig localizedTextProvider;\n    private Boolean disallowProxyMemberAccess;\n    private Integer ognlAutoGrowthCollectionLimit;\n    private String staticContentPath;\n    private BeanConfig expressionCacheFactory;\n    private BeanConfig beaninfoCacheFactory;\n\n    protected String beanConfToString(BeanConfig beanConf) {\n        return beanConf == null ? null : beanConf.getName();\n    }\n\n    private String classesToString(Set<Class<?>> classes) {\n        List<String> list = null;\n        if (classes != null && !classes.isEmpty()) {\n            list = new ArrayList<>();\n            for (Class<?> c : classes) {\n                list.add(c.getName());\n            }\n        }\n        return StringUtils.join(list, ',');\n    }\n\n    public Map<String, String> getAllAsStringsMap() {\n        Map<String, String> map = new HashMap<>();\n\n        map.put(StrutsConstants.STRUTS_DEVMODE, Objects.toString(devMode, null));\n        map.put(StrutsConstants.STRUTS_I18N_RELOAD, Objects.toString(i18nReload, null));\n        map.put(StrutsConstants.STRUTS_I18N_ENCODING, i18nEncoding);\n        map.put(StrutsConstants.STRUTS_CONFIGURATION_XML_RELOAD, Objects.toString(configurationXmlReload, null));\n        map.put(StrutsConstants.STRUTS_ACTION_EXTENSION, StringUtils.join(actionExtension, ','));\n        map.put(StrutsConstants.STRUTS_ACTION_EXCLUDE_PATTERN, StringUtils.join(actionExcludePattern, ','));\n        map.put(StrutsConstants.STRUTS_URL_HTTP_PORT, Objects.toString(urlHttpPort, null));\n        map.put(StrutsConstants.STRUTS_URL_HTTPS_PORT, Objects.toString(urlHttpsPort, null));\n        map.put(StrutsConstants.STRUTS_URL_INCLUDEPARAMS, urlIncludeParams);\n        map.put(StrutsConstants.STRUTS_URL_RENDERER, beanConfToString(urlRenderer));\n        map.put(StrutsConstants.STRUTS_OBJECTFACTORY, beanConfToString(objectFactory));\n        map.put(StrutsConstants.STRUTS_OBJECTFACTORY_ACTIONFACTORY, beanConfToString(objectFactoryActionFactory));\n        map.put(StrutsConstants.STRUTS_OBJECTFACTORY_RESULTFACTORY, beanConfToString(objectFactoryResultFactory));\n        map.put(StrutsConstants.STRUTS_OBJECTFACTORY_CONVERTERFACTORY, beanConfToString(objectFactoryConverterFactory));\n        map.put(StrutsConstants.STRUTS_OBJECTFACTORY_INTERCEPTORFACTORY, beanConfToString(objectFactoryInterceptorFactory));\n        map.put(StrutsConstants.STRUTS_OBJECTFACTORY_VALIDATORFACTORY, beanConfToString(objectFactoryValidatorFactory));\n        map.put(StrutsConstants.STRUTS_OBJECTFACTORY_UNKNOWNHANDLERFACTORY, beanConfToString(objectFactoryUnknownHandlerFactory));\n        map.put(StrutsConstants.STRUTS_OBJECTTYPEDETERMINER, beanConfToString(objectTypeDeterminer));\n        map.put(StrutsConstants.STRUTS_LOCALE, locale == null ? null : locale.getLanguage());\n        map.put(StrutsConstants.STRUTS_DISPATCHER_PARAMETERSWORKAROUND, Objects.toString(dispatcherParametersWorkaround, null));\n        map.put(StrutsConstants.STRUTS_FREEMARKER_MANAGER_CLASSNAME, beanConfToString(freemarkerManagerClassname));\n        map.put(StrutsConstants.STRUTS_FREEMARKER_TEMPLATES_CACHE_UPDATE_DELAY, freemarkerTemplatesCacheUpdateDelay);\n        map.put(StrutsConstants.STRUTS_FREEMARKER_BEANWRAPPER_CACHE, Objects.toString(freemarkerBeanwrapperCache, null));\n        map.put(StrutsConstants.STRUTS_FREEMARKER_MRU_MAX_STRONG_SIZE, Objects.toString(freemarkerMruMaxStrongSize, null));\n        map.put(StrutsConstants.STRUTS_VELOCITY_CONFIGFILE, velocityConfigfile);\n        map.put(StrutsConstants.STRUTS_VELOCITY_TOOLBOXLOCATION, velocityToolboxlocation);\n        map.put(StrutsConstants.STRUTS_VELOCITY_CONTEXTS, StringUtils.join(velocityContexts, ','));\n        map.put(StrutsConstants.STRUTS_UI_TEMPLATEDIR, uiTemplateDir);\n        map.put(StrutsConstants.STRUTS_UI_THEME, uiTheme);\n        map.put(StrutsConstants.STRUTS_UI_THEME_EXPANSION_TOKEN, uiThemeExpansionToken);\n        map.put(StrutsConstants.STRUTS_MULTIPART_MAXSIZE, Objects.toString(multipartMaxSize, null));\n        map.put(StrutsConstants.STRUTS_MULTIPART_MAXFILES, Objects.toString(multipartMaxFiles, null));\n        map.put(StrutsConstants.STRUTS_MULTIPART_MAXFILESIZE, Objects.toString(multipartMaxFileSize, null));\n        map.put(StrutsConstants.STRUTS_MULTIPART_MAX_STRING_LENGTH, Objects.toString(multipartMaxStringLength, null));\n        map.put(StrutsConstants.STRUTS_MULTIPART_SAVEDIR, multipartSaveDir);\n        map.put(StrutsConstants.STRUTS_MULTIPART_BUFFERSIZE, Objects.toString(multipartBufferSize, null));\n        map.put(StrutsConstants.STRUTS_MULTIPART_PARSER, beanConfToString(multipartParser));\n        map.put(StrutsConstants.STRUTS_MULTIPART_ENABLED, Objects.toString(multipartEnabled, null));\n        map.put(StrutsConstants.STRUTS_MULTIPART_VALIDATION_REGEX, Objects.toString(multipartValidationRegex, null));\n        map.put(StrutsConstants.STRUTS_OBJECTFACTORY_SPRING_AUTOWIRE, objectFactorySpringAutoWire);\n        map.put(StrutsConstants.STRUTS_OBJECTFACTORY_SPRING_AUTOWIRE_ALWAYS_RESPECT, Objects.toString(objectFactorySpringAutoWireAlwaysRespect, null));\n        map.put(StrutsConstants.STRUTS_OBJECTFACTORY_SPRING_USE_CLASS_CACHE, Objects.toString(objectFactorySpringUseClassCache, null));\n        map.put(StrutsConstants.STRUTS_OBJECTFACTORY_SPRING_ENABLE_AOP_SUPPORT, Objects.toString(objectFactorySpringEnableAopSupport, null));\n        map.put(StrutsConstants.STRUTS_CUSTOM_PROPERTIES, StringUtils.join(customProperties, ','));\n        map.put(StrutsConstants.STRUTS_CUSTOM_I18N_RESOURCES, StringUtils.join(customI18nResources, ','));\n        map.put(StrutsConstants.STRUTS_MAPPER_CLASS, beanConfToString(mapperClass));\n        map.put(StrutsConstants.PREFIX_BASED_MAPPER_CONFIGURATION, StringUtils.join(mapperPrefixMapping, ','));\n        map.put(StrutsConstants.STRUTS_SERVE_STATIC_CONTENT, Objects.toString(serveStatic, null));\n        map.put(StrutsConstants.STRUTS_SERVE_STATIC_BROWSER_CACHE, Objects.toString(serveStaticBrowserCache, null));\n        map.put(StrutsConstants.STRUTS_ENABLE_DYNAMIC_METHOD_INVOCATION, Objects.toString(enableDynamicMethodInvocation, null));\n        map.put(StrutsConstants.STRUTS_ENABLE_SLASHES_IN_ACTION_NAMES, Objects.toString(enableSlashesInActionNames, null));\n        map.put(StrutsConstants.STRUTS_MAPPER_COMPOSITE, StringUtils.join(mapperComposite, ','));\n        map.put(StrutsConstants.STRUTS_ACTIONPROXYFACTORY, beanConfToString(actionProxyFactory));\n        map.put(StrutsConstants.STRUTS_FREEMARKER_WRAPPER_ALT_MAP, Objects.toString(freemarkerWrapperAltMap, null));\n        map.put(StrutsConstants.STRUTS_XWORKCONVERTER, beanConfToString(xworkConverter));\n        map.put(StrutsConstants.STRUTS_ALWAYS_SELECT_FULL_NAMESPACE, Objects.toString(mapperAlwaysSelectFullNamespace, null));\n        map.put(StrutsConstants.STRUTS_LOCALE_PROVIDER_FACTORY, beanConfToString(localeProviderFactory));\n        map.put(StrutsConstants.STRUTS_ID_PARAMETER_NAME, mapperIdParameterName);\n        map.put(StrutsConstants.STRUTS_ALLOW_STATIC_FIELD_ACCESS, Objects.toString(ognlAllowStaticFieldAccess, null));\n        map.put(StrutsConstants.STRUTS_ACTIONVALIDATORMANAGER, beanConfToString(actionValidatorManager));\n        map.put(StrutsConstants.STRUTS_VALUESTACKFACTORY, beanConfToString(valueStackFactory));\n        map.put(StrutsConstants.STRUTS_REFLECTIONPROVIDER, beanConfToString(reflectionProvider));\n        map.put(StrutsConstants.STRUTS_REFLECTIONCONTEXTFACTORY, beanConfToString(reflectionContextFactory));\n        map.put(StrutsConstants.STRUTS_PATTERNMATCHER, beanConfToString(patternMatcher));\n        map.put(StrutsConstants.STRUTS_STATIC_CONTENT_LOADER, beanConfToString(staticContentLoader));\n        map.put(StrutsConstants.STRUTS_UNKNOWN_HANDLER_MANAGER, beanConfToString(unknownHandlerManager));\n        map.put(StrutsConstants.STRUTS_EL_THROW_EXCEPTION, Objects.toString(elThrowExceptionOnFailure, null));\n        map.put(StrutsConstants.STRUTS_OGNL_LOG_MISSING_PROPERTIES, Objects.toString(ognlLogMissingProperties, null));\n        map.put(StrutsConstants.STRUTS_OGNL_ENABLE_EXPRESSION_CACHE, Objects.toString(ognlEnableExpressionCache, null));\n        map.put(StrutsConstants.STRUTS_OGNL_ENABLE_EVAL_EXPRESSION, Objects.toString(ognlEnableEvalExpression, null));\n        map.put(StrutsConstants.STRUTS_DISABLE_REQUEST_ATTRIBUTE_VALUE_STACK_LOOKUP, Objects.toString(disableRequestAttributeValueStackLookup, null));\n        map.put(StrutsConstants.STRUTS_URL_HELPER, beanConfToString(viewUrlHelper));\n        map.put(StrutsConstants.STRUTS_CONVERTER_COLLECTION, beanConfToString(converterCollection));\n        map.put(StrutsConstants.STRUTS_CONVERTER_ARRAY, beanConfToString(converterArray));\n        map.put(StrutsConstants.STRUTS_CONVERTER_DATE, beanConfToString(converterDate));\n        map.put(StrutsConstants.STRUTS_CONVERTER_NUMBER, beanConfToString(converterNumber));\n        map.put(StrutsConstants.STRUTS_CONVERTER_STRING, beanConfToString(converterString));\n        map.put(StrutsConstants.STRUTS_HANDLE_EXCEPTION, Objects.toString(handleException, null));\n        map.put(StrutsConstants.STRUTS_CONVERTER_PROPERTIES_PROCESSOR, beanConfToString(converterPropertiesProcessor));\n        map.put(StrutsConstants.STRUTS_CONVERTER_FILE_PROCESSOR, beanConfToString(converterFileProcessor));\n        map.put(StrutsConstants.STRUTS_CONVERTER_ANNOTATION_PROCESSOR, beanConfToString(converterAnnotationProcessor));\n        map.put(StrutsConstants.STRUTS_CONVERTER_CREATOR, beanConfToString(converterCreator));\n        map.put(StrutsConstants.STRUTS_CONVERTER_HOLDER, beanConfToString(ConverterHolder));\n        map.put(StrutsConstants.STRUTS_EXPRESSION_PARSER, beanConfToString(expressionParser));\n        map.put(StrutsConstants.STRUTS_ALLOWED_ACTION_NAMES, Objects.toString(allowedActionNames, null));\n        map.put(StrutsConstants.STRUTS_DEFAULT_ACTION_NAME, defaultActionName);\n        map.put(StrutsConstants.STRUTS_ALLOWED_METHOD_NAMES, Objects.toString(allowedMethodNames, null));\n        map.put(StrutsConstants.STRUTS_DEFAULT_METHOD_NAME, defaultMethodName);\n        map.put(StrutsConstants.STRUTS_MAPPER_ACTION_PREFIX_ENABLED, Objects.toString(mapperActionPrefixEnabled, null));\n        map.put(StrutsConstants.DEFAULT_TEMPLATE_TYPE_CONFIG_KEY, uiTemplateSuffix);\n        map.put(StrutsConstants.STRUTS_DISPATCHER_ERROR_HANDLER, beanConfToString(dispatcherErrorHandler));\n        map.put(StrutsConstants.STRUTS_EXCLUDED_CLASSES, classesToString(excludedClasses));\n        map.put(StrutsConstants.STRUTS_EXCLUDED_PACKAGE_NAME_PATTERNS, StringUtils.join(excludedPackageNamePatterns, ','));\n        map.put(StrutsConstants.STRUTS_EXCLUDED_PACKAGE_NAMES, StringUtils.join(excludedPackageNames, ','));\n        map.put(StrutsConstants.STRUTS_EXCLUDED_PACKAGE_EXEMPT_CLASSES, classesToString(excludedPackageExemptClasses));\n        map.put(StrutsConstants.STRUTS_DEV_MODE_EXCLUDED_CLASSES, classesToString(devModeExcludedClasses));\n        map.put(StrutsConstants.STRUTS_DEV_MODE_EXCLUDED_PACKAGE_NAME_PATTERNS, StringUtils.join(devModeExcludedPackageNamePatterns, ','));\n        map.put(StrutsConstants.STRUTS_DEV_MODE_EXCLUDED_PACKAGE_NAMES, StringUtils.join(devModeExcludedPackageNames, ','));\n        map.put(StrutsConstants.STRUTS_DEV_MODE_EXCLUDED_PACKAGE_EXEMPT_CLASSES, classesToString(devModeExcludedPackageExemptClasses));\n        map.put(StrutsConstants.STRUTS_EXCLUDED_PATTERNS_CHECKER, beanConfToString(excludedPatternsChecker));\n        map.put(StrutsConstants.STRUTS_ACCEPTED_PATTERNS_CHECKER, beanConfToString(acceptedPatternsChecker));\n        map.put(StrutsConstants.STRUTS_NOT_EXCLUDED_ACCEPTED_PATTERNS_CHECKER, beanConfToString(notExcludedAcceptedPatternsChecker));\n        map.put(StrutsConstants.STRUTS_OVERRIDE_EXCLUDED_PATTERNS, StringUtils.join(overrideExcludedPatterns, ','));\n        map.put(StrutsConstants.STRUTS_OVERRIDE_ACCEPTED_PATTERNS, StringUtils.join(overrideAcceptedPatterns, ','));\n        map.put(StrutsConstants.STRUTS_ADDITIONAL_EXCLUDED_PATTERNS, StringUtils.join(additionalExcludedPatterns, ','));\n        map.put(StrutsConstants.STRUTS_ADDITIONAL_ACCEPTED_PATTERNS, StringUtils.join(additionalAcceptedPatterns, ','));\n        map.put(StrutsConstants.STRUTS_CONTENT_TYPE_MATCHER, beanConfToString(contentTypeMatcher));\n        map.put(StrutsConstants.STRUTS_SMI_METHOD_REGEX, strictMethodInvocationMethodRegex);\n        map.put(StrutsConstants.STRUTS_TEXT_PROVIDER_FACTORY, beanConfToString(textProviderFactory));\n        map.put(StrutsConstants.STRUTS_LOCALIZED_TEXT_PROVIDER, beanConfToString(localizedTextProvider));\n        map.put(StrutsConstants.STRUTS_DISALLOW_PROXY_MEMBER_ACCESS, Objects.toString(disallowProxyMemberAccess, null));\n        map.put(StrutsConstants.STRUTS_OGNL_AUTO_GROWTH_COLLECTION_LIMIT, Objects.toString(ognlAutoGrowthCollectionLimit, null));\n        map.put(StrutsConstants.STRUTS_UI_STATIC_CONTENT_PATH, Objects.toString(staticContentPath, StaticContentLoader.DEFAULT_STATIC_CONTENT_PATH));\n        map.put(StrutsConstants.STRUTS_OGNL_EXPRESSION_CACHE_FACTORY, beanConfToString(expressionCacheFactory));\n        map.put(StrutsConstants.STRUTS_OGNL_BEANINFO_CACHE_FACTORY, beanConfToString(beaninfoCacheFactory));\n\n        return map;\n    }\n\n    public Boolean getDevMode() {\n        return devMode;\n    }\n\n    public void setDevMode(Boolean devMode) {\n        this.devMode = devMode;\n    }\n\n    public Boolean getI18nReload() {\n        return i18nReload;\n    }\n\n    public void setI18nReload(Boolean i18nReload) {\n        this.i18nReload = i18nReload;\n    }\n\n    public String getI18nEncoding() {\n        return i18nEncoding;\n    }\n\n    public void setI18nEncoding(String i18nEncoding) {\n        this.i18nEncoding = i18nEncoding;\n    }\n\n    public Boolean getConfigurationXmlReload() {\n        return configurationXmlReload;\n    }\n\n    public void setConfigurationXmlReload(Boolean configurationXmlReload) {\n        this.configurationXmlReload = configurationXmlReload;\n    }\n\n    public List<String> getActionExtension() {\n        return actionExtension;\n    }\n\n    public void setActionExtension(List<String> actionExtension) {\n        this.actionExtension = actionExtension;\n    }\n\n    public List<Pattern> getActionExcludePattern() {\n        return actionExcludePattern;\n    }\n\n    public void setActionExcludePattern(List<Pattern> actionExcludePattern) {\n        this.actionExcludePattern = actionExcludePattern;\n    }\n\n    public Integer getUrlHttpPort() {\n        return urlHttpPort;\n    }\n\n    public void setUrlHttpPort(Integer urlHttpPort) {\n        this.urlHttpPort = urlHttpPort;\n    }\n\n    public Integer getUrlHttpsPort() {\n        return urlHttpsPort;\n    }\n\n    public void setUrlHttpsPort(Integer urlHttpsPort) {\n        this.urlHttpsPort = urlHttpsPort;\n    }\n\n    public String getUrlIncludeParams() {\n        return urlIncludeParams;\n    }\n\n    public void setUrlIncludeParams(String urlIncludeParams) {\n        this.urlIncludeParams = urlIncludeParams;\n    }\n\n    public BeanConfig getUrlRenderer() {\n        return urlRenderer;\n    }\n\n    public void setUrlRenderer(BeanConfig urlRenderer) {\n        this.urlRenderer = urlRenderer;\n    }\n\n    public void setUrlRenderer(Class<?> clazz) {\n        this.urlRenderer = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getObjectFactory() {\n        return objectFactory;\n    }\n\n    public void setObjectFactory(BeanConfig objectFactory) {\n        this.objectFactory = objectFactory;\n    }\n\n    public void setObjectFactory(Class<?> clazz) {\n        this.objectFactory = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getObjectFactoryActionFactory() {\n        return objectFactoryActionFactory;\n    }\n\n    public void setObjectFactoryActionFactory(BeanConfig objectFactoryActionFactory) {\n        this.objectFactoryActionFactory = objectFactoryActionFactory;\n    }\n\n    public void setObjectFactoryActionFactory(Class<?> clazz) {\n        this.objectFactoryActionFactory = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getObjectFactoryResultFactory() {\n        return objectFactoryResultFactory;\n    }\n\n    public void setObjectFactoryResultFactory(BeanConfig objectFactoryResultFactory) {\n        this.objectFactoryResultFactory = objectFactoryResultFactory;\n    }\n\n    public void setObjectFactoryResultFactory(Class<?> clazz) {\n        this.objectFactoryResultFactory = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getObjectFactoryConverterFactory() {\n        return objectFactoryConverterFactory;\n    }\n\n    public void setObjectFactoryConverterFactory(BeanConfig objectFactoryConverterFactory) {\n        this.objectFactoryConverterFactory = objectFactoryConverterFactory;\n    }\n\n    public void setObjectFactoryConverterFactory(Class<?> clazz) {\n        this.objectFactoryConverterFactory = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getObjectFactoryInterceptorFactory() {\n        return objectFactoryInterceptorFactory;\n    }\n\n    public void setObjectFactoryInterceptorFactory(BeanConfig objectFactoryInterceptorFactory) {\n        this.objectFactoryInterceptorFactory = objectFactoryInterceptorFactory;\n    }\n\n    public void setObjectFactoryInterceptorFactory(Class<?> clazz) {\n        this.objectFactoryInterceptorFactory = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getObjectFactoryValidatorFactory() {\n        return objectFactoryValidatorFactory;\n    }\n\n    public void setObjectFactoryValidatorFactory(BeanConfig objectFactoryValidatorFactory) {\n        this.objectFactoryValidatorFactory = objectFactoryValidatorFactory;\n    }\n\n    public void setObjectFactoryValidatorFactory(Class<?> clazz) {\n        this.objectFactoryValidatorFactory = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getObjectFactoryUnknownHandlerFactory() {\n        return objectFactoryUnknownHandlerFactory;\n    }\n\n    public void setObjectFactoryUnknownHandlerFactory(BeanConfig objectFactoryUnknownHandlerFactory) {\n        this.objectFactoryUnknownHandlerFactory = objectFactoryUnknownHandlerFactory;\n    }\n\n    public void setObjectFactoryUnknownHandlerFactory(Class<?> clazz) {\n        this.objectFactoryUnknownHandlerFactory = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getObjectTypeDeterminer() {\n        return objectTypeDeterminer;\n    }\n\n    public void setObjectTypeDeterminer(BeanConfig objectTypeDeterminer) {\n        this.objectTypeDeterminer = objectTypeDeterminer;\n    }\n\n    public void setObjectTypeDeterminer(Class<?> clazz) {\n        this.objectTypeDeterminer = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public Locale getLocale() {\n        return locale;\n    }\n\n    public void setLocale(Locale locale) {\n        this.locale = locale;\n    }\n\n    public Boolean getDispatcherParametersWorkaround() {\n        return dispatcherParametersWorkaround;\n    }\n\n    public void setDispatcherParametersWorkaround(Boolean dispatcherParametersWorkaround) {\n        this.dispatcherParametersWorkaround = dispatcherParametersWorkaround;\n    }\n\n    public BeanConfig getFreemarkerManagerClassname() {\n        return freemarkerManagerClassname;\n    }\n\n    public void setFreemarkerManagerClassname(BeanConfig freemarkerManagerClassname) {\n        this.freemarkerManagerClassname = freemarkerManagerClassname;\n    }\n\n    public void setFreemarkerManagerClassname(Class<?> clazz) {\n        this.freemarkerManagerClassname = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public String getFreemarkerTemplatesCacheUpdateDelay() {\n        return freemarkerTemplatesCacheUpdateDelay;\n    }\n\n    public void setFreemarkerTemplatesCacheUpdateDelay(String freemarkerTemplatesCacheUpdateDelay) {\n        this.freemarkerTemplatesCacheUpdateDelay = freemarkerTemplatesCacheUpdateDelay;\n    }\n\n    public Boolean getFreemarkerBeanwrapperCache() {\n        return freemarkerBeanwrapperCache;\n    }\n\n    public void setFreemarkerBeanwrapperCache(Boolean freemarkerBeanwrapperCache) {\n        this.freemarkerBeanwrapperCache = freemarkerBeanwrapperCache;\n    }\n\n    public Integer getFreemarkerMruMaxStrongSize() {\n        return freemarkerMruMaxStrongSize;\n    }\n\n    public void setFreemarkerMruMaxStrongSize(Integer freemarkerMruMaxStrongSize) {\n        this.freemarkerMruMaxStrongSize = freemarkerMruMaxStrongSize;\n    }\n\n    public BeanConfig getVelocityManagerClassname() {\n        return velocityManagerClassname;\n    }\n\n    public void setVelocityManagerClassname(BeanConfig velocityManagerClassname) {\n        this.velocityManagerClassname = velocityManagerClassname;\n    }\n\n    public void setVelocityManagerClassname(Class<?> clazz) {\n        this.velocityManagerClassname = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public String getVelocityConfigfile() {\n        return velocityConfigfile;\n    }\n\n    public void setVelocityConfigfile(String velocityConfigfile) {\n        this.velocityConfigfile = velocityConfigfile;\n    }\n\n    public String getVelocityToolboxlocation() {\n        return velocityToolboxlocation;\n    }\n\n    public void setVelocityToolboxlocation(String velocityToolboxlocation) {\n        this.velocityToolboxlocation = velocityToolboxlocation;\n    }\n\n    public List<String> getVelocityContexts() {\n        return velocityContexts;\n    }\n\n    public void setVelocityContexts(List<String> velocityContexts) {\n        this.velocityContexts = velocityContexts;\n    }\n\n    public String getUiTemplateDir() {\n        return uiTemplateDir;\n    }\n\n    public void setUiTemplateDir(String uiTemplateDir) {\n        this.uiTemplateDir = uiTemplateDir;\n    }\n\n    public String getUiTheme() {\n        return uiTheme;\n    }\n\n    public void setUiTheme(String uiTheme) {\n        this.uiTheme = uiTheme;\n    }\n\n    public String getUiThemeExpansionToken() {\n        return uiThemeExpansionToken;\n    }\n\n    public void setUiThemeExpansionToken(String uiThemeExpansionToken) {\n        this.uiThemeExpansionToken = uiThemeExpansionToken;\n    }\n\n    public Long getMultipartMaxSize() {\n        return multipartMaxSize;\n    }\n\n    public void setMultipartMaxSize(Long multipartMaxSize) {\n        this.multipartMaxSize = multipartMaxSize;\n    }\n\n    public Long getMultipartMaxFiles() {\n        return multipartMaxFiles;\n    }\n\n    public void setMultipartMaxFiles(Long multipartMaxFiles) {\n        this.multipartMaxFiles = multipartMaxFiles;\n    }\n\n    public Long getMultipartMaxFileSize() {\n        return multipartMaxFileSize;\n    }\n\n    public void setMultipartMaxFileSize(Long multipartMaxFileSize) {\n        this.multipartMaxFileSize = multipartMaxFileSize;\n    }\n\n    public Long getMultipartMaxStringLength() {\n        return multipartMaxStringLength;\n    }\n\n    public void setMultipartMaxStringLength(Long multipartMaxStringLength) {\n        this.multipartMaxStringLength = multipartMaxStringLength;\n    }\n\n    public String getMultipartSaveDir() {\n        return multipartSaveDir;\n    }\n\n    public void setMultipartSaveDir(String multipartSaveDir) {\n        this.multipartSaveDir = multipartSaveDir;\n    }\n\n    public Integer getMultipartBufferSize() {\n        return multipartBufferSize;\n    }\n\n    public void setMultipartBufferSize(Integer multipartBufferSize) {\n        this.multipartBufferSize = multipartBufferSize;\n    }\n\n    public BeanConfig getMultipartParser() {\n        return multipartParser;\n    }\n\n    public void setMultipartParser(BeanConfig multipartParser) {\n        this.multipartParser = multipartParser;\n    }\n\n    public void setMultipartParser(Class<?> clazz) {\n        this.multipartParser = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public Boolean getMultipartEnabled() {\n        return multipartEnabled;\n    }\n\n    public void setMultipartEnabled(Boolean multipartEnabled) {\n        this.multipartEnabled = multipartEnabled;\n    }\n\n    public Pattern getMultipartValidationRegex() {\n        return multipartValidationRegex;\n    }\n\n    public void setMultipartValidationRegex(Pattern multipartValidationRegex) {\n        this.multipartValidationRegex = multipartValidationRegex;\n    }\n\n    public String getObjectFactorySpringAutoWire() {\n        return objectFactorySpringAutoWire;\n    }\n\n    public void setObjectFactorySpringAutoWire(String objectFactorySpringAutoWire) {\n        this.objectFactorySpringAutoWire = objectFactorySpringAutoWire;\n    }\n\n    public Boolean getObjectFactorySpringAutoWireAlwaysRespect() {\n        return objectFactorySpringAutoWireAlwaysRespect;\n    }\n\n    public void setObjectFactorySpringAutoWireAlwaysRespect(Boolean objectFactorySpringAutoWireAlwaysRespect) {\n        this.objectFactorySpringAutoWireAlwaysRespect = objectFactorySpringAutoWireAlwaysRespect;\n    }\n\n    public Boolean getObjectFactorySpringUseClassCache() {\n        return objectFactorySpringUseClassCache;\n    }\n\n    public void setObjectFactorySpringUseClassCache(Boolean objectFactorySpringUseClassCache) {\n        this.objectFactorySpringUseClassCache = objectFactorySpringUseClassCache;\n    }\n\n    public Boolean getObjectFactorySpringEnableAopSupport() {\n        return objectFactorySpringEnableAopSupport;\n    }\n\n    public void setObjectFactorySpringEnableAopSupport(Boolean objectFactorySpringEnableAopSupport) {\n        this.objectFactorySpringEnableAopSupport = objectFactorySpringEnableAopSupport;\n    }\n\n    public Boolean getXsltNocache() {\n        return xsltNocache;\n    }\n\n    public void setXsltNocache(Boolean xsltNocache) {\n        this.xsltNocache = xsltNocache;\n    }\n\n    public List<String> getCustomProperties() {\n        return customProperties;\n    }\n\n    public void setCustomProperties(List<String> customProperties) {\n        this.customProperties = customProperties;\n    }\n\n    public List<String> getCustomI18nResources() {\n        return customI18nResources;\n    }\n\n    public void setCustomI18nResources(List<String> customI18nResources) {\n        this.customI18nResources = customI18nResources;\n    }\n\n    public BeanConfig getMapperClass() {\n        return mapperClass;\n    }\n\n    public void setMapperClass(BeanConfig mapperClass) {\n        this.mapperClass = mapperClass;\n    }\n\n    public void setMapperClass(Class<?> clazz) {\n        this.mapperClass = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public List<String> getMapperPrefixMapping() {\n        return mapperPrefixMapping;\n    }\n\n    public void setMapperPrefixMapping(List<String> mapperPrefixMapping) {\n        this.mapperPrefixMapping = mapperPrefixMapping;\n    }\n\n    public Boolean getServeStatic() {\n        return serveStatic;\n    }\n\n    public void setServeStatic(Boolean serveStatic) {\n        this.serveStatic = serveStatic;\n    }\n\n    public Boolean getServeStaticBrowserCache() {\n        return serveStaticBrowserCache;\n    }\n\n    public void setServeStaticBrowserCache(Boolean serveStaticBrowserCache) {\n        this.serveStaticBrowserCache = serveStaticBrowserCache;\n    }\n\n    public Boolean getEnableDynamicMethodInvocation() {\n        return enableDynamicMethodInvocation;\n    }\n\n    public void setEnableDynamicMethodInvocation(Boolean enableDynamicMethodInvocation) {\n        this.enableDynamicMethodInvocation = enableDynamicMethodInvocation;\n    }\n\n    public Boolean getEnableSlashesInActionNames() {\n        return enableSlashesInActionNames;\n    }\n\n    public void setEnableSlashesInActionNames(Boolean enableSlashesInActionNames) {\n        this.enableSlashesInActionNames = enableSlashesInActionNames;\n    }\n\n    public List<String> getMapperComposite() {\n        return mapperComposite;\n    }\n\n    public void setMapperComposite(List<String> mapperComposite) {\n        this.mapperComposite = mapperComposite;\n    }\n\n    public BeanConfig getActionProxyFactory() {\n        return actionProxyFactory;\n    }\n\n    public void setActionProxyFactory(BeanConfig actionProxyFactory) {\n        this.actionProxyFactory = actionProxyFactory;\n    }\n\n    public void setActionProxyFactory(Class<?> clazz) {\n        this.actionProxyFactory = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public Boolean getFreemarkerWrapperAltMap() {\n        return freemarkerWrapperAltMap;\n    }\n\n    public void setFreemarkerWrapperAltMap(Boolean freemarkerWrapperAltMap) {\n        this.freemarkerWrapperAltMap = freemarkerWrapperAltMap;\n    }\n\n    public BeanConfig getXworkConverter() {\n        return xworkConverter;\n    }\n\n    public void setXworkConverter(BeanConfig xworkConverter) {\n        this.xworkConverter = xworkConverter;\n    }\n\n    public void setXworkConverter(Class<?> clazz) {\n        this.xworkConverter = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public Boolean getMapperAlwaysSelectFullNamespace() {\n        return mapperAlwaysSelectFullNamespace;\n    }\n\n    public void setMapperAlwaysSelectFullNamespace(Boolean mapperAlwaysSelectFullNamespace) {\n        this.mapperAlwaysSelectFullNamespace = mapperAlwaysSelectFullNamespace;\n    }\n\n    public BeanConfig getLocaleProviderFactory() {\n        return localeProviderFactory;\n    }\n\n    public void setLocaleProviderFactory(BeanConfig localeProviderFactory) {\n        this.localeProviderFactory = localeProviderFactory;\n    }\n\n    public void setLocaleProviderFactory(Class<?> clazz) {\n        this.localeProviderFactory = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public String getMapperIdParameterName() {\n        return mapperIdParameterName;\n    }\n\n    public void setMapperIdParameterName(String mapperIdParameterName) {\n        this.mapperIdParameterName = mapperIdParameterName;\n    }\n\n    public Boolean getOgnlAllowStaticFieldAccess() {\n        return ognlAllowStaticFieldAccess;\n    }\n\n    public void setOgnlAllowStaticFieldAccess(Boolean ognlAllowStaticFieldAccess) {\n        this.ognlAllowStaticFieldAccess = ognlAllowStaticFieldAccess;\n    }\n\n    public BeanConfig getActionValidatorManager() {\n        return actionValidatorManager;\n    }\n\n    public void setActionValidatorManager(BeanConfig actionValidatorManager) {\n        this.actionValidatorManager = actionValidatorManager;\n    }\n\n    public void setActionValidatorManager(Class<?> clazz) {\n        this.actionValidatorManager = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getValueStackFactory() {\n        return valueStackFactory;\n    }\n\n    public void setValueStackFactory(BeanConfig valueStackFactory) {\n        this.valueStackFactory = valueStackFactory;\n    }\n\n    public void setValueStackFactory(Class<?> clazz) {\n        this.valueStackFactory = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getReflectionProvider() {\n        return reflectionProvider;\n    }\n\n    public void setReflectionProvider(BeanConfig reflectionProvider) {\n        this.reflectionProvider = reflectionProvider;\n    }\n\n    public void setReflectionProvider(Class<?> clazz) {\n        this.reflectionProvider = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getReflectionContextFactory() {\n        return reflectionContextFactory;\n    }\n\n    public void setReflectionContextFactory(BeanConfig reflectionContextFactory) {\n        this.reflectionContextFactory = reflectionContextFactory;\n    }\n\n    public void setReflectionContextFactory(Class<?> clazz) {\n        this.reflectionContextFactory = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getPatternMatcher() {\n        return patternMatcher;\n    }\n\n    public void setPatternMatcher(BeanConfig patternMatcher) {\n        this.patternMatcher = patternMatcher;\n    }\n\n    public void setPatternMatcher(Class<?> clazz) {\n        this.patternMatcher = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getStaticContentLoader() {\n        return staticContentLoader;\n    }\n\n    public void setStaticContentLoader(BeanConfig staticContentLoader) {\n        this.staticContentLoader = staticContentLoader;\n    }\n\n    public void setStaticContentLoader(Class<?> clazz) {\n        this.staticContentLoader = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getUnknownHandlerManager() {\n        return unknownHandlerManager;\n    }\n\n    public void setUnknownHandlerManager(BeanConfig unknownHandlerManager) {\n        this.unknownHandlerManager = unknownHandlerManager;\n    }\n\n    public void setUnknownHandlerManager(Class<?> clazz) {\n        this.unknownHandlerManager = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public Boolean getElThrowExceptionOnFailure() {\n        return elThrowExceptionOnFailure;\n    }\n\n    public void setElThrowExceptionOnFailure(Boolean elThrowExceptionOnFailure) {\n        this.elThrowExceptionOnFailure = elThrowExceptionOnFailure;\n    }\n\n    public Boolean getOgnlLogMissingProperties() {\n        return ognlLogMissingProperties;\n    }\n\n    public void setOgnlLogMissingProperties(Boolean ognlLogMissingProperties) {\n        this.ognlLogMissingProperties = ognlLogMissingProperties;\n    }\n\n    public Boolean getOgnlEnableExpressionCache() {\n        return ognlEnableExpressionCache;\n    }\n\n    public void setOgnlEnableExpressionCache(Boolean ognlEnableExpressionCache) {\n        this.ognlEnableExpressionCache = ognlEnableExpressionCache;\n    }\n\n    public Boolean getOgnlEnableEvalExpression() {\n        return ognlEnableEvalExpression;\n    }\n\n    public void setOgnlEnableEvalExpression(Boolean ognlEnableEvalExpression) {\n        this.ognlEnableEvalExpression = ognlEnableEvalExpression;\n    }\n\n    public Boolean getDisableRequestAttributeValueStackLookup() {\n        return disableRequestAttributeValueStackLookup;\n    }\n\n    public void setDisableRequestAttributeValueStackLookup(Boolean disableRequestAttributeValueStackLookup) {\n        this.disableRequestAttributeValueStackLookup = disableRequestAttributeValueStackLookup;\n    }\n\n    public BeanConfig getViewUrlHelper() {\n        return viewUrlHelper;\n    }\n\n    public void setViewUrlHelper(BeanConfig viewUrlHelper) {\n        this.viewUrlHelper = viewUrlHelper;\n    }\n\n    public void setViewUrlHelper(Class<?> clazz) {\n        this.viewUrlHelper = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getConverterCollection() {\n        return converterCollection;\n    }\n\n    public void setConverterCollection(BeanConfig converterCollection) {\n        this.converterCollection = converterCollection;\n    }\n\n    public void setConverterCollection(Class<?> clazz) {\n        this.converterCollection = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getConverterArray() {\n        return converterArray;\n    }\n\n    public void setConverterArray(BeanConfig converterArray) {\n        this.converterArray = converterArray;\n    }\n\n    public void setConverterArray(Class<?> clazz) {\n        this.converterArray = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getConverterDate() {\n        return converterDate;\n    }\n\n    public void setConverterDate(BeanConfig converterDate) {\n        this.converterDate = converterDate;\n    }\n\n    public void setConverterDate(Class<?> clazz) {\n        this.converterDate = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getConverterNumber() {\n        return converterNumber;\n    }\n\n    public void setConverterNumber(BeanConfig converterNumber) {\n        this.converterNumber = converterNumber;\n    }\n\n    public void setConverterNumber(Class<?> clazz) {\n        this.converterNumber = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getConverterString() {\n        return converterString;\n    }\n\n    public void setConverterString(BeanConfig converterString) {\n        this.converterString = converterString;\n    }\n\n    public void setConverterString(Class<?> clazz) {\n        this.converterString = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public Boolean getHandleException() {\n        return handleException;\n    }\n\n    public void setHandleException(Boolean handleException) {\n        this.handleException = handleException;\n    }\n\n    public BeanConfig getConverterPropertiesProcessor() {\n        return converterPropertiesProcessor;\n    }\n\n    public void setConverterPropertiesProcessor(BeanConfig converterPropertiesProcessor) {\n        this.converterPropertiesProcessor = converterPropertiesProcessor;\n    }\n\n    public void setConverterPropertiesProcessor(Class<?> clazz) {\n        this.converterPropertiesProcessor = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getConverterFileProcessor() {\n        return converterFileProcessor;\n    }\n\n    public void setConverterFileProcessor(BeanConfig converterFileProcessor) {\n        this.converterFileProcessor = converterFileProcessor;\n    }\n\n    public void setConverterFileProcessor(Class<?> clazz) {\n        this.converterFileProcessor = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getConverterAnnotationProcessor() {\n        return converterAnnotationProcessor;\n    }\n\n    public void setConverterAnnotationProcessor(BeanConfig converterAnnotationProcessor) {\n        this.converterAnnotationProcessor = converterAnnotationProcessor;\n    }\n\n    public void setConverterAnnotationProcessor(Class<?> clazz) {\n        this.converterAnnotationProcessor = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getConverterCreator() {\n        return converterCreator;\n    }\n\n    public void setConverterCreator(BeanConfig converterCreator) {\n        this.converterCreator = converterCreator;\n    }\n\n    public void setConverterCreator(Class<?> clazz) {\n        this.converterCreator = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getConverterHolder() {\n        return ConverterHolder;\n    }\n\n    public void setConverterHolder(BeanConfig ConverterHolder) {\n        this.ConverterHolder = ConverterHolder;\n    }\n\n    public void setConverterHolder(Class<?> clazz) {\n        this.ConverterHolder = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getExpressionParser() {\n        return expressionParser;\n    }\n\n    public void setExpressionParser(BeanConfig expressionParser) {\n        this.expressionParser = expressionParser;\n    }\n\n    public void setExpressionParser(Class<?> clazz) {\n        this.expressionParser = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public Pattern getAllowedActionNames() {\n        return allowedActionNames;\n    }\n\n    public void setAllowedActionNames(Pattern allowedActionNames) {\n        this.allowedActionNames = allowedActionNames;\n    }\n\n    public String getDefaultActionName() {\n        return defaultActionName;\n    }\n\n    public void setDefaultActionName(String defaultActionName) {\n        this.defaultActionName = defaultActionName;\n    }\n\n    public Pattern getAllowedMethodNames() {\n        return allowedMethodNames;\n    }\n\n    public void setAllowedMethodNames(Pattern allowedMethodNames) {\n        this.allowedMethodNames = allowedMethodNames;\n    }\n\n    public String getDefaultMethodName() {\n        return defaultMethodName;\n    }\n\n    public void setDefaultMethodName(String defaultMethodName) {\n        this.defaultMethodName = defaultMethodName;\n    }\n\n    public Boolean getMapperActionPrefixEnabled() {\n        return mapperActionPrefixEnabled;\n    }\n\n    public void setMapperActionPrefixEnabled(Boolean mapperActionPrefixEnabled) {\n        this.mapperActionPrefixEnabled = mapperActionPrefixEnabled;\n    }\n\n    public Boolean getMapperActionPrefixCrossNamespaces() {\n        return mapperActionPrefixCrossNamespaces;\n    }\n\n    public void setMapperActionPrefixCrossNamespaces(Boolean mapperActionPrefixCrossNamespaces) {\n        this.mapperActionPrefixCrossNamespaces = mapperActionPrefixCrossNamespaces;\n    }\n\n    public String getUiTemplateSuffix() {\n        return uiTemplateSuffix;\n    }\n\n    public void setUiTemplateSuffix(String uiTemplateSuffix) {\n        this.uiTemplateSuffix = uiTemplateSuffix;\n    }\n\n    public BeanConfig getDispatcherErrorHandler() {\n        return dispatcherErrorHandler;\n    }\n\n    public void setDispatcherErrorHandler(BeanConfig dispatcherErrorHandler) {\n        this.dispatcherErrorHandler = dispatcherErrorHandler;\n    }\n\n    public void setDispatcherErrorHandler(Class<?> clazz) {\n        this.dispatcherErrorHandler = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public Set<Class<?>> getExcludedClasses() {\n        return excludedClasses;\n    }\n\n    public void setExcludedClasses(Set<Class<?>> excludedClasses) {\n        this.excludedClasses = excludedClasses;\n    }\n\n    public List<Pattern> getExcludedPackageNamePatterns() {\n        return excludedPackageNamePatterns;\n    }\n\n    public void setExcludedPackageNamePatterns(List<Pattern> excludedPackageNamePatterns) {\n        this.excludedPackageNamePatterns = excludedPackageNamePatterns;\n    }\n\n    public Set<String> getExcludedPackageNames() {\n        return excludedPackageNames;\n    }\n\n    public void setExcludedPackageNames(Set<String> excludedPackageNames) {\n        this.excludedPackageNames = excludedPackageNames;\n    }\n\n    public Set<Class<?>> getExcludedPackageExemptClasses() {\n        return excludedPackageExemptClasses;\n    }\n\n    public void setExcludedPackageExemptClasses(Set<Class<?>> excludedPackageExemptClasses) {\n        this.excludedPackageExemptClasses = excludedPackageExemptClasses;\n    }\n\n    public Set<Class<?>> getDevModeExcludedClasses() {\n        return devModeExcludedClasses;\n    }\n\n    public void setDevModeExcludedClasses(Set<Class<?>> devModeExcludedClasses) {\n        this.devModeExcludedClasses = devModeExcludedClasses;\n    }\n\n    public List<Pattern> getDevModeExcludedPackageNamePatterns() {\n        return devModeExcludedPackageNamePatterns;\n    }\n\n    public void setDevModeExcludedPackageNamePatterns(List<Pattern> devModeExcludedPackageNamePatterns) {\n        this.devModeExcludedPackageNamePatterns = devModeExcludedPackageNamePatterns;\n    }\n\n    public Set<String> getDevModeExcludedPackageNames() {\n        return devModeExcludedPackageNames;\n    }\n\n    public void setDevModeExcludedPackageNames(Set<String> devModeExcludedPackageNames) {\n        this.devModeExcludedPackageNames = devModeExcludedPackageNames;\n    }\n\n    public Set<Class<?>> getDevModeExcludedPackageExemptClasses() {\n        return devModeExcludedPackageExemptClasses;\n    }\n\n    public void setDevModeExcludedPackageExemptClasses(Set<Class<?>> devModeExcludedPackageExemptClasses) {\n        this.devModeExcludedPackageExemptClasses = devModeExcludedPackageExemptClasses;\n    }\n\n    public BeanConfig getExcludedPatternsChecker() {\n        return excludedPatternsChecker;\n    }\n\n    public void setExcludedPatternsChecker(BeanConfig excludedPatternsChecker) {\n        this.excludedPatternsChecker = excludedPatternsChecker;\n    }\n\n    public void setExcludedPatternsChecker(Class<?> clazz) {\n        this.excludedPatternsChecker = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getAcceptedPatternsChecker() {\n        return acceptedPatternsChecker;\n    }\n\n    public void setAcceptedPatternsChecker(BeanConfig acceptedPatternsChecker) {\n        this.acceptedPatternsChecker = acceptedPatternsChecker;\n    }\n\n    public void setAcceptedPatternsChecker(Class<?> clazz) {\n        this.acceptedPatternsChecker = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getNotExcludedAcceptedPatternsChecker() {\n        return notExcludedAcceptedPatternsChecker;\n    }\n\n    public void setNotExcludedAcceptedPatternsChecker(BeanConfig notExcludedAcceptedPatternsChecker) {\n        this.notExcludedAcceptedPatternsChecker = notExcludedAcceptedPatternsChecker;\n    }\n\n    public void setNotExcludedAcceptedPatternsChecker(Class<?> clazz) {\n        this.notExcludedAcceptedPatternsChecker = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public Set<Pattern> getOverrideExcludedPatterns() {\n        return overrideExcludedPatterns;\n    }\n\n    public void setOverrideExcludedPatterns(Set<Pattern> overrideExcludedPatterns) {\n        this.overrideExcludedPatterns = overrideExcludedPatterns;\n    }\n\n    public Set<Pattern> getOverrideAcceptedPatterns() {\n        return overrideAcceptedPatterns;\n    }\n\n    public void setOverrideAcceptedPatterns(Set<Pattern> overrideAcceptedPatterns) {\n        this.overrideAcceptedPatterns = overrideAcceptedPatterns;\n    }\n\n    public Set<Pattern> getAdditionalExcludedPatterns() {\n        return additionalExcludedPatterns;\n    }\n\n    public void setAdditionalExcludedPatterns(Set<Pattern> additionalExcludedPatterns) {\n        this.additionalExcludedPatterns = additionalExcludedPatterns;\n    }\n\n    public Set<Pattern> getAdditionalAcceptedPatterns() {\n        return additionalAcceptedPatterns;\n    }\n\n    public void setAdditionalAcceptedPatterns(Set<Pattern> additionalAcceptedPatterns) {\n        this.additionalAcceptedPatterns = additionalAcceptedPatterns;\n    }\n\n    public BeanConfig getContentTypeMatcher() {\n        return contentTypeMatcher;\n    }\n\n    public void setContentTypeMatcher(BeanConfig contentTypeMatcher) {\n        this.contentTypeMatcher = contentTypeMatcher;\n    }\n\n    public void setContentTypeMatcher(Class<?> clazz) {\n        this.contentTypeMatcher = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public String getStrictMethodInvocationMethodRegex() {\n        return strictMethodInvocationMethodRegex;\n    }\n\n    public void setStrictMethodInvocationMethodRegex(String strictMethodInvocationMethodRegex) {\n        this.strictMethodInvocationMethodRegex = strictMethodInvocationMethodRegex;\n    }\n\n    public BeanConfig getTextProviderFactory() {\n        return textProviderFactory;\n    }\n\n    public void setTextProviderFactory(BeanConfig textProviderFactory) {\n        this.textProviderFactory = textProviderFactory;\n    }\n\n    public void setTextProviderFactory(Class<?> clazz) {\n        this.textProviderFactory = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getLocalizedTextProvider() {\n        return localizedTextProvider;\n    }\n\n    public void setLocalizedTextProvider(BeanConfig localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    public void setLocalizedTextProvider(Class<?> clazz) {\n        this.localizedTextProvider = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public Boolean getDisallowProxyMemberAccess() {\n        return disallowProxyMemberAccess;\n    }\n\n    public void setDisallowProxyMemberAccess(Boolean disallowProxyMemberAccess) {\n        this.disallowProxyMemberAccess = disallowProxyMemberAccess;\n    }\n\n    public Integer getOgnlAutoGrowthCollectionLimit() {\n        return ognlAutoGrowthCollectionLimit;\n    }\n\n    public void setOgnlAutoGrowthCollectionLimit(Integer ognlAutoGrowthCollectionLimit) {\n        this.ognlAutoGrowthCollectionLimit = ognlAutoGrowthCollectionLimit;\n    }\n\n    public String getStaticContentPath() {\n        return staticContentPath;\n    }\n\n    public void setStaticContentPath(String staticContentPath) {\n        this.staticContentPath = StaticContentLoader.Validator.validateStaticContentPath(staticContentPath);\n    }\n\n    public BeanConfig getExpressionCacheFactory() {\n        return expressionCacheFactory;\n    }\n\n    public void setExpressionCacheFactory(BeanConfig expressionCacheFactory) {\n        this.expressionCacheFactory = expressionCacheFactory;\n    }\n\n    public void setExpressionCacheFactory(Class<?> clazz) {\n        this.expressionCacheFactory = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getBeaninfoCacheFactory() {\n        return beaninfoCacheFactory;\n    }\n\n    public void setBeaninfoCacheFactory(BeanConfig beaninfoCacheFactory) {\n        this.beaninfoCacheFactory = beaninfoCacheFactory;\n    }\n\n    public void setBeaninfoCacheFactory(Class<?> clazz) {\n        this.beaninfoCacheFactory = new BeanConfig(clazz, clazz.getName());\n    }\n}\n"}
{"test_method": "@Test\n    public void testGetBean() throws Exception {\n        final CdiObjectFactory cdiObjectFactory = new CdiObjectFactory();\n        FooConsumer fooConsumer = (FooConsumer) cdiObjectFactory.buildBean(FooConsumer.class.getCanonicalName(), null, false);\n        assertNotNull(fooConsumer);\n        assertNotNull(fooConsumer.fooService);\n    }", "focal_method": "@Override\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n    public Object buildBean(String className, Map<String, Object> extraContext, boolean injectInternal)\n            throws Exception {\n\n        Class<?> clazz = getClassInstance(className);\n        InjectionTarget injectionTarget = getInjectionTarget(clazz);\n\n        // a separate CreationalContext is required for every bean\n        final CreationalContext ctx = buildNonContextualCreationalContext(beanManager);\n\n        Object o = injectionTarget.produce(ctx);\n        injectionTarget.inject(o, ctx);\n        injectionTarget.postConstruct(o);\n\n        if (injectInternal) {\n            injectInternalBeans(o);\n        }\n\n        return o;\n    }", "test_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.cdi;\n\nimport org.jboss.weld.bootstrap.api.helpers.RegistrySingletonProvider;\nimport org.jboss.weld.environment.se.Weld;\nimport org.jboss.weld.environment.se.WeldContainer;\nimport org.junit.BeforeClass;\nimport org.junit.Test;\nimport org.springframework.mock.jndi.SimpleNamingContextBuilder;\n\nimport javax.enterprise.inject.spi.InjectionTarget;\n\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertSame;\nimport static org.junit.Assert.assertTrue;\n\npublic class CdiObjectFactoryTest {\n\n    @BeforeClass\n    public static void setup() throws Exception {\n        Weld weld = new Weld().containerId(RegistrySingletonProvider.STATIC_INSTANCE);\n        WeldContainer container = weld.initialize();\n\n        SimpleNamingContextBuilder builder = new SimpleNamingContextBuilder();\n        builder.activate();\n        builder.bind(CdiObjectFactory.CDI_JNDIKEY_BEANMANAGER_COMP, container.getBeanManager());\n    }\n\n    @Test\n    public void testFindBeanManager() {\n        assertNotNull(new CdiObjectFactory().findBeanManager());\n    }\n\n    @Test\n    public void testGetBean() throws Exception {\n        final CdiObjectFactory cdiObjectFactory = new CdiObjectFactory();\n        FooConsumer fooConsumer = (FooConsumer) cdiObjectFactory.buildBean(FooConsumer.class.getCanonicalName(), null, false);\n        assertNotNull(fooConsumer);\n        assertNotNull(fooConsumer.fooService);\n    }\n\n    @Test\n    public void testGetInjectionTarget() {\n        final CdiObjectFactory cdiObjectFactory = new CdiObjectFactory();\n        final InjectionTarget<?> injectionTarget = cdiObjectFactory.getInjectionTarget(FooConsumer.class);\n        assertNotNull(injectionTarget);\n        assertTrue(cdiObjectFactory.injectionTargetCache.containsKey(FooConsumer.class));\n        assertSame(cdiObjectFactory.getInjectionTarget(FooConsumer.class), injectionTarget);\n    }\n}\n", "focal_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.cdi;\n\nimport com.opensymphony.xwork2.ObjectFactory;\nimport com.opensymphony.xwork2.inject.Inject;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport javax.enterprise.context.spi.CreationalContext;\nimport javax.enterprise.inject.spi.BeanManager;\nimport javax.enterprise.inject.spi.InjectionTarget;\nimport javax.enterprise.inject.spi.InjectionTargetFactory;\nimport javax.naming.Context;\nimport javax.naming.InitialContext;\nimport javax.naming.NamingException;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * CdiObjectFactory allows Struts 2 managed objects, like Actions, Interceptors or Results, to be injected by a Contexts\n * and Dependency Injection container (JSR299 / WebBeans).\n * The BeanManager instance will be searched in the container's JNDI context, according to following algorithm:\n * <ul>\n *     <li>if a value for configuration constant <code>struts.objectFactory.cdi.jndiKey</code> is given, this key will be looked up</li>\n *     <li>if no BeanManager found so far, look under {@link #CDI_JNDIKEY_BEANMANAGER_COMP}</li>\n *     <li>if no BeanManager found so far, look under {@link #CDI_JNDIKEY_BEANMANAGER_APP}</li>\n *     <li>if no BeanManager found so far, look under {@link #CDI_JNDIKEY_BEANMANAGER_COMP_ENV}</li>\n * </ul>\n */\npublic class CdiObjectFactory extends ObjectFactory {\n\n    private static final Logger LOG = LogManager.getLogger(CdiObjectFactory.class);\n\n    /**\n     * The key under which the BeanManager can be found according to CDI API docs\n     */\n    public static final String CDI_JNDIKEY_BEANMANAGER_COMP = \"java:comp/BeanManager\";\n    /**\n     * The key under which the BeanManager can be found according to JBoss Weld docs\n     */\n    public static final String CDI_JNDIKEY_BEANMANAGER_APP = \"java:app/BeanManager\";\n    /**\n     * The key under which the BeanManager can be found in pure Servlet containers according to JBoss Weld docs.\n     */\n    public static final String CDI_JNDIKEY_BEANMANAGER_COMP_ENV = \"java:comp/env/BeanManager\";\n\n    public static final String STRUTS_OBJECT_FACTORY_CDI_JNDI_KEY = \"struts.objectFactory.cdi.jndiKey\";\n\n    private String jndiKey;\n\n    @Inject(value = STRUTS_OBJECT_FACTORY_CDI_JNDI_KEY, required = false)\n    public void setJndiKey( String jndiKey ) {\n        this.jndiKey = jndiKey;\n    }\n\n    protected BeanManager beanManager;\n\n    Map<Class<?>, InjectionTarget<?>> injectionTargetCache = new ConcurrentHashMap<Class<?>, InjectionTarget<?>>();\n\n    public CdiObjectFactory() {\n        LOG.info(\"Initializing Struts2 CDI integration...\");\n        this.beanManager = findBeanManager();\n        if (beanManager != null) {\n            LOG.info(\"Struts2 CDI integration initialized.\");\n        } else {\n            LOG.error(\"Struts2 CDI integration could not be initialized.\");\n        }\n    }\n\n    /**\n     * Try to find the CDI BeanManager from JNDI context. First, if provided, the key given by\n     * struts.objectFactory.cdi.jndiKey will be checked. Then, if nothing was found or no explicit configuration was\n     * given, the key {@link #CDI_JNDIKEY_BEANMANAGER_COMP} will be tested. If nothing is found there, the key {@link\n     * #CDI_JNDIKEY_BEANMANAGER_APP} will be checked. If still nothing is found there, the key {@link\n     * #CDI_JNDIKEY_BEANMANAGER_COMP_ENV} will be checked.\n     *\n     * @return the BeanManager, if found. <tt>null</tt> otherwise.\n     */\n    protected BeanManager findBeanManager() {\n        BeanManager bm = null;\n        try {\n            Context initialContext = new InitialContext();\n            if (jndiKey != null && jndiKey.trim().length() > 0) {\n                // Check explicit configuration first, if given\n                bm = lookup(initialContext, jndiKey);\n            }\n            if (bm == null) {\n                // Check CDI default\n                bm = lookup(initialContext, CDI_JNDIKEY_BEANMANAGER_COMP);\n            }\n            if (bm == null) {\n                // Check WELD default\n                bm = lookup(initialContext, CDI_JNDIKEY_BEANMANAGER_APP);\n            }\n            if (bm == null) {\n                // Check Tomcat / Jetty default\n                bm = lookup(initialContext, CDI_JNDIKEY_BEANMANAGER_COMP_ENV);\n            }\n            if (bm == null) {\n                LOG.error(\"[findBeanManager]: Could not find BeanManager instance for any given JNDI key, giving up\");\n            }\n        } catch ( NamingException e ) {\n            LOG.error(\"[findBeanManager]: Unable to get InitialContext for BeanManager lookup\", e);\n        }\n        return bm;\n    }\n\n    /**\n     * Lookup the given JNDI key in the given context.\n     *\n     * @param context the context to use for lookup.\n     * @param jndiKeyToCheck the key to lookup.\n     *\n     * @return the BeanManager, if found; <tt>null</tt> if not found or {@link javax.naming.NamingException} was thrown.\n     */\n    protected BeanManager lookup( Context context, String jndiKeyToCheck ) {\n        LOG.info(\"[lookup]: Checking for BeanManager under JNDI key {}\", jndiKeyToCheck);\n        BeanManager result = null;\n        try {\n            result = (BeanManager) context.lookup(jndiKeyToCheck);\n        } catch ( NamingException e ) {\n            LOG.debug(\"[lookup]: BeanManager lookup failed for JNDI key {}\", jndiKeyToCheck, e);\n        }\n        return result;\n    }\n\n    @Override\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n    public Object buildBean(String className, Map<String, Object> extraContext, boolean injectInternal)\n            throws Exception {\n\n        Class<?> clazz = getClassInstance(className);\n        InjectionTarget injectionTarget = getInjectionTarget(clazz);\n\n        // a separate CreationalContext is required for every bean\n        final CreationalContext ctx = buildNonContextualCreationalContext(beanManager);\n\n        Object o = injectionTarget.produce(ctx);\n        injectionTarget.inject(o, ctx);\n        injectionTarget.postConstruct(o);\n\n        if (injectInternal) {\n            injectInternalBeans(o);\n        }\n\n        return o;\n    }\n\n    /**\n     * Get a InjectionTarget instance for a given class. If the appropriate target is not found in cache, a nw instance\n     * will be created.\n     *\n     * @param clazz The class to get a InjectionTarget instance for.\n     * @return if found in cache, an existing instance. A new instance otherwise.\n     */\n    protected InjectionTarget<?> getInjectionTarget(Class<?> clazz) {\n        InjectionTarget<?> result;\n        result = injectionTargetCache.get(clazz);\n        if (result == null) {\n            final InjectionTargetFactory<?> injectionTargetFactory =\n                    beanManager.getInjectionTargetFactory(beanManager.createAnnotatedType(clazz));\n            result = injectionTargetFactory.createInjectionTarget(null);\n            injectionTargetCache.put(clazz, result);\n        }\n\n        return result;\n    }\n\n    /**\n     * Simple wrapper for CreationalContext creation.\n     *\n     * @param beanManager the BeanManager to use for creating the context.\n     * @return the context to use, if given BeanManager was not <tt>null</tt>. <tt>null</tt> otherwise.\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected CreationalContext buildNonContextualCreationalContext(BeanManager beanManager) {\n        return beanManager != null ? beanManager.createCreationalContext(null) : null;\n    }\n\n    /**\n     * Allow constructor injection\n     */\n    @Override\n    public boolean isNoArgConstructorRequired() {\n        return false;\n    }\n\n}\n"}
{"test_method": "@Test\n    public void testContainsBean() {\n        MockBeanFactory mockBeanFactory = new MockBeanFactory();\n\n        Assert.assertTrue(\"OsgiUtil containsBean() on mock bean factory with numeric id is false ?\", OsgiUtil.containsBean(mockBeanFactory, \"1000\"));\n        Assert.assertFalse(\"OsgiUtil containsBean() on mock bean factory with nonnumeric id is true ?\", OsgiUtil.containsBean(mockBeanFactory, \"NotANumber\"));\n        Assert.assertFalse(\"OsgiUtil containsBean() on mock bean factory with null id is true ?\", OsgiUtil.containsBean(mockBeanFactory, null));\n    }", "focal_method": "public static boolean containsBean(Object beanFactory, String beanId) {\n        try {\n            Method getBeanMethod = beanFactory.getClass().getMethod(\"containsBean\", String.class);\n            return (Boolean) getBeanMethod.invoke(beanFactory, beanId);\n        } catch (Exception ex) {\n            LOG.error(\"Unable to call containsBean() on object of type [{}], with bean id [{}]\", beanFactory.getClass().getName(), beanId, ex);\n        }\n\n        return false;\n    }", "test_file": "/*\n * Copyright 2020 Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.struts2.osgi;\n\nimport org.junit.Assert;\nimport org.junit.Test;\n\n/**\n *  Basic tests for OsgiUtil\n */\npublic class OsgiUtilTest  {\n\n    /*\n     * An independent unit test for OsgiUtil.translateBundleURLToJarURL() would be nice, but appears\n     * complicated to do without either creating and installing a custom URL handler or using\n     * one of the Mock frameworks that can mock final classes like URL.\n     */\n\n    @Test\n    public void testGetBean() {\n        MockBeanFactory mockBeanFactory = new MockBeanFactory();\n\n        Object mockBean = OsgiUtil.getBean(mockBeanFactory, \"1000\");\n        Assert.assertNotNull(\"OsgiUtil getBean() on mock bean factory returned null ?\", mockBean);\n        Assert.assertTrue(\"Mock bean from mock bean factory has mismatched id ?\", mockBeanFactory.beanMatchesId(mockBean, \"1000\"));\n\n        mockBean = OsgiUtil.getBean(new Object(), \"1000\");  // Logs an error (coverage only).\n        Assert.assertNull(\"OsgiUtil getBean() on normal object found a getBean() method ?\", mockBean);\n    }\n\n    @Test\n    public void testContainsBean() {\n        MockBeanFactory mockBeanFactory = new MockBeanFactory();\n\n        Assert.assertTrue(\"OsgiUtil containsBean() on mock bean factory with numeric id is false ?\", OsgiUtil.containsBean(mockBeanFactory, \"1000\"));\n        Assert.assertFalse(\"OsgiUtil containsBean() on mock bean factory with nonnumeric id is true ?\", OsgiUtil.containsBean(mockBeanFactory, \"NotANumber\"));\n        Assert.assertFalse(\"OsgiUtil containsBean() on mock bean factory with null id is true ?\", OsgiUtil.containsBean(mockBeanFactory, null));\n    }\n\n    @Test\n    public void testGenerateJavaVersionForSystemPackages() {\n        // Some test patterns copied from OgnlRuntimeTest.testMajorJavaVersionParse() in OGNL 3.2.x.\n        // Pre-JDK 9 version strings.\n        Assert.assertEquals(\"JDK 5 generate java version failed ?\", \"1.5\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.5\"));\n        Assert.assertEquals(\"JDK 5 generate java version failed ?\", \"1.5\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.5.0\"));\n        Assert.assertEquals(\"JDK 5 generate java version failed ?\", \"1.5\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.5.0_21-b11\"));\n        Assert.assertEquals(\"JDK 6 generate java version failed ?\", \"1.6\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.6\"));\n        Assert.assertEquals(\"JDK 6 generate java version failed ?\", \"1.6\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.6.0\"));\n        Assert.assertEquals(\"JDK 6 generate java version failed ?\", \"1.6\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.6.0_43-b19\"));\n        Assert.assertEquals(\"JDK 7 generate java version failed ?\", \"1.7\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.7\"));\n        Assert.assertEquals(\"JDK 7 generate java version failed ?\", \"1.7\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.7.0\"));\n        Assert.assertEquals(\"JDK 7 generate java version failed ?\", \"1.7\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.7.0_79-b15\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"1.8\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.8\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"1.8\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.8.0\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"1.8\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.8.0_201-b20\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"1.8\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.8.0-someopenjdkstyle\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"1.8\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.8.0_201-someopenjdkstyle\"));\n        // JDK 9 and later version strings.\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"9.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"9\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"9.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"9-ea+19\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"9.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"9+100\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"9.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"9-ea+19\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"9.1\", OsgiUtil.generateJavaVersionForSystemPackages(\"9.1.3+15\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"9.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"9-someopenjdkstyle\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"10.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"10\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"10.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"10-ea+11\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"10.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"10+10\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"10.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"10-ea+11\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"10.1\", OsgiUtil.generateJavaVersionForSystemPackages(\"10.1.3+15\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"10.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"10-someopenjdkstyle\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"11.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"11\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"11.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"11-ea+22\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"11.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"11+33\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"11.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"11-ea+19\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"11.1\", OsgiUtil.generateJavaVersionForSystemPackages(\"11.1.3+15\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"11.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"11-someopenjdkstyle\"));\n    }\n\n    @Test\n    public void testGenerateJava_SE_SystemPackageVersionString() {\n        // Some test patterns copied from OgnlRuntimeTest.testMajorJavaVersionParse() in OGNL 3.2.x.\n        // Pre-JDK 9 version strings.\n        Assert.assertEquals(\"JDK 5 generate java version failed ?\", \"0.0.0.JavaSE_001_005\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.5\"));\n        Assert.assertEquals(\"JDK 5 generate java version failed ?\", \"0.0.0.JavaSE_001_005\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.5.0\"));\n        Assert.assertEquals(\"JDK 5 generate java version failed ?\", \"0.0.0.JavaSE_001_005\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.5.0_21-b11\"));\n        Assert.assertEquals(\"JDK 6 generate java version failed ?\", \"0.0.0.JavaSE_001_006\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.6\"));\n        Assert.assertEquals(\"JDK 6 generate java version failed ?\", \"0.0.0.JavaSE_001_006\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.6.0\"));\n        Assert.assertEquals(\"JDK 6 generate java version failed ?\", \"0.0.0.JavaSE_001_006\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.6.0_43-b19\"));\n        Assert.assertEquals(\"JDK 7 generate java version failed ?\", \"0.0.0.JavaSE_001_007\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.7\"));\n        Assert.assertEquals(\"JDK 7 generate java version failed ?\", \"0.0.0.JavaSE_001_007\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.7.0\"));\n        Assert.assertEquals(\"JDK 7 generate java version failed ?\", \"0.0.0.JavaSE_001_007\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.7.0_79-b15\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"0.0.0.JavaSE_001_008\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.8\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"0.0.0.JavaSE_001_008\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.8.0\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"0.0.0.JavaSE_001_008\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.8.0_201-b20\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"0.0.0.JavaSE_001_008\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.8.0-someopenjdkstyle\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"0.0.0.JavaSE_001_008\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.8.0_201-someopenjdkstyle\"));\n        // JDK 9 and later version strings.\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"0.0.0.JavaSE_009\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"9\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"0.0.0.JavaSE_009\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"9-ea+19\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"0.0.0.JavaSE_009\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"9+100\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"0.0.0.JavaSE_009\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"9-ea+19\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"0.0.0.JavaSE_009\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"9.1.3+15\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"0.0.0.JavaSE_009\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"9-someopenjdkstyle\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"0.0.0.JavaSE_010\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"10\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"0.0.0.JavaSE_010\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"10-ea+11\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"0.0.0.JavaSE_010\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"10+10\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"0.0.0.JavaSE_010\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"10-ea+11\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"0.0.0.JavaSE_010\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"10.1.3+15\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"0.0.0.JavaSE_010\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"10-someopenjdkstyle\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"0.0.0.JavaSE_011\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"11\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"0.0.0.JavaSE_011\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"11-ea+22\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"0.0.0.JavaSE_011\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"11+33\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"0.0.0.JavaSE_011\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"11-ea+19\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"0.0.0.JavaSE_011\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"11.1.3+15\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"0.0.0.JavaSE_011\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"11-someopenjdkstyle\"));\n    }\n\n    private class MockBeanFactory {\n\n        public Object getBean(String beanId) {\n            return \"MockBean: \" + beanId;\n        }\n\n        public boolean containsBean(String beanId) {\n            boolean result = false;\n\n            if (beanId != null) {\n                try {\n                    Integer.parseInt(beanId);\n                    result = true;\n                } catch (NumberFormatException nfe) {\n                    result = false;\n                }\n            }\n\n            return result;\n        }\n\n        public final boolean beanMatchesId(Object mockBean, String beanId) {\n            return mockBean.equals(\"MockBean: \" + beanId);\n        }\n\n    }\n\n}\n", "focal_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.osgi;\n\nimport org.apache.logging.log4j.Logger;\nimport org.apache.logging.log4j.LogManager;\nimport org.osgi.framework.Bundle;\n\nimport java.lang.reflect.Method;\nimport java.net.MalformedURLException;\nimport java.net.URL;\n\npublic class OsgiUtil {\n\n    private static final Logger LOG = LogManager.getLogger(OsgiUtil.class);\n\n    /**\n     * A bundle is a jar, and a bundle URL will be useless to clients, this method translates\n     * a URL to a resource inside a bundle from \"bundle:something/path\" to \"jar:file:bundlelocation!/path\"\n     *\n     * @param bundleUrl URL to translate\n     * @param bundle the bundle\n     *\n     * @return translated URL\n     *\n     * @throws MalformedURLException if URL is malformed\n     */\n    public static URL translateBundleURLToJarURL(URL bundleUrl, Bundle bundle) throws MalformedURLException {\n        if (bundleUrl != null && \"bundle\".equalsIgnoreCase(bundleUrl.getProtocol())) {\n            StringBuilder sb = new StringBuilder(\"jar:\");\n            sb.append(bundle.getLocation());\n            sb.append(\"!\");\n            sb.append(bundleUrl.getFile());\n            return new URL(sb.toString());\n        }\n\n        return bundleUrl;\n    }\n\n    /**\n     * Calls getBean() on the passed object using reflection. Used on Spring context\n     * because they are loaded from bundles (in another class loader)\n     *\n     * @param beanFactory bean factory\n     * @param beanId id of bean\n     *\n     * @return the object found\n     */\n    public static Object getBean(Object beanFactory, String beanId) {\n        try {\n            Method getBeanMethod = beanFactory.getClass().getMethod(\"getBean\", String.class);\n            return getBeanMethod.invoke(beanFactory, beanId);\n        } catch (Exception ex) {\n            LOG.error(\"Unable to call getBean() on object of type [{}], with bean id [{}]\",  beanFactory.getClass().getName(), beanId, ex);\n        }\n\n        return null;\n    }\n\n    /**\n     * Calls containsBean on the passed object using reflection. Used on Spring context\n     * because they are loaded from bundles (in another class loader)\n     *\n     * @param beanFactory bean factory\n     * @param beanId id of bean\n     *\n     * @return true if bean factory contains bean with bean id\n     */\n    public static boolean containsBean(Object beanFactory, String beanId) {\n        try {\n            Method getBeanMethod = beanFactory.getClass().getMethod(\"containsBean\", String.class);\n            return (Boolean) getBeanMethod.invoke(beanFactory, beanId);\n        } catch (Exception ex) {\n            LOG.error(\"Unable to call containsBean() on object of type [{}], with bean id [{}]\", beanFactory.getClass().getName(), beanId, ex);\n        }\n\n        return false;\n    }\n\n    /**\n     * Attempt to generate an OSGi compatible Java version String from the System \"java.version\" property,\n     * with the form (where x is the major version number): 1.x for Java 8 and earlier, x.y for Java 9+.\n     * See <a href=\"https://openjdk.java.net/jeps/223\">JEP 223: New Version-String Scheme</a> for details\n     * on version naming changes.\n     * \n     * @param systemJavaVersion a Java version string from System.getProperty(\"java.version\") or equivalent.\n     * @return a String of the form (where x is the major version number): 1.x for Java 8 and earlier, x.y for Java 9+.\n     */\n    public static String generateJavaVersionForSystemPackages(String systemJavaVersion) {\n        if (systemJavaVersion == null || systemJavaVersion.isEmpty()) {\n            throw new IllegalArgumentException(\"Cannot parse Java version from null or empty string\");\n        } else {\n            String parsedResult;\n            final int dotIndex1 = systemJavaVersion.indexOf('.');\n            final int dotIndex2 = (dotIndex1 > 0 ? systemJavaVersion.indexOf('.', dotIndex1 + 1) : -1);\n            if (dotIndex1 > 0 && dotIndex2 > 0) {\n                parsedResult = systemJavaVersion.substring(0, dotIndex2);  // Assuming Java 8 or older style, or Java 9+ with a minor or security update.\n            } else if (dotIndex1 > 0) {\n                parsedResult = systemJavaVersion;  // Assuming a truncated Java 8 or older style, or Java 9+ with a minor or security update.\n            } else if (dotIndex1 == -1) {\n                final int minusIndex = systemJavaVersion.indexOf('-');\n                final int plusIndex = systemJavaVersion.indexOf('+');\n                if (minusIndex > 0) {\n                    parsedResult = systemJavaVersion.substring(0, minusIndex);  // Assuming Java 9+ early-access\n                } else if (plusIndex > 0) {\n                    parsedResult = systemJavaVersion.substring(0, plusIndex);  // Assuming Java 9+ java.runime.version or java.vm.version string\n                } else {\n                    parsedResult = systemJavaVersion;\n                }\n                try {\n                    final int firstNumber = Integer.parseInt(parsedResult);\n                    if (firstNumber >= 9) {\n                        parsedResult = parsedResult + \".0\";  // Assuming Java 9+ and no minor or security update, append standard value.\n                    } else {\n                        throw new IllegalArgumentException(\"Single digit Java version string less than 9 (nonsense)\");\n                    }\n                } catch (Exception ex) {\n                    throw new IllegalArgumentException(\"Cannot parse Java version string (probable non-numeric start)\", ex);\n                }\n            } else {\n                throw new IllegalArgumentException(\"Cannot parse Java version from a string starting with a '.'\");\n            }\n            return parsedResult;\n        }\n    }\n\n    /**\n     * Attempt to generate an OSGi compatible Java SE system package version String from the System \"java.version\" property,\n     * with the form (where x or xx is the major version number): 0.0.0.JavaSE_001_00x for Java 8 and earlier (e.g. 0.0.0.JavaSE_001_008),\n     * 0.0.0.JavaSE_0xx for Java 9+ (e.g. 0.0.0.JavaSE_009 for Java 9, 0.0.0.JavaSE_011 for Java 11).\n     * \n     * @param systemJavaVersion a Java version string from System.getProperty(\"java.version\") or equivalent.\n     * @return a String of the form (where x or xx is the major version number): JavaSE_001_00x for Java 8 and earlier, JavaSE_0xx for Java 9+.\n     */\n    public static String generateJava_SE_SystemPackageVersionString(String systemJavaVersion) {\n        final String javaVersionForSystemPackages = generateJavaVersionForSystemPackages(systemJavaVersion);\n        final int dotIndex = javaVersionForSystemPackages.indexOf('.');\n        if (dotIndex > 0) {\n            final String generatedResult;\n            try {\n                final String prefix = javaVersionForSystemPackages.substring(0, dotIndex);\n                final String suffix = javaVersionForSystemPackages.substring(dotIndex + 1);\n                final int firstNumber = Integer.parseInt(prefix);\n                final int secondNumber = Integer.parseInt(suffix);\n                if (firstNumber >= 9) {\n                    generatedResult = String.format(\"0.0.0.JavaSE_%03d\", firstNumber);  // Assuming Java 9+\n                } else {\n                    generatedResult = String.format(\"0.0.0.JavaSE_001_%03d\", secondNumber);  // Assuming Java 8 or earlier\n                }\n                return generatedResult;\n            } catch (Exception ex) {\n                throw new IllegalArgumentException(\"Cannot parse Java version string (probable non-numeric start)\", ex);\n            }\n        } else {\n                throw new IllegalArgumentException(\"Cannot parse Java version from a system packages string missing or starting with a '.'\");\n        }\n    }\n}\n"}
{"test_method": "@Test\n    public void testClassesToString() {\n        ConstantConfig constantConfig = new ConstantConfig();\n\n        Set<Class<?>> excludedClasses = new LinkedHashSet<>();\n        excludedClasses.add(Object.class);\n        excludedClasses.add(Runtime.class);\n        excludedClasses.add(System.class);\n\n        constantConfig.setExcludedClasses(excludedClasses);\n        constantConfig.setDevModeExcludedClasses(excludedClasses);\n\n        Map<String, String> map = constantConfig.getAllAsStringsMap();\n        Assert.assertEquals(\"java.lang.Object,java.lang.Runtime,java.lang.System\",\n            map.get(StrutsConstants.STRUTS_EXCLUDED_CLASSES));\n        Assert.assertEquals(\"java.lang.Object,java.lang.Runtime,java.lang.System\",\n            map.get(StrutsConstants.STRUTS_DEV_MODE_EXCLUDED_CLASSES));\n    }", "focal_method": "private String classesToString(Set<Class<?>> classes) {\n        List<String> list = null;\n        if (classes != null && !classes.isEmpty()) {\n            list = new ArrayList<>();\n            for (Class<?> c : classes) {\n                list.add(c.getName());\n            }\n        }\n        return StringUtils.join(list, ',');\n    }", "test_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.config.entities;\n\nimport com.opensymphony.xwork2.TestBean;\nimport com.opensymphony.xwork2.inject.Container;\nimport org.apache.struts2.StrutsConstants;\nimport org.apache.struts2.dispatcher.StaticContentLoader;\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport java.util.Arrays;\nimport java.util.LinkedHashSet;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class ConstantConfigTest {\n\n    @Test\n    public void testBeanConfToString() {\n        ConstantConfig constantConfig = new ConstantConfig();\n\n        String actual = constantConfig.beanConfToString(null);\n        Assert.assertNull(actual);\n\n        actual = constantConfig.beanConfToString(new BeanConfig(TestBean.class));\n        Assert.assertEquals(Container.DEFAULT_NAME, actual);\n\n        String expectedName = \"expectedTestBeanName\";\n        actual = constantConfig.beanConfToString(new BeanConfig(TestBean.class, expectedName));\n        Assert.assertEquals(expectedName, actual);\n    }\n\n    @Test\n    public void testGetAllAsStringsMap() {\n        ConstantConfig constantConfig = new ConstantConfig();\n\n        boolean expectedDevMode = true;\n        constantConfig.setDevMode(expectedDevMode);\n\n        String expectedActionExtensions = \".action,.some,.another\";\n        constantConfig.setActionExtension(Arrays.asList(expectedActionExtensions.split(\",\")));\n\n        String expectedLanguage = \"fr\";\n        constantConfig.setLocale(new Locale(expectedLanguage));\n\n        Map<String, String> map = constantConfig.getAllAsStringsMap();\n\n        Assert.assertEquals(String.valueOf(expectedDevMode), map.get(StrutsConstants.STRUTS_DEVMODE));\n        Assert.assertEquals(expectedActionExtensions, map.get(StrutsConstants.STRUTS_ACTION_EXTENSION));\n        Assert.assertNull(map.get(StrutsConstants.STRUTS_I18N_RELOAD));\n        Assert.assertEquals(expectedLanguage, map.get(StrutsConstants.STRUTS_LOCALE));\n    }\n\n    @Test\n    public void testEmptyClassesToString() {\n        ConstantConfig constantConfig = new ConstantConfig();\n\n        constantConfig.setExcludedClasses(null);\n        constantConfig.setExcludedPackageNamePatterns(null);\n        constantConfig.setExcludedPackageNames(null);\n        constantConfig.setExcludedPackageExemptClasses(null);\n        constantConfig.setDevModeExcludedClasses(null);\n        constantConfig.setDevModeExcludedPackageNamePatterns(null);\n        constantConfig.setDevModeExcludedPackageNames(null);\n        constantConfig.setDevModeExcludedPackageExemptClasses(null);\n\n        Map<String, String> map = constantConfig.getAllAsStringsMap();\n        Assert.assertNull(map.get(StrutsConstants.STRUTS_EXCLUDED_CLASSES));\n        Assert.assertNull(map.get(StrutsConstants.STRUTS_EXCLUDED_PACKAGE_NAME_PATTERNS));\n        Assert.assertNull(map.get(StrutsConstants.STRUTS_EXCLUDED_PACKAGE_NAMES));\n        Assert.assertNull(map.get(StrutsConstants.STRUTS_DEV_MODE_EXCLUDED_CLASSES));\n        Assert.assertNull(map.get(StrutsConstants.STRUTS_DEV_MODE_EXCLUDED_PACKAGE_NAME_PATTERNS));\n        Assert.assertNull(map.get(StrutsConstants.STRUTS_DEV_MODE_EXCLUDED_PACKAGE_NAMES));\n    }\n\n    @Test\n    public void testClassesToString() {\n        ConstantConfig constantConfig = new ConstantConfig();\n\n        Set<Class<?>> excludedClasses = new LinkedHashSet<>();\n        excludedClasses.add(Object.class);\n        excludedClasses.add(Runtime.class);\n        excludedClasses.add(System.class);\n\n        constantConfig.setExcludedClasses(excludedClasses);\n        constantConfig.setDevModeExcludedClasses(excludedClasses);\n\n        Map<String, String> map = constantConfig.getAllAsStringsMap();\n        Assert.assertEquals(\"java.lang.Object,java.lang.Runtime,java.lang.System\",\n            map.get(StrutsConstants.STRUTS_EXCLUDED_CLASSES));\n        Assert.assertEquals(\"java.lang.Object,java.lang.Runtime,java.lang.System\",\n            map.get(StrutsConstants.STRUTS_DEV_MODE_EXCLUDED_CLASSES));\n    }\n\n    @Test\n    public void testExemptClassesToString() {\n        ConstantConfig constantConfig = new ConstantConfig();\n\n        Set<Class<?>> exemptClasses = new LinkedHashSet<>();\n        exemptClasses.add(Object.class);\n        exemptClasses.add(Runtime.class);\n        exemptClasses.add(System.class);\n\n        constantConfig.setExcludedPackageExemptClasses(exemptClasses);\n        constantConfig.setDevModeExcludedPackageExemptClasses(exemptClasses);\n\n        Map<String, String> map = constantConfig.getAllAsStringsMap();\n        Assert.assertEquals(\"java.lang.Object,java.lang.Runtime,java.lang.System\",\n                map.get(StrutsConstants.STRUTS_EXCLUDED_PACKAGE_EXEMPT_CLASSES));\n        Assert.assertEquals(\"java.lang.Object,java.lang.Runtime,java.lang.System\",\n                map.get(StrutsConstants.STRUTS_DEV_MODE_EXCLUDED_PACKAGE_EXEMPT_CLASSES));\n    }\n\n    @Test\n    public void testSettingStaticContentPath() {\n        // given\n        ConstantConfig config = new ConstantConfig();\n\n        // when\n        config.setStaticContentPath(null);\n        // then\n        Assert.assertEquals(StaticContentLoader.DEFAULT_STATIC_CONTENT_PATH, config.getStaticContentPath());\n\n        // when\n        config.setStaticContentPath(\" \");\n        // then\n        Assert.assertEquals(StaticContentLoader.DEFAULT_STATIC_CONTENT_PATH, config.getStaticContentPath());\n\n        // when\n        config.setStaticContentPath(\"content\");\n        // then\n        Assert.assertEquals(\"/content\", config.getStaticContentPath());\n\n        // when\n        config.setStaticContentPath(\"/content\");\n        // then\n        Assert.assertEquals(\"/content\", config.getStaticContentPath());\n    }\n\n}\n", "focal_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.config.entities;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.struts2.StrutsConstants;\nimport org.apache.struts2.dispatcher.StaticContentLoader;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\npublic class ConstantConfig {\n    private Boolean devMode;\n    private Boolean i18nReload;\n    private String i18nEncoding;\n    private Boolean configurationXmlReload;\n    private List<String> actionExtension;\n    private List<Pattern> actionExcludePattern;\n    private Integer urlHttpPort;\n    private Integer urlHttpsPort;\n    private String urlIncludeParams;\n    private BeanConfig urlRenderer;\n    private BeanConfig objectFactory;\n    private BeanConfig objectFactoryActionFactory;\n    private BeanConfig objectFactoryResultFactory;\n    private BeanConfig objectFactoryConverterFactory;\n    private BeanConfig objectFactoryInterceptorFactory;\n    private BeanConfig objectFactoryValidatorFactory;\n    private BeanConfig objectFactoryUnknownHandlerFactory;\n    private BeanConfig objectTypeDeterminer;\n    private Locale locale;\n    private Boolean dispatcherParametersWorkaround;\n    private BeanConfig freemarkerManagerClassname;\n    private String freemarkerTemplatesCacheUpdateDelay;\n    private Boolean freemarkerBeanwrapperCache;\n    private Integer freemarkerMruMaxStrongSize;\n    private BeanConfig velocityManagerClassname;\n    private String velocityConfigfile;\n    private String velocityToolboxlocation;\n    private List<String> velocityContexts;\n    private String uiTemplateDir;\n    private String uiTheme;\n    private String uiThemeExpansionToken;\n    private Long multipartMaxSize;\n    private Long multipartMaxFiles;\n    private Long multipartMaxFileSize;\n    private Long multipartMaxStringLength;\n    private String multipartSaveDir;\n    private Integer multipartBufferSize;\n    private BeanConfig multipartParser;\n    private Boolean multipartEnabled;\n    private Pattern multipartValidationRegex;\n    private String objectFactorySpringAutoWire;\n    private Boolean objectFactorySpringAutoWireAlwaysRespect;\n    private Boolean objectFactorySpringUseClassCache;\n    private Boolean objectFactorySpringEnableAopSupport;\n    private Boolean xsltNocache;\n    private List<String> customProperties;\n    private List<String> customI18nResources;\n    private BeanConfig mapperClass;\n    private List<String> mapperPrefixMapping;\n    private Boolean serveStatic;\n    private Boolean serveStaticBrowserCache;\n    private Boolean enableDynamicMethodInvocation;\n    private Boolean enableSlashesInActionNames;\n    private List<String> mapperComposite;\n    private BeanConfig actionProxyFactory;\n    private Boolean freemarkerWrapperAltMap;\n    private BeanConfig xworkConverter;\n    private Boolean mapperAlwaysSelectFullNamespace;\n    private BeanConfig localeProviderFactory;\n    private String mapperIdParameterName;\n    private Boolean ognlAllowStaticFieldAccess;\n    private BeanConfig actionValidatorManager;\n    private BeanConfig valueStackFactory;\n    private BeanConfig reflectionProvider;\n    private BeanConfig reflectionContextFactory;\n    private BeanConfig patternMatcher;\n    private BeanConfig staticContentLoader;\n    private BeanConfig unknownHandlerManager;\n    private Boolean elThrowExceptionOnFailure;\n    private Boolean ognlLogMissingProperties;\n    private Boolean ognlEnableExpressionCache;\n    private Boolean ognlEnableEvalExpression;\n    private Boolean disableRequestAttributeValueStackLookup;\n    private BeanConfig viewUrlHelper;\n    private BeanConfig converterCollection;\n    private BeanConfig converterArray;\n    private BeanConfig converterDate;\n    private BeanConfig converterNumber;\n    private BeanConfig converterString;\n    private Boolean handleException;\n    private BeanConfig converterPropertiesProcessor;\n    private BeanConfig converterFileProcessor;\n    private BeanConfig converterAnnotationProcessor;\n    private BeanConfig converterCreator;\n    private BeanConfig ConverterHolder;\n    private BeanConfig expressionParser;\n    private Pattern allowedActionNames;\n    private String defaultActionName;\n    private Pattern allowedMethodNames;\n    private String defaultMethodName;\n    private Boolean mapperActionPrefixEnabled;\n    private Boolean mapperActionPrefixCrossNamespaces;\n    private String uiTemplateSuffix;\n    private BeanConfig dispatcherErrorHandler;\n    private Set<Class<?>> excludedClasses;\n    private List<Pattern> excludedPackageNamePatterns;\n    private Set<String> excludedPackageNames;\n    private Set<Class<?>> excludedPackageExemptClasses;\n    private Set<Class<?>> devModeExcludedClasses;\n    private List<Pattern> devModeExcludedPackageNamePatterns;\n    private Set<String> devModeExcludedPackageNames;\n    private Set<Class<?>> devModeExcludedPackageExemptClasses;\n    private BeanConfig excludedPatternsChecker;\n    private BeanConfig acceptedPatternsChecker;\n    private BeanConfig notExcludedAcceptedPatternsChecker;\n    private Set<Pattern> overrideExcludedPatterns;\n    private Set<Pattern> overrideAcceptedPatterns;\n    private Set<Pattern> additionalExcludedPatterns;\n    private Set<Pattern> additionalAcceptedPatterns;\n    private BeanConfig contentTypeMatcher;\n    private String strictMethodInvocationMethodRegex;\n    private BeanConfig textProviderFactory;\n    private BeanConfig localizedTextProvider;\n    private Boolean disallowProxyMemberAccess;\n    private Integer ognlAutoGrowthCollectionLimit;\n    private String staticContentPath;\n    private BeanConfig expressionCacheFactory;\n    private BeanConfig beaninfoCacheFactory;\n\n    protected String beanConfToString(BeanConfig beanConf) {\n        return beanConf == null ? null : beanConf.getName();\n    }\n\n    private String classesToString(Set<Class<?>> classes) {\n        List<String> list = null;\n        if (classes != null && !classes.isEmpty()) {\n            list = new ArrayList<>();\n            for (Class<?> c : classes) {\n                list.add(c.getName());\n            }\n        }\n        return StringUtils.join(list, ',');\n    }\n\n    public Map<String, String> getAllAsStringsMap() {\n        Map<String, String> map = new HashMap<>();\n\n        map.put(StrutsConstants.STRUTS_DEVMODE, Objects.toString(devMode, null));\n        map.put(StrutsConstants.STRUTS_I18N_RELOAD, Objects.toString(i18nReload, null));\n        map.put(StrutsConstants.STRUTS_I18N_ENCODING, i18nEncoding);\n        map.put(StrutsConstants.STRUTS_CONFIGURATION_XML_RELOAD, Objects.toString(configurationXmlReload, null));\n        map.put(StrutsConstants.STRUTS_ACTION_EXTENSION, StringUtils.join(actionExtension, ','));\n        map.put(StrutsConstants.STRUTS_ACTION_EXCLUDE_PATTERN, StringUtils.join(actionExcludePattern, ','));\n        map.put(StrutsConstants.STRUTS_URL_HTTP_PORT, Objects.toString(urlHttpPort, null));\n        map.put(StrutsConstants.STRUTS_URL_HTTPS_PORT, Objects.toString(urlHttpsPort, null));\n        map.put(StrutsConstants.STRUTS_URL_INCLUDEPARAMS, urlIncludeParams);\n        map.put(StrutsConstants.STRUTS_URL_RENDERER, beanConfToString(urlRenderer));\n        map.put(StrutsConstants.STRUTS_OBJECTFACTORY, beanConfToString(objectFactory));\n        map.put(StrutsConstants.STRUTS_OBJECTFACTORY_ACTIONFACTORY, beanConfToString(objectFactoryActionFactory));\n        map.put(StrutsConstants.STRUTS_OBJECTFACTORY_RESULTFACTORY, beanConfToString(objectFactoryResultFactory));\n        map.put(StrutsConstants.STRUTS_OBJECTFACTORY_CONVERTERFACTORY, beanConfToString(objectFactoryConverterFactory));\n        map.put(StrutsConstants.STRUTS_OBJECTFACTORY_INTERCEPTORFACTORY, beanConfToString(objectFactoryInterceptorFactory));\n        map.put(StrutsConstants.STRUTS_OBJECTFACTORY_VALIDATORFACTORY, beanConfToString(objectFactoryValidatorFactory));\n        map.put(StrutsConstants.STRUTS_OBJECTFACTORY_UNKNOWNHANDLERFACTORY, beanConfToString(objectFactoryUnknownHandlerFactory));\n        map.put(StrutsConstants.STRUTS_OBJECTTYPEDETERMINER, beanConfToString(objectTypeDeterminer));\n        map.put(StrutsConstants.STRUTS_LOCALE, locale == null ? null : locale.getLanguage());\n        map.put(StrutsConstants.STRUTS_DISPATCHER_PARAMETERSWORKAROUND, Objects.toString(dispatcherParametersWorkaround, null));\n        map.put(StrutsConstants.STRUTS_FREEMARKER_MANAGER_CLASSNAME, beanConfToString(freemarkerManagerClassname));\n        map.put(StrutsConstants.STRUTS_FREEMARKER_TEMPLATES_CACHE_UPDATE_DELAY, freemarkerTemplatesCacheUpdateDelay);\n        map.put(StrutsConstants.STRUTS_FREEMARKER_BEANWRAPPER_CACHE, Objects.toString(freemarkerBeanwrapperCache, null));\n        map.put(StrutsConstants.STRUTS_FREEMARKER_MRU_MAX_STRONG_SIZE, Objects.toString(freemarkerMruMaxStrongSize, null));\n        map.put(StrutsConstants.STRUTS_VELOCITY_CONFIGFILE, velocityConfigfile);\n        map.put(StrutsConstants.STRUTS_VELOCITY_TOOLBOXLOCATION, velocityToolboxlocation);\n        map.put(StrutsConstants.STRUTS_VELOCITY_CONTEXTS, StringUtils.join(velocityContexts, ','));\n        map.put(StrutsConstants.STRUTS_UI_TEMPLATEDIR, uiTemplateDir);\n        map.put(StrutsConstants.STRUTS_UI_THEME, uiTheme);\n        map.put(StrutsConstants.STRUTS_UI_THEME_EXPANSION_TOKEN, uiThemeExpansionToken);\n        map.put(StrutsConstants.STRUTS_MULTIPART_MAXSIZE, Objects.toString(multipartMaxSize, null));\n        map.put(StrutsConstants.STRUTS_MULTIPART_MAXFILES, Objects.toString(multipartMaxFiles, null));\n        map.put(StrutsConstants.STRUTS_MULTIPART_MAXFILESIZE, Objects.toString(multipartMaxFileSize, null));\n        map.put(StrutsConstants.STRUTS_MULTIPART_MAX_STRING_LENGTH, Objects.toString(multipartMaxStringLength, null));\n        map.put(StrutsConstants.STRUTS_MULTIPART_SAVEDIR, multipartSaveDir);\n        map.put(StrutsConstants.STRUTS_MULTIPART_BUFFERSIZE, Objects.toString(multipartBufferSize, null));\n        map.put(StrutsConstants.STRUTS_MULTIPART_PARSER, beanConfToString(multipartParser));\n        map.put(StrutsConstants.STRUTS_MULTIPART_ENABLED, Objects.toString(multipartEnabled, null));\n        map.put(StrutsConstants.STRUTS_MULTIPART_VALIDATION_REGEX, Objects.toString(multipartValidationRegex, null));\n        map.put(StrutsConstants.STRUTS_OBJECTFACTORY_SPRING_AUTOWIRE, objectFactorySpringAutoWire);\n        map.put(StrutsConstants.STRUTS_OBJECTFACTORY_SPRING_AUTOWIRE_ALWAYS_RESPECT, Objects.toString(objectFactorySpringAutoWireAlwaysRespect, null));\n        map.put(StrutsConstants.STRUTS_OBJECTFACTORY_SPRING_USE_CLASS_CACHE, Objects.toString(objectFactorySpringUseClassCache, null));\n        map.put(StrutsConstants.STRUTS_OBJECTFACTORY_SPRING_ENABLE_AOP_SUPPORT, Objects.toString(objectFactorySpringEnableAopSupport, null));\n        map.put(StrutsConstants.STRUTS_CUSTOM_PROPERTIES, StringUtils.join(customProperties, ','));\n        map.put(StrutsConstants.STRUTS_CUSTOM_I18N_RESOURCES, StringUtils.join(customI18nResources, ','));\n        map.put(StrutsConstants.STRUTS_MAPPER_CLASS, beanConfToString(mapperClass));\n        map.put(StrutsConstants.PREFIX_BASED_MAPPER_CONFIGURATION, StringUtils.join(mapperPrefixMapping, ','));\n        map.put(StrutsConstants.STRUTS_SERVE_STATIC_CONTENT, Objects.toString(serveStatic, null));\n        map.put(StrutsConstants.STRUTS_SERVE_STATIC_BROWSER_CACHE, Objects.toString(serveStaticBrowserCache, null));\n        map.put(StrutsConstants.STRUTS_ENABLE_DYNAMIC_METHOD_INVOCATION, Objects.toString(enableDynamicMethodInvocation, null));\n        map.put(StrutsConstants.STRUTS_ENABLE_SLASHES_IN_ACTION_NAMES, Objects.toString(enableSlashesInActionNames, null));\n        map.put(StrutsConstants.STRUTS_MAPPER_COMPOSITE, StringUtils.join(mapperComposite, ','));\n        map.put(StrutsConstants.STRUTS_ACTIONPROXYFACTORY, beanConfToString(actionProxyFactory));\n        map.put(StrutsConstants.STRUTS_FREEMARKER_WRAPPER_ALT_MAP, Objects.toString(freemarkerWrapperAltMap, null));\n        map.put(StrutsConstants.STRUTS_XWORKCONVERTER, beanConfToString(xworkConverter));\n        map.put(StrutsConstants.STRUTS_ALWAYS_SELECT_FULL_NAMESPACE, Objects.toString(mapperAlwaysSelectFullNamespace, null));\n        map.put(StrutsConstants.STRUTS_LOCALE_PROVIDER_FACTORY, beanConfToString(localeProviderFactory));\n        map.put(StrutsConstants.STRUTS_ID_PARAMETER_NAME, mapperIdParameterName);\n        map.put(StrutsConstants.STRUTS_ALLOW_STATIC_FIELD_ACCESS, Objects.toString(ognlAllowStaticFieldAccess, null));\n        map.put(StrutsConstants.STRUTS_ACTIONVALIDATORMANAGER, beanConfToString(actionValidatorManager));\n        map.put(StrutsConstants.STRUTS_VALUESTACKFACTORY, beanConfToString(valueStackFactory));\n        map.put(StrutsConstants.STRUTS_REFLECTIONPROVIDER, beanConfToString(reflectionProvider));\n        map.put(StrutsConstants.STRUTS_REFLECTIONCONTEXTFACTORY, beanConfToString(reflectionContextFactory));\n        map.put(StrutsConstants.STRUTS_PATTERNMATCHER, beanConfToString(patternMatcher));\n        map.put(StrutsConstants.STRUTS_STATIC_CONTENT_LOADER, beanConfToString(staticContentLoader));\n        map.put(StrutsConstants.STRUTS_UNKNOWN_HANDLER_MANAGER, beanConfToString(unknownHandlerManager));\n        map.put(StrutsConstants.STRUTS_EL_THROW_EXCEPTION, Objects.toString(elThrowExceptionOnFailure, null));\n        map.put(StrutsConstants.STRUTS_OGNL_LOG_MISSING_PROPERTIES, Objects.toString(ognlLogMissingProperties, null));\n        map.put(StrutsConstants.STRUTS_OGNL_ENABLE_EXPRESSION_CACHE, Objects.toString(ognlEnableExpressionCache, null));\n        map.put(StrutsConstants.STRUTS_OGNL_ENABLE_EVAL_EXPRESSION, Objects.toString(ognlEnableEvalExpression, null));\n        map.put(StrutsConstants.STRUTS_DISABLE_REQUEST_ATTRIBUTE_VALUE_STACK_LOOKUP, Objects.toString(disableRequestAttributeValueStackLookup, null));\n        map.put(StrutsConstants.STRUTS_URL_HELPER, beanConfToString(viewUrlHelper));\n        map.put(StrutsConstants.STRUTS_CONVERTER_COLLECTION, beanConfToString(converterCollection));\n        map.put(StrutsConstants.STRUTS_CONVERTER_ARRAY, beanConfToString(converterArray));\n        map.put(StrutsConstants.STRUTS_CONVERTER_DATE, beanConfToString(converterDate));\n        map.put(StrutsConstants.STRUTS_CONVERTER_NUMBER, beanConfToString(converterNumber));\n        map.put(StrutsConstants.STRUTS_CONVERTER_STRING, beanConfToString(converterString));\n        map.put(StrutsConstants.STRUTS_HANDLE_EXCEPTION, Objects.toString(handleException, null));\n        map.put(StrutsConstants.STRUTS_CONVERTER_PROPERTIES_PROCESSOR, beanConfToString(converterPropertiesProcessor));\n        map.put(StrutsConstants.STRUTS_CONVERTER_FILE_PROCESSOR, beanConfToString(converterFileProcessor));\n        map.put(StrutsConstants.STRUTS_CONVERTER_ANNOTATION_PROCESSOR, beanConfToString(converterAnnotationProcessor));\n        map.put(StrutsConstants.STRUTS_CONVERTER_CREATOR, beanConfToString(converterCreator));\n        map.put(StrutsConstants.STRUTS_CONVERTER_HOLDER, beanConfToString(ConverterHolder));\n        map.put(StrutsConstants.STRUTS_EXPRESSION_PARSER, beanConfToString(expressionParser));\n        map.put(StrutsConstants.STRUTS_ALLOWED_ACTION_NAMES, Objects.toString(allowedActionNames, null));\n        map.put(StrutsConstants.STRUTS_DEFAULT_ACTION_NAME, defaultActionName);\n        map.put(StrutsConstants.STRUTS_ALLOWED_METHOD_NAMES, Objects.toString(allowedMethodNames, null));\n        map.put(StrutsConstants.STRUTS_DEFAULT_METHOD_NAME, defaultMethodName);\n        map.put(StrutsConstants.STRUTS_MAPPER_ACTION_PREFIX_ENABLED, Objects.toString(mapperActionPrefixEnabled, null));\n        map.put(StrutsConstants.DEFAULT_TEMPLATE_TYPE_CONFIG_KEY, uiTemplateSuffix);\n        map.put(StrutsConstants.STRUTS_DISPATCHER_ERROR_HANDLER, beanConfToString(dispatcherErrorHandler));\n        map.put(StrutsConstants.STRUTS_EXCLUDED_CLASSES, classesToString(excludedClasses));\n        map.put(StrutsConstants.STRUTS_EXCLUDED_PACKAGE_NAME_PATTERNS, StringUtils.join(excludedPackageNamePatterns, ','));\n        map.put(StrutsConstants.STRUTS_EXCLUDED_PACKAGE_NAMES, StringUtils.join(excludedPackageNames, ','));\n        map.put(StrutsConstants.STRUTS_EXCLUDED_PACKAGE_EXEMPT_CLASSES, classesToString(excludedPackageExemptClasses));\n        map.put(StrutsConstants.STRUTS_DEV_MODE_EXCLUDED_CLASSES, classesToString(devModeExcludedClasses));\n        map.put(StrutsConstants.STRUTS_DEV_MODE_EXCLUDED_PACKAGE_NAME_PATTERNS, StringUtils.join(devModeExcludedPackageNamePatterns, ','));\n        map.put(StrutsConstants.STRUTS_DEV_MODE_EXCLUDED_PACKAGE_NAMES, StringUtils.join(devModeExcludedPackageNames, ','));\n        map.put(StrutsConstants.STRUTS_DEV_MODE_EXCLUDED_PACKAGE_EXEMPT_CLASSES, classesToString(devModeExcludedPackageExemptClasses));\n        map.put(StrutsConstants.STRUTS_EXCLUDED_PATTERNS_CHECKER, beanConfToString(excludedPatternsChecker));\n        map.put(StrutsConstants.STRUTS_ACCEPTED_PATTERNS_CHECKER, beanConfToString(acceptedPatternsChecker));\n        map.put(StrutsConstants.STRUTS_NOT_EXCLUDED_ACCEPTED_PATTERNS_CHECKER, beanConfToString(notExcludedAcceptedPatternsChecker));\n        map.put(StrutsConstants.STRUTS_OVERRIDE_EXCLUDED_PATTERNS, StringUtils.join(overrideExcludedPatterns, ','));\n        map.put(StrutsConstants.STRUTS_OVERRIDE_ACCEPTED_PATTERNS, StringUtils.join(overrideAcceptedPatterns, ','));\n        map.put(StrutsConstants.STRUTS_ADDITIONAL_EXCLUDED_PATTERNS, StringUtils.join(additionalExcludedPatterns, ','));\n        map.put(StrutsConstants.STRUTS_ADDITIONAL_ACCEPTED_PATTERNS, StringUtils.join(additionalAcceptedPatterns, ','));\n        map.put(StrutsConstants.STRUTS_CONTENT_TYPE_MATCHER, beanConfToString(contentTypeMatcher));\n        map.put(StrutsConstants.STRUTS_SMI_METHOD_REGEX, strictMethodInvocationMethodRegex);\n        map.put(StrutsConstants.STRUTS_TEXT_PROVIDER_FACTORY, beanConfToString(textProviderFactory));\n        map.put(StrutsConstants.STRUTS_LOCALIZED_TEXT_PROVIDER, beanConfToString(localizedTextProvider));\n        map.put(StrutsConstants.STRUTS_DISALLOW_PROXY_MEMBER_ACCESS, Objects.toString(disallowProxyMemberAccess, null));\n        map.put(StrutsConstants.STRUTS_OGNL_AUTO_GROWTH_COLLECTION_LIMIT, Objects.toString(ognlAutoGrowthCollectionLimit, null));\n        map.put(StrutsConstants.STRUTS_UI_STATIC_CONTENT_PATH, Objects.toString(staticContentPath, StaticContentLoader.DEFAULT_STATIC_CONTENT_PATH));\n        map.put(StrutsConstants.STRUTS_OGNL_EXPRESSION_CACHE_FACTORY, beanConfToString(expressionCacheFactory));\n        map.put(StrutsConstants.STRUTS_OGNL_BEANINFO_CACHE_FACTORY, beanConfToString(beaninfoCacheFactory));\n\n        return map;\n    }\n\n    public Boolean getDevMode() {\n        return devMode;\n    }\n\n    public void setDevMode(Boolean devMode) {\n        this.devMode = devMode;\n    }\n\n    public Boolean getI18nReload() {\n        return i18nReload;\n    }\n\n    public void setI18nReload(Boolean i18nReload) {\n        this.i18nReload = i18nReload;\n    }\n\n    public String getI18nEncoding() {\n        return i18nEncoding;\n    }\n\n    public void setI18nEncoding(String i18nEncoding) {\n        this.i18nEncoding = i18nEncoding;\n    }\n\n    public Boolean getConfigurationXmlReload() {\n        return configurationXmlReload;\n    }\n\n    public void setConfigurationXmlReload(Boolean configurationXmlReload) {\n        this.configurationXmlReload = configurationXmlReload;\n    }\n\n    public List<String> getActionExtension() {\n        return actionExtension;\n    }\n\n    public void setActionExtension(List<String> actionExtension) {\n        this.actionExtension = actionExtension;\n    }\n\n    public List<Pattern> getActionExcludePattern() {\n        return actionExcludePattern;\n    }\n\n    public void setActionExcludePattern(List<Pattern> actionExcludePattern) {\n        this.actionExcludePattern = actionExcludePattern;\n    }\n\n    public Integer getUrlHttpPort() {\n        return urlHttpPort;\n    }\n\n    public void setUrlHttpPort(Integer urlHttpPort) {\n        this.urlHttpPort = urlHttpPort;\n    }\n\n    public Integer getUrlHttpsPort() {\n        return urlHttpsPort;\n    }\n\n    public void setUrlHttpsPort(Integer urlHttpsPort) {\n        this.urlHttpsPort = urlHttpsPort;\n    }\n\n    public String getUrlIncludeParams() {\n        return urlIncludeParams;\n    }\n\n    public void setUrlIncludeParams(String urlIncludeParams) {\n        this.urlIncludeParams = urlIncludeParams;\n    }\n\n    public BeanConfig getUrlRenderer() {\n        return urlRenderer;\n    }\n\n    public void setUrlRenderer(BeanConfig urlRenderer) {\n        this.urlRenderer = urlRenderer;\n    }\n\n    public void setUrlRenderer(Class<?> clazz) {\n        this.urlRenderer = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getObjectFactory() {\n        return objectFactory;\n    }\n\n    public void setObjectFactory(BeanConfig objectFactory) {\n        this.objectFactory = objectFactory;\n    }\n\n    public void setObjectFactory(Class<?> clazz) {\n        this.objectFactory = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getObjectFactoryActionFactory() {\n        return objectFactoryActionFactory;\n    }\n\n    public void setObjectFactoryActionFactory(BeanConfig objectFactoryActionFactory) {\n        this.objectFactoryActionFactory = objectFactoryActionFactory;\n    }\n\n    public void setObjectFactoryActionFactory(Class<?> clazz) {\n        this.objectFactoryActionFactory = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getObjectFactoryResultFactory() {\n        return objectFactoryResultFactory;\n    }\n\n    public void setObjectFactoryResultFactory(BeanConfig objectFactoryResultFactory) {\n        this.objectFactoryResultFactory = objectFactoryResultFactory;\n    }\n\n    public void setObjectFactoryResultFactory(Class<?> clazz) {\n        this.objectFactoryResultFactory = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getObjectFactoryConverterFactory() {\n        return objectFactoryConverterFactory;\n    }\n\n    public void setObjectFactoryConverterFactory(BeanConfig objectFactoryConverterFactory) {\n        this.objectFactoryConverterFactory = objectFactoryConverterFactory;\n    }\n\n    public void setObjectFactoryConverterFactory(Class<?> clazz) {\n        this.objectFactoryConverterFactory = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getObjectFactoryInterceptorFactory() {\n        return objectFactoryInterceptorFactory;\n    }\n\n    public void setObjectFactoryInterceptorFactory(BeanConfig objectFactoryInterceptorFactory) {\n        this.objectFactoryInterceptorFactory = objectFactoryInterceptorFactory;\n    }\n\n    public void setObjectFactoryInterceptorFactory(Class<?> clazz) {\n        this.objectFactoryInterceptorFactory = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getObjectFactoryValidatorFactory() {\n        return objectFactoryValidatorFactory;\n    }\n\n    public void setObjectFactoryValidatorFactory(BeanConfig objectFactoryValidatorFactory) {\n        this.objectFactoryValidatorFactory = objectFactoryValidatorFactory;\n    }\n\n    public void setObjectFactoryValidatorFactory(Class<?> clazz) {\n        this.objectFactoryValidatorFactory = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getObjectFactoryUnknownHandlerFactory() {\n        return objectFactoryUnknownHandlerFactory;\n    }\n\n    public void setObjectFactoryUnknownHandlerFactory(BeanConfig objectFactoryUnknownHandlerFactory) {\n        this.objectFactoryUnknownHandlerFactory = objectFactoryUnknownHandlerFactory;\n    }\n\n    public void setObjectFactoryUnknownHandlerFactory(Class<?> clazz) {\n        this.objectFactoryUnknownHandlerFactory = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getObjectTypeDeterminer() {\n        return objectTypeDeterminer;\n    }\n\n    public void setObjectTypeDeterminer(BeanConfig objectTypeDeterminer) {\n        this.objectTypeDeterminer = objectTypeDeterminer;\n    }\n\n    public void setObjectTypeDeterminer(Class<?> clazz) {\n        this.objectTypeDeterminer = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public Locale getLocale() {\n        return locale;\n    }\n\n    public void setLocale(Locale locale) {\n        this.locale = locale;\n    }\n\n    public Boolean getDispatcherParametersWorkaround() {\n        return dispatcherParametersWorkaround;\n    }\n\n    public void setDispatcherParametersWorkaround(Boolean dispatcherParametersWorkaround) {\n        this.dispatcherParametersWorkaround = dispatcherParametersWorkaround;\n    }\n\n    public BeanConfig getFreemarkerManagerClassname() {\n        return freemarkerManagerClassname;\n    }\n\n    public void setFreemarkerManagerClassname(BeanConfig freemarkerManagerClassname) {\n        this.freemarkerManagerClassname = freemarkerManagerClassname;\n    }\n\n    public void setFreemarkerManagerClassname(Class<?> clazz) {\n        this.freemarkerManagerClassname = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public String getFreemarkerTemplatesCacheUpdateDelay() {\n        return freemarkerTemplatesCacheUpdateDelay;\n    }\n\n    public void setFreemarkerTemplatesCacheUpdateDelay(String freemarkerTemplatesCacheUpdateDelay) {\n        this.freemarkerTemplatesCacheUpdateDelay = freemarkerTemplatesCacheUpdateDelay;\n    }\n\n    public Boolean getFreemarkerBeanwrapperCache() {\n        return freemarkerBeanwrapperCache;\n    }\n\n    public void setFreemarkerBeanwrapperCache(Boolean freemarkerBeanwrapperCache) {\n        this.freemarkerBeanwrapperCache = freemarkerBeanwrapperCache;\n    }\n\n    public Integer getFreemarkerMruMaxStrongSize() {\n        return freemarkerMruMaxStrongSize;\n    }\n\n    public void setFreemarkerMruMaxStrongSize(Integer freemarkerMruMaxStrongSize) {\n        this.freemarkerMruMaxStrongSize = freemarkerMruMaxStrongSize;\n    }\n\n    public BeanConfig getVelocityManagerClassname() {\n        return velocityManagerClassname;\n    }\n\n    public void setVelocityManagerClassname(BeanConfig velocityManagerClassname) {\n        this.velocityManagerClassname = velocityManagerClassname;\n    }\n\n    public void setVelocityManagerClassname(Class<?> clazz) {\n        this.velocityManagerClassname = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public String getVelocityConfigfile() {\n        return velocityConfigfile;\n    }\n\n    public void setVelocityConfigfile(String velocityConfigfile) {\n        this.velocityConfigfile = velocityConfigfile;\n    }\n\n    public String getVelocityToolboxlocation() {\n        return velocityToolboxlocation;\n    }\n\n    public void setVelocityToolboxlocation(String velocityToolboxlocation) {\n        this.velocityToolboxlocation = velocityToolboxlocation;\n    }\n\n    public List<String> getVelocityContexts() {\n        return velocityContexts;\n    }\n\n    public void setVelocityContexts(List<String> velocityContexts) {\n        this.velocityContexts = velocityContexts;\n    }\n\n    public String getUiTemplateDir() {\n        return uiTemplateDir;\n    }\n\n    public void setUiTemplateDir(String uiTemplateDir) {\n        this.uiTemplateDir = uiTemplateDir;\n    }\n\n    public String getUiTheme() {\n        return uiTheme;\n    }\n\n    public void setUiTheme(String uiTheme) {\n        this.uiTheme = uiTheme;\n    }\n\n    public String getUiThemeExpansionToken() {\n        return uiThemeExpansionToken;\n    }\n\n    public void setUiThemeExpansionToken(String uiThemeExpansionToken) {\n        this.uiThemeExpansionToken = uiThemeExpansionToken;\n    }\n\n    public Long getMultipartMaxSize() {\n        return multipartMaxSize;\n    }\n\n    public void setMultipartMaxSize(Long multipartMaxSize) {\n        this.multipartMaxSize = multipartMaxSize;\n    }\n\n    public Long getMultipartMaxFiles() {\n        return multipartMaxFiles;\n    }\n\n    public void setMultipartMaxFiles(Long multipartMaxFiles) {\n        this.multipartMaxFiles = multipartMaxFiles;\n    }\n\n    public Long getMultipartMaxFileSize() {\n        return multipartMaxFileSize;\n    }\n\n    public void setMultipartMaxFileSize(Long multipartMaxFileSize) {\n        this.multipartMaxFileSize = multipartMaxFileSize;\n    }\n\n    public Long getMultipartMaxStringLength() {\n        return multipartMaxStringLength;\n    }\n\n    public void setMultipartMaxStringLength(Long multipartMaxStringLength) {\n        this.multipartMaxStringLength = multipartMaxStringLength;\n    }\n\n    public String getMultipartSaveDir() {\n        return multipartSaveDir;\n    }\n\n    public void setMultipartSaveDir(String multipartSaveDir) {\n        this.multipartSaveDir = multipartSaveDir;\n    }\n\n    public Integer getMultipartBufferSize() {\n        return multipartBufferSize;\n    }\n\n    public void setMultipartBufferSize(Integer multipartBufferSize) {\n        this.multipartBufferSize = multipartBufferSize;\n    }\n\n    public BeanConfig getMultipartParser() {\n        return multipartParser;\n    }\n\n    public void setMultipartParser(BeanConfig multipartParser) {\n        this.multipartParser = multipartParser;\n    }\n\n    public void setMultipartParser(Class<?> clazz) {\n        this.multipartParser = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public Boolean getMultipartEnabled() {\n        return multipartEnabled;\n    }\n\n    public void setMultipartEnabled(Boolean multipartEnabled) {\n        this.multipartEnabled = multipartEnabled;\n    }\n\n    public Pattern getMultipartValidationRegex() {\n        return multipartValidationRegex;\n    }\n\n    public void setMultipartValidationRegex(Pattern multipartValidationRegex) {\n        this.multipartValidationRegex = multipartValidationRegex;\n    }\n\n    public String getObjectFactorySpringAutoWire() {\n        return objectFactorySpringAutoWire;\n    }\n\n    public void setObjectFactorySpringAutoWire(String objectFactorySpringAutoWire) {\n        this.objectFactorySpringAutoWire = objectFactorySpringAutoWire;\n    }\n\n    public Boolean getObjectFactorySpringAutoWireAlwaysRespect() {\n        return objectFactorySpringAutoWireAlwaysRespect;\n    }\n\n    public void setObjectFactorySpringAutoWireAlwaysRespect(Boolean objectFactorySpringAutoWireAlwaysRespect) {\n        this.objectFactorySpringAutoWireAlwaysRespect = objectFactorySpringAutoWireAlwaysRespect;\n    }\n\n    public Boolean getObjectFactorySpringUseClassCache() {\n        return objectFactorySpringUseClassCache;\n    }\n\n    public void setObjectFactorySpringUseClassCache(Boolean objectFactorySpringUseClassCache) {\n        this.objectFactorySpringUseClassCache = objectFactorySpringUseClassCache;\n    }\n\n    public Boolean getObjectFactorySpringEnableAopSupport() {\n        return objectFactorySpringEnableAopSupport;\n    }\n\n    public void setObjectFactorySpringEnableAopSupport(Boolean objectFactorySpringEnableAopSupport) {\n        this.objectFactorySpringEnableAopSupport = objectFactorySpringEnableAopSupport;\n    }\n\n    public Boolean getXsltNocache() {\n        return xsltNocache;\n    }\n\n    public void setXsltNocache(Boolean xsltNocache) {\n        this.xsltNocache = xsltNocache;\n    }\n\n    public List<String> getCustomProperties() {\n        return customProperties;\n    }\n\n    public void setCustomProperties(List<String> customProperties) {\n        this.customProperties = customProperties;\n    }\n\n    public List<String> getCustomI18nResources() {\n        return customI18nResources;\n    }\n\n    public void setCustomI18nResources(List<String> customI18nResources) {\n        this.customI18nResources = customI18nResources;\n    }\n\n    public BeanConfig getMapperClass() {\n        return mapperClass;\n    }\n\n    public void setMapperClass(BeanConfig mapperClass) {\n        this.mapperClass = mapperClass;\n    }\n\n    public void setMapperClass(Class<?> clazz) {\n        this.mapperClass = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public List<String> getMapperPrefixMapping() {\n        return mapperPrefixMapping;\n    }\n\n    public void setMapperPrefixMapping(List<String> mapperPrefixMapping) {\n        this.mapperPrefixMapping = mapperPrefixMapping;\n    }\n\n    public Boolean getServeStatic() {\n        return serveStatic;\n    }\n\n    public void setServeStatic(Boolean serveStatic) {\n        this.serveStatic = serveStatic;\n    }\n\n    public Boolean getServeStaticBrowserCache() {\n        return serveStaticBrowserCache;\n    }\n\n    public void setServeStaticBrowserCache(Boolean serveStaticBrowserCache) {\n        this.serveStaticBrowserCache = serveStaticBrowserCache;\n    }\n\n    public Boolean getEnableDynamicMethodInvocation() {\n        return enableDynamicMethodInvocation;\n    }\n\n    public void setEnableDynamicMethodInvocation(Boolean enableDynamicMethodInvocation) {\n        this.enableDynamicMethodInvocation = enableDynamicMethodInvocation;\n    }\n\n    public Boolean getEnableSlashesInActionNames() {\n        return enableSlashesInActionNames;\n    }\n\n    public void setEnableSlashesInActionNames(Boolean enableSlashesInActionNames) {\n        this.enableSlashesInActionNames = enableSlashesInActionNames;\n    }\n\n    public List<String> getMapperComposite() {\n        return mapperComposite;\n    }\n\n    public void setMapperComposite(List<String> mapperComposite) {\n        this.mapperComposite = mapperComposite;\n    }\n\n    public BeanConfig getActionProxyFactory() {\n        return actionProxyFactory;\n    }\n\n    public void setActionProxyFactory(BeanConfig actionProxyFactory) {\n        this.actionProxyFactory = actionProxyFactory;\n    }\n\n    public void setActionProxyFactory(Class<?> clazz) {\n        this.actionProxyFactory = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public Boolean getFreemarkerWrapperAltMap() {\n        return freemarkerWrapperAltMap;\n    }\n\n    public void setFreemarkerWrapperAltMap(Boolean freemarkerWrapperAltMap) {\n        this.freemarkerWrapperAltMap = freemarkerWrapperAltMap;\n    }\n\n    public BeanConfig getXworkConverter() {\n        return xworkConverter;\n    }\n\n    public void setXworkConverter(BeanConfig xworkConverter) {\n        this.xworkConverter = xworkConverter;\n    }\n\n    public void setXworkConverter(Class<?> clazz) {\n        this.xworkConverter = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public Boolean getMapperAlwaysSelectFullNamespace() {\n        return mapperAlwaysSelectFullNamespace;\n    }\n\n    public void setMapperAlwaysSelectFullNamespace(Boolean mapperAlwaysSelectFullNamespace) {\n        this.mapperAlwaysSelectFullNamespace = mapperAlwaysSelectFullNamespace;\n    }\n\n    public BeanConfig getLocaleProviderFactory() {\n        return localeProviderFactory;\n    }\n\n    public void setLocaleProviderFactory(BeanConfig localeProviderFactory) {\n        this.localeProviderFactory = localeProviderFactory;\n    }\n\n    public void setLocaleProviderFactory(Class<?> clazz) {\n        this.localeProviderFactory = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public String getMapperIdParameterName() {\n        return mapperIdParameterName;\n    }\n\n    public void setMapperIdParameterName(String mapperIdParameterName) {\n        this.mapperIdParameterName = mapperIdParameterName;\n    }\n\n    public Boolean getOgnlAllowStaticFieldAccess() {\n        return ognlAllowStaticFieldAccess;\n    }\n\n    public void setOgnlAllowStaticFieldAccess(Boolean ognlAllowStaticFieldAccess) {\n        this.ognlAllowStaticFieldAccess = ognlAllowStaticFieldAccess;\n    }\n\n    public BeanConfig getActionValidatorManager() {\n        return actionValidatorManager;\n    }\n\n    public void setActionValidatorManager(BeanConfig actionValidatorManager) {\n        this.actionValidatorManager = actionValidatorManager;\n    }\n\n    public void setActionValidatorManager(Class<?> clazz) {\n        this.actionValidatorManager = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getValueStackFactory() {\n        return valueStackFactory;\n    }\n\n    public void setValueStackFactory(BeanConfig valueStackFactory) {\n        this.valueStackFactory = valueStackFactory;\n    }\n\n    public void setValueStackFactory(Class<?> clazz) {\n        this.valueStackFactory = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getReflectionProvider() {\n        return reflectionProvider;\n    }\n\n    public void setReflectionProvider(BeanConfig reflectionProvider) {\n        this.reflectionProvider = reflectionProvider;\n    }\n\n    public void setReflectionProvider(Class<?> clazz) {\n        this.reflectionProvider = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getReflectionContextFactory() {\n        return reflectionContextFactory;\n    }\n\n    public void setReflectionContextFactory(BeanConfig reflectionContextFactory) {\n        this.reflectionContextFactory = reflectionContextFactory;\n    }\n\n    public void setReflectionContextFactory(Class<?> clazz) {\n        this.reflectionContextFactory = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getPatternMatcher() {\n        return patternMatcher;\n    }\n\n    public void setPatternMatcher(BeanConfig patternMatcher) {\n        this.patternMatcher = patternMatcher;\n    }\n\n    public void setPatternMatcher(Class<?> clazz) {\n        this.patternMatcher = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getStaticContentLoader() {\n        return staticContentLoader;\n    }\n\n    public void setStaticContentLoader(BeanConfig staticContentLoader) {\n        this.staticContentLoader = staticContentLoader;\n    }\n\n    public void setStaticContentLoader(Class<?> clazz) {\n        this.staticContentLoader = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getUnknownHandlerManager() {\n        return unknownHandlerManager;\n    }\n\n    public void setUnknownHandlerManager(BeanConfig unknownHandlerManager) {\n        this.unknownHandlerManager = unknownHandlerManager;\n    }\n\n    public void setUnknownHandlerManager(Class<?> clazz) {\n        this.unknownHandlerManager = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public Boolean getElThrowExceptionOnFailure() {\n        return elThrowExceptionOnFailure;\n    }\n\n    public void setElThrowExceptionOnFailure(Boolean elThrowExceptionOnFailure) {\n        this.elThrowExceptionOnFailure = elThrowExceptionOnFailure;\n    }\n\n    public Boolean getOgnlLogMissingProperties() {\n        return ognlLogMissingProperties;\n    }\n\n    public void setOgnlLogMissingProperties(Boolean ognlLogMissingProperties) {\n        this.ognlLogMissingProperties = ognlLogMissingProperties;\n    }\n\n    public Boolean getOgnlEnableExpressionCache() {\n        return ognlEnableExpressionCache;\n    }\n\n    public void setOgnlEnableExpressionCache(Boolean ognlEnableExpressionCache) {\n        this.ognlEnableExpressionCache = ognlEnableExpressionCache;\n    }\n\n    public Boolean getOgnlEnableEvalExpression() {\n        return ognlEnableEvalExpression;\n    }\n\n    public void setOgnlEnableEvalExpression(Boolean ognlEnableEvalExpression) {\n        this.ognlEnableEvalExpression = ognlEnableEvalExpression;\n    }\n\n    public Boolean getDisableRequestAttributeValueStackLookup() {\n        return disableRequestAttributeValueStackLookup;\n    }\n\n    public void setDisableRequestAttributeValueStackLookup(Boolean disableRequestAttributeValueStackLookup) {\n        this.disableRequestAttributeValueStackLookup = disableRequestAttributeValueStackLookup;\n    }\n\n    public BeanConfig getViewUrlHelper() {\n        return viewUrlHelper;\n    }\n\n    public void setViewUrlHelper(BeanConfig viewUrlHelper) {\n        this.viewUrlHelper = viewUrlHelper;\n    }\n\n    public void setViewUrlHelper(Class<?> clazz) {\n        this.viewUrlHelper = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getConverterCollection() {\n        return converterCollection;\n    }\n\n    public void setConverterCollection(BeanConfig converterCollection) {\n        this.converterCollection = converterCollection;\n    }\n\n    public void setConverterCollection(Class<?> clazz) {\n        this.converterCollection = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getConverterArray() {\n        return converterArray;\n    }\n\n    public void setConverterArray(BeanConfig converterArray) {\n        this.converterArray = converterArray;\n    }\n\n    public void setConverterArray(Class<?> clazz) {\n        this.converterArray = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getConverterDate() {\n        return converterDate;\n    }\n\n    public void setConverterDate(BeanConfig converterDate) {\n        this.converterDate = converterDate;\n    }\n\n    public void setConverterDate(Class<?> clazz) {\n        this.converterDate = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getConverterNumber() {\n        return converterNumber;\n    }\n\n    public void setConverterNumber(BeanConfig converterNumber) {\n        this.converterNumber = converterNumber;\n    }\n\n    public void setConverterNumber(Class<?> clazz) {\n        this.converterNumber = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getConverterString() {\n        return converterString;\n    }\n\n    public void setConverterString(BeanConfig converterString) {\n        this.converterString = converterString;\n    }\n\n    public void setConverterString(Class<?> clazz) {\n        this.converterString = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public Boolean getHandleException() {\n        return handleException;\n    }\n\n    public void setHandleException(Boolean handleException) {\n        this.handleException = handleException;\n    }\n\n    public BeanConfig getConverterPropertiesProcessor() {\n        return converterPropertiesProcessor;\n    }\n\n    public void setConverterPropertiesProcessor(BeanConfig converterPropertiesProcessor) {\n        this.converterPropertiesProcessor = converterPropertiesProcessor;\n    }\n\n    public void setConverterPropertiesProcessor(Class<?> clazz) {\n        this.converterPropertiesProcessor = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getConverterFileProcessor() {\n        return converterFileProcessor;\n    }\n\n    public void setConverterFileProcessor(BeanConfig converterFileProcessor) {\n        this.converterFileProcessor = converterFileProcessor;\n    }\n\n    public void setConverterFileProcessor(Class<?> clazz) {\n        this.converterFileProcessor = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getConverterAnnotationProcessor() {\n        return converterAnnotationProcessor;\n    }\n\n    public void setConverterAnnotationProcessor(BeanConfig converterAnnotationProcessor) {\n        this.converterAnnotationProcessor = converterAnnotationProcessor;\n    }\n\n    public void setConverterAnnotationProcessor(Class<?> clazz) {\n        this.converterAnnotationProcessor = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getConverterCreator() {\n        return converterCreator;\n    }\n\n    public void setConverterCreator(BeanConfig converterCreator) {\n        this.converterCreator = converterCreator;\n    }\n\n    public void setConverterCreator(Class<?> clazz) {\n        this.converterCreator = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getConverterHolder() {\n        return ConverterHolder;\n    }\n\n    public void setConverterHolder(BeanConfig ConverterHolder) {\n        this.ConverterHolder = ConverterHolder;\n    }\n\n    public void setConverterHolder(Class<?> clazz) {\n        this.ConverterHolder = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getExpressionParser() {\n        return expressionParser;\n    }\n\n    public void setExpressionParser(BeanConfig expressionParser) {\n        this.expressionParser = expressionParser;\n    }\n\n    public void setExpressionParser(Class<?> clazz) {\n        this.expressionParser = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public Pattern getAllowedActionNames() {\n        return allowedActionNames;\n    }\n\n    public void setAllowedActionNames(Pattern allowedActionNames) {\n        this.allowedActionNames = allowedActionNames;\n    }\n\n    public String getDefaultActionName() {\n        return defaultActionName;\n    }\n\n    public void setDefaultActionName(String defaultActionName) {\n        this.defaultActionName = defaultActionName;\n    }\n\n    public Pattern getAllowedMethodNames() {\n        return allowedMethodNames;\n    }\n\n    public void setAllowedMethodNames(Pattern allowedMethodNames) {\n        this.allowedMethodNames = allowedMethodNames;\n    }\n\n    public String getDefaultMethodName() {\n        return defaultMethodName;\n    }\n\n    public void setDefaultMethodName(String defaultMethodName) {\n        this.defaultMethodName = defaultMethodName;\n    }\n\n    public Boolean getMapperActionPrefixEnabled() {\n        return mapperActionPrefixEnabled;\n    }\n\n    public void setMapperActionPrefixEnabled(Boolean mapperActionPrefixEnabled) {\n        this.mapperActionPrefixEnabled = mapperActionPrefixEnabled;\n    }\n\n    public Boolean getMapperActionPrefixCrossNamespaces() {\n        return mapperActionPrefixCrossNamespaces;\n    }\n\n    public void setMapperActionPrefixCrossNamespaces(Boolean mapperActionPrefixCrossNamespaces) {\n        this.mapperActionPrefixCrossNamespaces = mapperActionPrefixCrossNamespaces;\n    }\n\n    public String getUiTemplateSuffix() {\n        return uiTemplateSuffix;\n    }\n\n    public void setUiTemplateSuffix(String uiTemplateSuffix) {\n        this.uiTemplateSuffix = uiTemplateSuffix;\n    }\n\n    public BeanConfig getDispatcherErrorHandler() {\n        return dispatcherErrorHandler;\n    }\n\n    public void setDispatcherErrorHandler(BeanConfig dispatcherErrorHandler) {\n        this.dispatcherErrorHandler = dispatcherErrorHandler;\n    }\n\n    public void setDispatcherErrorHandler(Class<?> clazz) {\n        this.dispatcherErrorHandler = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public Set<Class<?>> getExcludedClasses() {\n        return excludedClasses;\n    }\n\n    public void setExcludedClasses(Set<Class<?>> excludedClasses) {\n        this.excludedClasses = excludedClasses;\n    }\n\n    public List<Pattern> getExcludedPackageNamePatterns() {\n        return excludedPackageNamePatterns;\n    }\n\n    public void setExcludedPackageNamePatterns(List<Pattern> excludedPackageNamePatterns) {\n        this.excludedPackageNamePatterns = excludedPackageNamePatterns;\n    }\n\n    public Set<String> getExcludedPackageNames() {\n        return excludedPackageNames;\n    }\n\n    public void setExcludedPackageNames(Set<String> excludedPackageNames) {\n        this.excludedPackageNames = excludedPackageNames;\n    }\n\n    public Set<Class<?>> getExcludedPackageExemptClasses() {\n        return excludedPackageExemptClasses;\n    }\n\n    public void setExcludedPackageExemptClasses(Set<Class<?>> excludedPackageExemptClasses) {\n        this.excludedPackageExemptClasses = excludedPackageExemptClasses;\n    }\n\n    public Set<Class<?>> getDevModeExcludedClasses() {\n        return devModeExcludedClasses;\n    }\n\n    public void setDevModeExcludedClasses(Set<Class<?>> devModeExcludedClasses) {\n        this.devModeExcludedClasses = devModeExcludedClasses;\n    }\n\n    public List<Pattern> getDevModeExcludedPackageNamePatterns() {\n        return devModeExcludedPackageNamePatterns;\n    }\n\n    public void setDevModeExcludedPackageNamePatterns(List<Pattern> devModeExcludedPackageNamePatterns) {\n        this.devModeExcludedPackageNamePatterns = devModeExcludedPackageNamePatterns;\n    }\n\n    public Set<String> getDevModeExcludedPackageNames() {\n        return devModeExcludedPackageNames;\n    }\n\n    public void setDevModeExcludedPackageNames(Set<String> devModeExcludedPackageNames) {\n        this.devModeExcludedPackageNames = devModeExcludedPackageNames;\n    }\n\n    public Set<Class<?>> getDevModeExcludedPackageExemptClasses() {\n        return devModeExcludedPackageExemptClasses;\n    }\n\n    public void setDevModeExcludedPackageExemptClasses(Set<Class<?>> devModeExcludedPackageExemptClasses) {\n        this.devModeExcludedPackageExemptClasses = devModeExcludedPackageExemptClasses;\n    }\n\n    public BeanConfig getExcludedPatternsChecker() {\n        return excludedPatternsChecker;\n    }\n\n    public void setExcludedPatternsChecker(BeanConfig excludedPatternsChecker) {\n        this.excludedPatternsChecker = excludedPatternsChecker;\n    }\n\n    public void setExcludedPatternsChecker(Class<?> clazz) {\n        this.excludedPatternsChecker = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getAcceptedPatternsChecker() {\n        return acceptedPatternsChecker;\n    }\n\n    public void setAcceptedPatternsChecker(BeanConfig acceptedPatternsChecker) {\n        this.acceptedPatternsChecker = acceptedPatternsChecker;\n    }\n\n    public void setAcceptedPatternsChecker(Class<?> clazz) {\n        this.acceptedPatternsChecker = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getNotExcludedAcceptedPatternsChecker() {\n        return notExcludedAcceptedPatternsChecker;\n    }\n\n    public void setNotExcludedAcceptedPatternsChecker(BeanConfig notExcludedAcceptedPatternsChecker) {\n        this.notExcludedAcceptedPatternsChecker = notExcludedAcceptedPatternsChecker;\n    }\n\n    public void setNotExcludedAcceptedPatternsChecker(Class<?> clazz) {\n        this.notExcludedAcceptedPatternsChecker = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public Set<Pattern> getOverrideExcludedPatterns() {\n        return overrideExcludedPatterns;\n    }\n\n    public void setOverrideExcludedPatterns(Set<Pattern> overrideExcludedPatterns) {\n        this.overrideExcludedPatterns = overrideExcludedPatterns;\n    }\n\n    public Set<Pattern> getOverrideAcceptedPatterns() {\n        return overrideAcceptedPatterns;\n    }\n\n    public void setOverrideAcceptedPatterns(Set<Pattern> overrideAcceptedPatterns) {\n        this.overrideAcceptedPatterns = overrideAcceptedPatterns;\n    }\n\n    public Set<Pattern> getAdditionalExcludedPatterns() {\n        return additionalExcludedPatterns;\n    }\n\n    public void setAdditionalExcludedPatterns(Set<Pattern> additionalExcludedPatterns) {\n        this.additionalExcludedPatterns = additionalExcludedPatterns;\n    }\n\n    public Set<Pattern> getAdditionalAcceptedPatterns() {\n        return additionalAcceptedPatterns;\n    }\n\n    public void setAdditionalAcceptedPatterns(Set<Pattern> additionalAcceptedPatterns) {\n        this.additionalAcceptedPatterns = additionalAcceptedPatterns;\n    }\n\n    public BeanConfig getContentTypeMatcher() {\n        return contentTypeMatcher;\n    }\n\n    public void setContentTypeMatcher(BeanConfig contentTypeMatcher) {\n        this.contentTypeMatcher = contentTypeMatcher;\n    }\n\n    public void setContentTypeMatcher(Class<?> clazz) {\n        this.contentTypeMatcher = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public String getStrictMethodInvocationMethodRegex() {\n        return strictMethodInvocationMethodRegex;\n    }\n\n    public void setStrictMethodInvocationMethodRegex(String strictMethodInvocationMethodRegex) {\n        this.strictMethodInvocationMethodRegex = strictMethodInvocationMethodRegex;\n    }\n\n    public BeanConfig getTextProviderFactory() {\n        return textProviderFactory;\n    }\n\n    public void setTextProviderFactory(BeanConfig textProviderFactory) {\n        this.textProviderFactory = textProviderFactory;\n    }\n\n    public void setTextProviderFactory(Class<?> clazz) {\n        this.textProviderFactory = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getLocalizedTextProvider() {\n        return localizedTextProvider;\n    }\n\n    public void setLocalizedTextProvider(BeanConfig localizedTextProvider) {\n        this.localizedTextProvider = localizedTextProvider;\n    }\n\n    public void setLocalizedTextProvider(Class<?> clazz) {\n        this.localizedTextProvider = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public Boolean getDisallowProxyMemberAccess() {\n        return disallowProxyMemberAccess;\n    }\n\n    public void setDisallowProxyMemberAccess(Boolean disallowProxyMemberAccess) {\n        this.disallowProxyMemberAccess = disallowProxyMemberAccess;\n    }\n\n    public Integer getOgnlAutoGrowthCollectionLimit() {\n        return ognlAutoGrowthCollectionLimit;\n    }\n\n    public void setOgnlAutoGrowthCollectionLimit(Integer ognlAutoGrowthCollectionLimit) {\n        this.ognlAutoGrowthCollectionLimit = ognlAutoGrowthCollectionLimit;\n    }\n\n    public String getStaticContentPath() {\n        return staticContentPath;\n    }\n\n    public void setStaticContentPath(String staticContentPath) {\n        this.staticContentPath = StaticContentLoader.Validator.validateStaticContentPath(staticContentPath);\n    }\n\n    public BeanConfig getExpressionCacheFactory() {\n        return expressionCacheFactory;\n    }\n\n    public void setExpressionCacheFactory(BeanConfig expressionCacheFactory) {\n        this.expressionCacheFactory = expressionCacheFactory;\n    }\n\n    public void setExpressionCacheFactory(Class<?> clazz) {\n        this.expressionCacheFactory = new BeanConfig(clazz, clazz.getName());\n    }\n\n    public BeanConfig getBeaninfoCacheFactory() {\n        return beaninfoCacheFactory;\n    }\n\n    public void setBeaninfoCacheFactory(BeanConfig beaninfoCacheFactory) {\n        this.beaninfoCacheFactory = beaninfoCacheFactory;\n    }\n\n    public void setBeaninfoCacheFactory(Class<?> clazz) {\n        this.beaninfoCacheFactory = new BeanConfig(clazz, clazz.getName());\n    }\n}\n"}
{"test_method": "@Test\n    public void findAnnotationMultipleActionNameGiven() {\n        StrutsTilesAnnotationProcessor annotationProcessor = new StrutsTilesAnnotationProcessor();\n        TilesDefinition tilesDefinition = annotationProcessor.findAnnotation(new TilesTestActionMultipleAnnotations(), \"def2\");\n        Assert.assertNotNull(tilesDefinition);\n        Assert.assertEquals(\"def2\", tilesDefinition.name());\n    }", "focal_method": "public TilesDefinition findAnnotation(Object action, String tileName) {\n        Class<?> clazz = action.getClass();\n        TilesDefinition tilesDefinition = clazz.getAnnotation(TilesDefinition.class);\n        TilesDefinitions tilesDefinitions = clazz.getAnnotation(TilesDefinitions.class);\n\n        if (tilesDefinition == null && tilesDefinitions != null) {\n            if (!StringUtils.isEmpty(tileName)) {\n                for (TilesDefinition i : tilesDefinitions.value()) {\n                    if (i.name().equals(tileName)) {\n                        tilesDefinition = i;\n                        break;\n                    }\n                }\n            } else {\n                if (tilesDefinitions.value().length > 0) {\n                    tilesDefinition = tilesDefinitions.value()[0];\n                }\n            }\n        }\n\n        return tilesDefinition;\n    }", "test_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.tiles;\n\nimport java.util.List;\nimport java.util.Set;\n\nimport org.apache.struts2.tiles.annotation.TilesDefinition;\nimport org.apache.tiles.api.Attribute;\nimport org.apache.tiles.api.Definition;\nimport org.apache.tiles.api.Expression;\nimport org.junit.Test;\n\nimport org.junit.Assert;\n\npublic class StrutsTilesAnnotationProcessorTest {\n\n    @Test\n    public void findAnnotationSingleAction() {\n        StrutsTilesAnnotationProcessor annotationProcessor = new StrutsTilesAnnotationProcessor();\n        TilesDefinition tilesDefinition = annotationProcessor.findAnnotation(new TilesTestActionSingleAnnotation(), null);\n        Assert.assertNotNull(tilesDefinition);\n        Assert.assertEquals(\"definition-name\", tilesDefinition.name());\n    }\n\n    @Test\n    public void findAnnotationMultipleActionNameNull() {\n        StrutsTilesAnnotationProcessor annotationProcessor = new StrutsTilesAnnotationProcessor();\n        TilesDefinition tilesDefinition = annotationProcessor.findAnnotation(new TilesTestActionMultipleAnnotations(), null);\n        Assert.assertNotNull(tilesDefinition);\n        Assert.assertEquals(\"def1\", tilesDefinition.name());\n    }\n\n    @Test\n    public void findAnnotationMultipleActionNameGiven() {\n        StrutsTilesAnnotationProcessor annotationProcessor = new StrutsTilesAnnotationProcessor();\n        TilesDefinition tilesDefinition = annotationProcessor.findAnnotation(new TilesTestActionMultipleAnnotations(), \"def2\");\n        Assert.assertNotNull(tilesDefinition);\n        Assert.assertEquals(\"def2\", tilesDefinition.name());\n    }\n\n    @Test\n    public void findAnnotationMultipleActionNotFound() {\n        StrutsTilesAnnotationProcessor annotationProcessor = new StrutsTilesAnnotationProcessor();\n        TilesDefinition tilesDefinition = annotationProcessor.findAnnotation(new TilesTestActionMultipleAnnotations(), \"def3\");\n        Assert.assertNull(tilesDefinition);\n    }\n\n    @Test\n    public void buildDefiniton() {\n        StrutsTilesAnnotationProcessor annotationProcessor = new StrutsTilesAnnotationProcessor();\n        TilesDefinition tilesDefinition = annotationProcessor.findAnnotation(new TilesTestActionSingleAnnotation(), null);\n\n        Definition definition = annotationProcessor.buildTilesDefinition(\"tileName\", tilesDefinition);\n\n        Assert.assertNotNull(definition);\n        Assert.assertEquals(\"tileName\", definition.getName());\n        Assert.assertEquals(\"preparer\", definition.getPreparer());\n        Assert.assertEquals(\"base-definition\", definition.getExtends());\n        Attribute templateAttribute = definition.getTemplateAttribute();\n        Assert.assertEquals(\"template\", templateAttribute.getValue());\n        Assert.assertEquals(\"type\", templateAttribute.getRenderer());\n        Assert.assertEquals(\"role\", templateAttribute.getRole());\n        Expression definitionExpressionObject = templateAttribute.getExpressionObject();\n        Assert.assertEquals(\"templ*\", definitionExpressionObject.getExpression());\n        Assert.assertNull(definitionExpressionObject.getLanguage());\n\n        Attribute putAttribute = definition.getAttribute(\"put-attr\");\n        Assert.assertNotNull(putAttribute);\n        Assert.assertEquals(\"attr-val\", putAttribute.getValue());\n        Assert.assertEquals(\"attr-type\", putAttribute.getRenderer());\n        Assert.assertEquals(\"attr-role\", putAttribute.getRole());\n        Expression putAttrExpressionObject = putAttribute.getExpressionObject();\n        Assert.assertEquals(\"expr\", putAttrExpressionObject.getExpression());\n        Assert.assertEquals(\"lang\", putAttrExpressionObject.getLanguage());\n\n        Attribute listAttribute = definition.getAttribute(\"list-name\");\n        Assert.assertEquals(\"list-role\", listAttribute.getRole());\n        List<Attribute> listValue = getListValue(listAttribute);\n        Assert.assertEquals(2, listValue.size());\n\n        Attribute addAttribute = listValue.get(0);\n        Assert.assertEquals(\"list-attr-role\", addAttribute.getRole());\n        Assert.assertEquals(\"list-attr-val\", addAttribute.getValue());\n        Assert.assertEquals(\"list-attr-type\", addAttribute.getRenderer());\n        Expression addAttrExpressionObject = addAttribute.getExpressionObject();\n        Assert.assertEquals(\"list-attr-expr\", addAttrExpressionObject.getExpression());\n\n        Attribute addListAttribute = listValue.get(1);\n        Assert.assertEquals(\"list-list-attr-role\", addListAttribute.getRole());\n        List<Attribute> addListValue = getListValue(addListAttribute);\n        Assert.assertEquals(1, addListValue.size());\n        Assert.assertEquals(\"list-list-add-attr\", addListValue.get(0).getValue());\n\n        Set<String> cascadedAttributeNames = definition.getCascadedAttributeNames();\n        Assert.assertEquals(2, cascadedAttributeNames.size());\n        Assert.assertTrue(cascadedAttributeNames.contains(\"put-attr\"));\n        Assert.assertTrue(cascadedAttributeNames.contains(\"list-name\"));\n    }\n\n    @Test\n    public void buildDefinitonAllEmpty() {\n        StrutsTilesAnnotationProcessor annotationProcessor = new StrutsTilesAnnotationProcessor();\n        TilesDefinition tilesDefinition = annotationProcessor.findAnnotation(new TilesTestActionSingleAnnotationAllEmpty(), null);\n\n        Definition definition = annotationProcessor.buildTilesDefinition(null, tilesDefinition);\n\n        Assert.assertNotNull(definition);\n        Assert.assertNull(definition.getName());\n        Assert.assertNull(definition.getPreparer());\n        Assert.assertNull(definition.getExtends());\n        Attribute templateAttribute = definition.getTemplateAttribute();\n        Assert.assertNull(templateAttribute.getValue());\n        Assert.assertNull(templateAttribute.getRole());\n        Assert.assertNull(templateAttribute.getExpressionObject());\n\n        Attribute putAttribute = definition.getAttribute(\"put-attr\");\n        Assert.assertNotNull(putAttribute);\n        Assert.assertNull(putAttribute.getValue());\n        Assert.assertNull(putAttribute.getRenderer());\n        Assert.assertNull(putAttribute.getRole());\n        Assert.assertNull(putAttribute.getExpressionObject());\n\n        Attribute listAttribute = definition.getAttribute(\"list-name\");\n        Assert.assertNull(listAttribute.getRole());\n        List<Attribute> listValue = getListValue(listAttribute);\n        Assert.assertEquals(2, listValue.size());\n\n        Attribute addAttribute = listValue.get(0);\n        Assert.assertNull(addAttribute.getRole());\n        Assert.assertNull(addAttribute.getValue());\n        Assert.assertNull(addAttribute.getRenderer());\n        Assert.assertNull(addAttribute.getExpressionObject());\n\n        Attribute addListAttribute = listValue.get(1);\n        Assert.assertNull(addListAttribute.getRole());\n        List<Attribute> addListValue = getListValue(addListAttribute);\n        Assert.assertEquals(1, addListValue.size());\n        Assert.assertNull(addListValue.get(0).getValue());\n\n        Set<String> cascadedAttributeNames = definition.getCascadedAttributeNames();\n        Assert.assertNull(cascadedAttributeNames);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected List<Attribute> getListValue(Attribute listAttribute) {\n        return (List<Attribute>) listAttribute.getValue();\n    }\n}\n", "focal_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.tiles;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.struts2.tiles.annotation.TilesAddAttribute;\nimport org.apache.struts2.tiles.annotation.TilesAddListAttribute;\nimport org.apache.struts2.tiles.annotation.TilesDefinition;\nimport org.apache.struts2.tiles.annotation.TilesDefinitions;\nimport org.apache.struts2.tiles.annotation.TilesPutAttribute;\nimport org.apache.struts2.tiles.annotation.TilesPutListAttribute;\nimport org.apache.tiles.api.Attribute;\nimport org.apache.tiles.api.Definition;\nimport org.apache.tiles.api.Expression;\nimport org.apache.tiles.api.ListAttribute;\n\n/**\n * Processes tiles annotations to create {@link Definition}s and\n * {@link Attribute}s in a way as close to <code>tiles.xml</code> as possible.\n *\n */\npublic class StrutsTilesAnnotationProcessor {\n\n    /**\n     * Search strategy is as follows:\n     * <ul>\n     *   <li>Check if action has Annotation {@link TilesDefinition}</li>\n     *   <li>If not, check if action has Annotation {@link TilesDefinitions}</li>\n     *   <li>If given tileName is not null and present in {@link TilesDefinitions}, return it</li>\n     *   <li>Return first element of {@link TilesDefinitions}</li>\n     *   <li>Return null</li>\n     * </ul>\n     *\n     * @param action\n     *            Annotated action.\n     * @param tileName\n     *            Tilename to search for. May be null in some circumstances.\n     * @return {@link TilesDefinition}\n     */\n    public TilesDefinition findAnnotation(Object action, String tileName) {\n        Class<?> clazz = action.getClass();\n        TilesDefinition tilesDefinition = clazz.getAnnotation(TilesDefinition.class);\n        TilesDefinitions tilesDefinitions = clazz.getAnnotation(TilesDefinitions.class);\n\n        if (tilesDefinition == null && tilesDefinitions != null) {\n            if (!StringUtils.isEmpty(tileName)) {\n                for (TilesDefinition i : tilesDefinitions.value()) {\n                    if (i.name().equals(tileName)) {\n                        tilesDefinition = i;\n                        break;\n                    }\n                }\n            } else {\n                if (tilesDefinitions.value().length > 0) {\n                    tilesDefinition = tilesDefinitions.value()[0];\n                }\n            }\n        }\n\n        return tilesDefinition;\n    }\n\n    /**\n     * Builds a {@link Definition} based on given {@link TilesDefinition} with\n     * given name.\n     *\n     * @param tileName\n     *            name for resulting {@link Definition}.\n     * @param tilesDefinition\n     *            {@link TilesDefinition} to process.\n     * @return {@link Definition} represented by given {@link TilesDefinition}.\n     */\n    public Definition buildTilesDefinition(String tileName, TilesDefinition tilesDefinition) {\n        Definition definition = new Definition();\n\n        definition.setName(tileName);\n\n        String extend = getValueOrNull(tilesDefinition.extend());\n        if (extend != null) {\n            definition.setExtends(extend);\n        }\n        String preparer = getValueOrNull(tilesDefinition.preparer());\n        if (preparer != null) {\n            definition.setPreparer(preparer);\n        }\n        definition.setTemplateAttribute(buildTemplateAttribute(tilesDefinition));\n\n        for (TilesPutAttribute putAttribute : tilesDefinition.putAttributes()) {\n            Attribute attribute = buildPutAttribute(putAttribute);\n            definition.putAttribute(putAttribute.name(), attribute, putAttribute.cascade());\n        }\n        for (TilesPutListAttribute putListAttribute : tilesDefinition.putListAttributes()) {\n            Attribute attribute = buildPutListAttribute(putListAttribute);\n            definition.putAttribute(putListAttribute.name(), attribute, putListAttribute.cascade());\n        }\n\n        return definition;\n    }\n\n    protected Attribute buildTemplateAttribute(TilesDefinition tilesDef) {\n        // see tiles DigesterDefinitionsReader\n        Attribute attribute = Attribute.createTemplateAttribute(getValueOrNull(tilesDef.template()));\n        String templateExpression = getValueOrNull(tilesDef.templateExpression());\n        Expression expression = Expression.createExpressionFromDescribedExpression(templateExpression);\n        attribute.setExpressionObject(expression);\n        attribute.setRole(getValueOrNull(tilesDef.role()));\n        String templateType = getValueOrNull(tilesDef.templateType());\n        if (templateType != null) {\n            attribute.setRenderer(templateType);\n        } else if (getValueOrNull(tilesDef.extend()) != null) {\n            attribute.setRenderer(null);\n        }\n        return attribute;\n    }\n\n    protected Attribute buildPutAttribute(TilesPutAttribute putAttribute) {\n        Attribute attribute = new Attribute();\n        attribute.setValue(getValueOrNull(putAttribute.value()));\n        String expression = getValueOrNull(putAttribute.expression());\n        attribute.setExpressionObject(Expression.createExpressionFromDescribedExpression(expression));\n        attribute.setRole(getValueOrNull(putAttribute.role()));\n        attribute.setRenderer(getValueOrNull(putAttribute.type()));\n        return attribute;\n    }\n\n    protected Attribute buildPutListAttribute(TilesPutListAttribute putListAttribute) {\n        ListAttribute attribute = new ListAttribute();\n        attribute.setRole(getValueOrNull(putListAttribute.role()));\n        attribute.setInherit(putListAttribute.inherit());\n        for (TilesAddAttribute addAttribute : putListAttribute.addAttributes()) {\n            attribute.add(buildAddAttribute(addAttribute));\n        }\n        for (TilesAddListAttribute addListAttribute : putListAttribute.addListAttributes()) {\n            attribute.add(buildAddListAttribute(addListAttribute));\n        }\n        return attribute;\n    }\n\n    protected Attribute buildAddAttribute(TilesAddAttribute addAttribute) {\n        Attribute attribute = new Attribute();\n        attribute.setValue(getValueOrNull(addAttribute.value()));\n        String expression = getValueOrNull(addAttribute.expression());\n        attribute.setExpressionObject(Expression.createExpressionFromDescribedExpression(expression));\n        attribute.setRole(getValueOrNull(addAttribute.role()));\n        attribute.setRenderer(getValueOrNull(addAttribute.type()));\n        return attribute;\n    }\n\n    protected Attribute buildAddListAttribute(TilesAddListAttribute addListAttribute) {\n        ListAttribute attribute = new ListAttribute();\n        attribute.setRole(getValueOrNull(addListAttribute.role()));\n        for (TilesAddAttribute addAttribute : addListAttribute.addAttributes()) {\n            attribute.add(buildAddAttribute(addAttribute));\n        }\n        return attribute;\n    }\n\n    protected String getValueOrNull(String value) {\n        return value != null && value.length() > 0 ? value : null;\n    }\n}\n"}
{"test_method": "@Test\n    public void findAnnotationSingleAction() {\n        StrutsTilesAnnotationProcessor annotationProcessor = new StrutsTilesAnnotationProcessor();\n        TilesDefinition tilesDefinition = annotationProcessor.findAnnotation(new TilesTestActionSingleAnnotation(), null);\n        Assert.assertNotNull(tilesDefinition);\n        Assert.assertEquals(\"definition-name\", tilesDefinition.name());\n    }", "focal_method": "public TilesDefinition findAnnotation(Object action, String tileName) {\n        Class<?> clazz = action.getClass();\n        TilesDefinition tilesDefinition = clazz.getAnnotation(TilesDefinition.class);\n        TilesDefinitions tilesDefinitions = clazz.getAnnotation(TilesDefinitions.class);\n\n        if (tilesDefinition == null && tilesDefinitions != null) {\n            if (!StringUtils.isEmpty(tileName)) {\n                for (TilesDefinition i : tilesDefinitions.value()) {\n                    if (i.name().equals(tileName)) {\n                        tilesDefinition = i;\n                        break;\n                    }\n                }\n            } else {\n                if (tilesDefinitions.value().length > 0) {\n                    tilesDefinition = tilesDefinitions.value()[0];\n                }\n            }\n        }\n\n        return tilesDefinition;\n    }", "test_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.tiles;\n\nimport java.util.List;\nimport java.util.Set;\n\nimport org.apache.struts2.tiles.annotation.TilesDefinition;\nimport org.apache.tiles.api.Attribute;\nimport org.apache.tiles.api.Definition;\nimport org.apache.tiles.api.Expression;\nimport org.junit.Test;\n\nimport org.junit.Assert;\n\npublic class StrutsTilesAnnotationProcessorTest {\n\n    @Test\n    public void findAnnotationSingleAction() {\n        StrutsTilesAnnotationProcessor annotationProcessor = new StrutsTilesAnnotationProcessor();\n        TilesDefinition tilesDefinition = annotationProcessor.findAnnotation(new TilesTestActionSingleAnnotation(), null);\n        Assert.assertNotNull(tilesDefinition);\n        Assert.assertEquals(\"definition-name\", tilesDefinition.name());\n    }\n\n    @Test\n    public void findAnnotationMultipleActionNameNull() {\n        StrutsTilesAnnotationProcessor annotationProcessor = new StrutsTilesAnnotationProcessor();\n        TilesDefinition tilesDefinition = annotationProcessor.findAnnotation(new TilesTestActionMultipleAnnotations(), null);\n        Assert.assertNotNull(tilesDefinition);\n        Assert.assertEquals(\"def1\", tilesDefinition.name());\n    }\n\n    @Test\n    public void findAnnotationMultipleActionNameGiven() {\n        StrutsTilesAnnotationProcessor annotationProcessor = new StrutsTilesAnnotationProcessor();\n        TilesDefinition tilesDefinition = annotationProcessor.findAnnotation(new TilesTestActionMultipleAnnotations(), \"def2\");\n        Assert.assertNotNull(tilesDefinition);\n        Assert.assertEquals(\"def2\", tilesDefinition.name());\n    }\n\n    @Test\n    public void findAnnotationMultipleActionNotFound() {\n        StrutsTilesAnnotationProcessor annotationProcessor = new StrutsTilesAnnotationProcessor();\n        TilesDefinition tilesDefinition = annotationProcessor.findAnnotation(new TilesTestActionMultipleAnnotations(), \"def3\");\n        Assert.assertNull(tilesDefinition);\n    }\n\n    @Test\n    public void buildDefiniton() {\n        StrutsTilesAnnotationProcessor annotationProcessor = new StrutsTilesAnnotationProcessor();\n        TilesDefinition tilesDefinition = annotationProcessor.findAnnotation(new TilesTestActionSingleAnnotation(), null);\n\n        Definition definition = annotationProcessor.buildTilesDefinition(\"tileName\", tilesDefinition);\n\n        Assert.assertNotNull(definition);\n        Assert.assertEquals(\"tileName\", definition.getName());\n        Assert.assertEquals(\"preparer\", definition.getPreparer());\n        Assert.assertEquals(\"base-definition\", definition.getExtends());\n        Attribute templateAttribute = definition.getTemplateAttribute();\n        Assert.assertEquals(\"template\", templateAttribute.getValue());\n        Assert.assertEquals(\"type\", templateAttribute.getRenderer());\n        Assert.assertEquals(\"role\", templateAttribute.getRole());\n        Expression definitionExpressionObject = templateAttribute.getExpressionObject();\n        Assert.assertEquals(\"templ*\", definitionExpressionObject.getExpression());\n        Assert.assertNull(definitionExpressionObject.getLanguage());\n\n        Attribute putAttribute = definition.getAttribute(\"put-attr\");\n        Assert.assertNotNull(putAttribute);\n        Assert.assertEquals(\"attr-val\", putAttribute.getValue());\n        Assert.assertEquals(\"attr-type\", putAttribute.getRenderer());\n        Assert.assertEquals(\"attr-role\", putAttribute.getRole());\n        Expression putAttrExpressionObject = putAttribute.getExpressionObject();\n        Assert.assertEquals(\"expr\", putAttrExpressionObject.getExpression());\n        Assert.assertEquals(\"lang\", putAttrExpressionObject.getLanguage());\n\n        Attribute listAttribute = definition.getAttribute(\"list-name\");\n        Assert.assertEquals(\"list-role\", listAttribute.getRole());\n        List<Attribute> listValue = getListValue(listAttribute);\n        Assert.assertEquals(2, listValue.size());\n\n        Attribute addAttribute = listValue.get(0);\n        Assert.assertEquals(\"list-attr-role\", addAttribute.getRole());\n        Assert.assertEquals(\"list-attr-val\", addAttribute.getValue());\n        Assert.assertEquals(\"list-attr-type\", addAttribute.getRenderer());\n        Expression addAttrExpressionObject = addAttribute.getExpressionObject();\n        Assert.assertEquals(\"list-attr-expr\", addAttrExpressionObject.getExpression());\n\n        Attribute addListAttribute = listValue.get(1);\n        Assert.assertEquals(\"list-list-attr-role\", addListAttribute.getRole());\n        List<Attribute> addListValue = getListValue(addListAttribute);\n        Assert.assertEquals(1, addListValue.size());\n        Assert.assertEquals(\"list-list-add-attr\", addListValue.get(0).getValue());\n\n        Set<String> cascadedAttributeNames = definition.getCascadedAttributeNames();\n        Assert.assertEquals(2, cascadedAttributeNames.size());\n        Assert.assertTrue(cascadedAttributeNames.contains(\"put-attr\"));\n        Assert.assertTrue(cascadedAttributeNames.contains(\"list-name\"));\n    }\n\n    @Test\n    public void buildDefinitonAllEmpty() {\n        StrutsTilesAnnotationProcessor annotationProcessor = new StrutsTilesAnnotationProcessor();\n        TilesDefinition tilesDefinition = annotationProcessor.findAnnotation(new TilesTestActionSingleAnnotationAllEmpty(), null);\n\n        Definition definition = annotationProcessor.buildTilesDefinition(null, tilesDefinition);\n\n        Assert.assertNotNull(definition);\n        Assert.assertNull(definition.getName());\n        Assert.assertNull(definition.getPreparer());\n        Assert.assertNull(definition.getExtends());\n        Attribute templateAttribute = definition.getTemplateAttribute();\n        Assert.assertNull(templateAttribute.getValue());\n        Assert.assertNull(templateAttribute.getRole());\n        Assert.assertNull(templateAttribute.getExpressionObject());\n\n        Attribute putAttribute = definition.getAttribute(\"put-attr\");\n        Assert.assertNotNull(putAttribute);\n        Assert.assertNull(putAttribute.getValue());\n        Assert.assertNull(putAttribute.getRenderer());\n        Assert.assertNull(putAttribute.getRole());\n        Assert.assertNull(putAttribute.getExpressionObject());\n\n        Attribute listAttribute = definition.getAttribute(\"list-name\");\n        Assert.assertNull(listAttribute.getRole());\n        List<Attribute> listValue = getListValue(listAttribute);\n        Assert.assertEquals(2, listValue.size());\n\n        Attribute addAttribute = listValue.get(0);\n        Assert.assertNull(addAttribute.getRole());\n        Assert.assertNull(addAttribute.getValue());\n        Assert.assertNull(addAttribute.getRenderer());\n        Assert.assertNull(addAttribute.getExpressionObject());\n\n        Attribute addListAttribute = listValue.get(1);\n        Assert.assertNull(addListAttribute.getRole());\n        List<Attribute> addListValue = getListValue(addListAttribute);\n        Assert.assertEquals(1, addListValue.size());\n        Assert.assertNull(addListValue.get(0).getValue());\n\n        Set<String> cascadedAttributeNames = definition.getCascadedAttributeNames();\n        Assert.assertNull(cascadedAttributeNames);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected List<Attribute> getListValue(Attribute listAttribute) {\n        return (List<Attribute>) listAttribute.getValue();\n    }\n}\n", "focal_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.tiles;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.struts2.tiles.annotation.TilesAddAttribute;\nimport org.apache.struts2.tiles.annotation.TilesAddListAttribute;\nimport org.apache.struts2.tiles.annotation.TilesDefinition;\nimport org.apache.struts2.tiles.annotation.TilesDefinitions;\nimport org.apache.struts2.tiles.annotation.TilesPutAttribute;\nimport org.apache.struts2.tiles.annotation.TilesPutListAttribute;\nimport org.apache.tiles.api.Attribute;\nimport org.apache.tiles.api.Definition;\nimport org.apache.tiles.api.Expression;\nimport org.apache.tiles.api.ListAttribute;\n\n/**\n * Processes tiles annotations to create {@link Definition}s and\n * {@link Attribute}s in a way as close to <code>tiles.xml</code> as possible.\n *\n */\npublic class StrutsTilesAnnotationProcessor {\n\n    /**\n     * Search strategy is as follows:\n     * <ul>\n     *   <li>Check if action has Annotation {@link TilesDefinition}</li>\n     *   <li>If not, check if action has Annotation {@link TilesDefinitions}</li>\n     *   <li>If given tileName is not null and present in {@link TilesDefinitions}, return it</li>\n     *   <li>Return first element of {@link TilesDefinitions}</li>\n     *   <li>Return null</li>\n     * </ul>\n     *\n     * @param action\n     *            Annotated action.\n     * @param tileName\n     *            Tilename to search for. May be null in some circumstances.\n     * @return {@link TilesDefinition}\n     */\n    public TilesDefinition findAnnotation(Object action, String tileName) {\n        Class<?> clazz = action.getClass();\n        TilesDefinition tilesDefinition = clazz.getAnnotation(TilesDefinition.class);\n        TilesDefinitions tilesDefinitions = clazz.getAnnotation(TilesDefinitions.class);\n\n        if (tilesDefinition == null && tilesDefinitions != null) {\n            if (!StringUtils.isEmpty(tileName)) {\n                for (TilesDefinition i : tilesDefinitions.value()) {\n                    if (i.name().equals(tileName)) {\n                        tilesDefinition = i;\n                        break;\n                    }\n                }\n            } else {\n                if (tilesDefinitions.value().length > 0) {\n                    tilesDefinition = tilesDefinitions.value()[0];\n                }\n            }\n        }\n\n        return tilesDefinition;\n    }\n\n    /**\n     * Builds a {@link Definition} based on given {@link TilesDefinition} with\n     * given name.\n     *\n     * @param tileName\n     *            name for resulting {@link Definition}.\n     * @param tilesDefinition\n     *            {@link TilesDefinition} to process.\n     * @return {@link Definition} represented by given {@link TilesDefinition}.\n     */\n    public Definition buildTilesDefinition(String tileName, TilesDefinition tilesDefinition) {\n        Definition definition = new Definition();\n\n        definition.setName(tileName);\n\n        String extend = getValueOrNull(tilesDefinition.extend());\n        if (extend != null) {\n            definition.setExtends(extend);\n        }\n        String preparer = getValueOrNull(tilesDefinition.preparer());\n        if (preparer != null) {\n            definition.setPreparer(preparer);\n        }\n        definition.setTemplateAttribute(buildTemplateAttribute(tilesDefinition));\n\n        for (TilesPutAttribute putAttribute : tilesDefinition.putAttributes()) {\n            Attribute attribute = buildPutAttribute(putAttribute);\n            definition.putAttribute(putAttribute.name(), attribute, putAttribute.cascade());\n        }\n        for (TilesPutListAttribute putListAttribute : tilesDefinition.putListAttributes()) {\n            Attribute attribute = buildPutListAttribute(putListAttribute);\n            definition.putAttribute(putListAttribute.name(), attribute, putListAttribute.cascade());\n        }\n\n        return definition;\n    }\n\n    protected Attribute buildTemplateAttribute(TilesDefinition tilesDef) {\n        // see tiles DigesterDefinitionsReader\n        Attribute attribute = Attribute.createTemplateAttribute(getValueOrNull(tilesDef.template()));\n        String templateExpression = getValueOrNull(tilesDef.templateExpression());\n        Expression expression = Expression.createExpressionFromDescribedExpression(templateExpression);\n        attribute.setExpressionObject(expression);\n        attribute.setRole(getValueOrNull(tilesDef.role()));\n        String templateType = getValueOrNull(tilesDef.templateType());\n        if (templateType != null) {\n            attribute.setRenderer(templateType);\n        } else if (getValueOrNull(tilesDef.extend()) != null) {\n            attribute.setRenderer(null);\n        }\n        return attribute;\n    }\n\n    protected Attribute buildPutAttribute(TilesPutAttribute putAttribute) {\n        Attribute attribute = new Attribute();\n        attribute.setValue(getValueOrNull(putAttribute.value()));\n        String expression = getValueOrNull(putAttribute.expression());\n        attribute.setExpressionObject(Expression.createExpressionFromDescribedExpression(expression));\n        attribute.setRole(getValueOrNull(putAttribute.role()));\n        attribute.setRenderer(getValueOrNull(putAttribute.type()));\n        return attribute;\n    }\n\n    protected Attribute buildPutListAttribute(TilesPutListAttribute putListAttribute) {\n        ListAttribute attribute = new ListAttribute();\n        attribute.setRole(getValueOrNull(putListAttribute.role()));\n        attribute.setInherit(putListAttribute.inherit());\n        for (TilesAddAttribute addAttribute : putListAttribute.addAttributes()) {\n            attribute.add(buildAddAttribute(addAttribute));\n        }\n        for (TilesAddListAttribute addListAttribute : putListAttribute.addListAttributes()) {\n            attribute.add(buildAddListAttribute(addListAttribute));\n        }\n        return attribute;\n    }\n\n    protected Attribute buildAddAttribute(TilesAddAttribute addAttribute) {\n        Attribute attribute = new Attribute();\n        attribute.setValue(getValueOrNull(addAttribute.value()));\n        String expression = getValueOrNull(addAttribute.expression());\n        attribute.setExpressionObject(Expression.createExpressionFromDescribedExpression(expression));\n        attribute.setRole(getValueOrNull(addAttribute.role()));\n        attribute.setRenderer(getValueOrNull(addAttribute.type()));\n        return attribute;\n    }\n\n    protected Attribute buildAddListAttribute(TilesAddListAttribute addListAttribute) {\n        ListAttribute attribute = new ListAttribute();\n        attribute.setRole(getValueOrNull(addListAttribute.role()));\n        for (TilesAddAttribute addAttribute : addListAttribute.addAttributes()) {\n            attribute.add(buildAddAttribute(addAttribute));\n        }\n        return attribute;\n    }\n\n    protected String getValueOrNull(String value) {\n        return value != null && value.length() > 0 ? value : null;\n    }\n}\n"}
{"test_method": "@Test\n    public void convertUploadedFileArrayToFile() throws Exception {\n        // given\n        UploadedFileConverter ufc = new UploadedFileConverter();\n        UploadedFile[] uploadedFile = new UploadedFile[] { new StrutsUploadedFile(tempFile) };\n\n        // when\n        Object result = ufc.convertValue(context, target, member, propertyName, uploadedFile, File.class);\n\n        // then\n        assertThat(result).isInstanceOf(File.class);\n        File file = (File) result;\n        assertThat(file.length()).isEqualTo(tempFile.length());\n        assertThat(file.getAbsolutePath()).isEqualTo(tempFile.getAbsolutePath());\n    }", "focal_method": "@Override\n    public Object convertValue(Map<String, Object> context, Object target, Member member, String propertyName, Object value, Class toType) {\n        if (File.class.equals(toType)) {\n            LOG.debug(\"Converting {} into {}, consider switching to {} and do not access {} directly!\",\n                    File.class.getName(), UploadedFile.class.getName(), UploadedFile.class.getName(), File.class.getName());\n\n            Object obj;\n            if (value.getClass().isArray() && Array.getLength(value) == 1) {\n                obj = Array.get(value, 0);\n            } else {\n                obj = value;\n            }\n\n            if (obj instanceof UploadedFile) {\n                UploadedFile file = (UploadedFile) obj;\n                if (file.getContent() instanceof File) {\n                    return file.getContent();\n                }\n                return new File(file.getAbsolutePath());\n            }\n        }\n\n        return super.convertValue(context, target, member, propertyName, value, toType);\n    }", "test_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.conversion;\n\nimport org.apache.struts2.dispatcher.multipart.StrutsUploadedFile;\nimport org.apache.struts2.dispatcher.multipart.UploadedFile;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.io.File;\nimport java.lang.reflect.Member;\nimport java.util.Collections;\nimport java.util.Map;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\npublic class UploadedFileConverterTest {\n\n    private Map<String, Object> context;\n    private Class target;\n    private Member member;\n    private String propertyName;\n    private File tempFile;\n\n    @Before\n    public void setUp() throws Exception {\n        context = Collections.emptyMap();\n        target = File.class;\n        member = File.class.getMethod(\"length\");\n        propertyName = \"ignore\";\n        tempFile = File.createTempFile(\"struts\", \"test\");\n    }\n\n    @After\n    public void tearDown() throws Exception {\n        tempFile.delete();\n    }\n\n    @Test\n    public void convertUploadedFileToFile() throws Exception {\n        // given\n        UploadedFileConverter ufc = new UploadedFileConverter();\n        UploadedFile uploadedFile = new StrutsUploadedFile(tempFile);\n\n        // when\n        Object result = ufc.convertValue(context, target, member, propertyName, uploadedFile, File.class);\n\n        // then\n        assertThat(result).isInstanceOf(File.class);\n        File file = (File) result;\n        assertThat(file.length()).isEqualTo(tempFile.length());\n        assertThat(file.getAbsolutePath()).isEqualTo(tempFile.getAbsolutePath());\n    }\n\n    @Test\n    public void convertUploadedFileArrayToFile() throws Exception {\n        // given\n        UploadedFileConverter ufc = new UploadedFileConverter();\n        UploadedFile[] uploadedFile = new UploadedFile[] { new StrutsUploadedFile(tempFile) };\n\n        // when\n        Object result = ufc.convertValue(context, target, member, propertyName, uploadedFile, File.class);\n\n        // then\n        assertThat(result).isInstanceOf(File.class);\n        File file = (File) result;\n        assertThat(file.length()).isEqualTo(tempFile.length());\n        assertThat(file.getAbsolutePath()).isEqualTo(tempFile.getAbsolutePath());\n    }\n\n}", "focal_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.conversion;\n\nimport com.opensymphony.xwork2.conversion.impl.DefaultTypeConverter;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.struts2.dispatcher.multipart.UploadedFile;\n\nimport java.io.File;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Member;\nimport java.util.Map;\n\npublic class UploadedFileConverter extends DefaultTypeConverter {\n\n    private static final Logger LOG = LogManager.getLogger(UploadedFileConverter.class);\n\n    @Override\n    public Object convertValue(Map<String, Object> context, Object target, Member member, String propertyName, Object value, Class toType) {\n        if (File.class.equals(toType)) {\n            LOG.debug(\"Converting {} into {}, consider switching to {} and do not access {} directly!\",\n                    File.class.getName(), UploadedFile.class.getName(), UploadedFile.class.getName(), File.class.getName());\n\n            Object obj;\n            if (value.getClass().isArray() && Array.getLength(value) == 1) {\n                obj = Array.get(value, 0);\n            } else {\n                obj = value;\n            }\n\n            if (obj instanceof UploadedFile) {\n                UploadedFile file = (UploadedFile) obj;\n                if (file.getContent() instanceof File) {\n                    return file.getContent();\n                }\n                return new File(file.getAbsolutePath());\n            }\n        }\n\n        return super.convertValue(context, target, member, propertyName, value, toType);\n    }\n\n}\n"}
{"test_method": "@Test\n    public void testIsLiteral() {\n        NamedVariablePatternMatcher matcher = new NamedVariablePatternMatcher();\n\n        assertTrue(matcher.isLiteral(\"bob\"));\n        assertFalse(matcher.isLiteral(\"bob{jim}\"));\n    }", "focal_method": "public boolean isLiteral(String pattern) {\n        return (pattern == null || pattern.indexOf('{') == -1);\n    }", "test_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2.util;\n\nimport com.opensymphony.xwork2.util.NamedVariablePatternMatcher.CompiledPattern;\nimport org.junit.Test;\n\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.Pattern;\n\nimport static org.junit.Assert.*;\n\npublic class NamedVariablePatternMatcherTest {\n\n    @Test\n    public void testCompile() {\n        NamedVariablePatternMatcher matcher = new NamedVariablePatternMatcher();\n\n        assertNull(matcher.compilePattern(null));\n        assertNull(matcher.compilePattern(\"\"));\n\n        CompiledPattern pattern = matcher.compilePattern(\"action.{format}\");\n        assertEquals(\"\\\\Qaction.\\\\E([^/]+)\", pattern.getPattern().pattern());\n\n        pattern = matcher.compilePattern(\"foo\");\n        assertEquals(\"\\\\Qfoo\\\\E\", pattern.getPattern().pattern());\n\n        pattern = matcher.compilePattern(\"foo{jim}\");\n        assertEquals(\"\\\\Qfoo\\\\E([^/]+)\", pattern.getPattern().pattern());\n        assertEquals(\"jim\", pattern.getVariableNames().get(0));\n\n        pattern = matcher.compilePattern(\"foo{jim}/{bob}\");\n        assertEquals(\"\\\\Qfoo\\\\E([^/]+)\\\\Q/\\\\E([^/]+)\", pattern.getPattern().pattern());\n        assertEquals(\"jim\", pattern.getVariableNames().get(0));\n        assertEquals(\"bob\", pattern.getVariableNames().get(1));\n        assertTrue(pattern.getPattern().matcher(\"foostar/jie\").matches());\n        assertFalse(pattern.getPattern().matcher(\"foo/star/jie\").matches());\n\n        pattern = matcher.compilePattern(\"{urlLocale}/eula_cz\");\n        assertEquals(\"([^/]+)\\\\Q/eula_cz\\\\E\", pattern.getPattern().pattern());\n        assertEquals(\"urlLocale\", pattern.getVariableNames().get(0));\n        assertTrue(pattern.getPattern().matcher(\"foostar/eula_cz\").matches());\n        assertFalse(pattern.getPattern().matcher(\"foo/star/eula_cz\").matches());\n\n        pattern = matcher.compilePattern(\"{test1}/path/{test2}\");\n        assertEquals(\"([^/]+)\\\\Q/path/\\\\E([^/]+)\", pattern.getPattern().pattern());\n        assertEquals(\"test1\", pattern.getVariableNames().get(0));\n        assertEquals(\"test2\", pattern.getVariableNames().get(1));\n        assertTrue(pattern.getPattern().matcher(\"test1/path/test2\").matches());\n        assertFalse(pattern.getPattern().matcher(\"test/1/path/test2\").matches());\n\n        pattern = matcher.compilePattern(\"path1/{test1}/path2/{test2}\");\n        assertEquals(\"\\\\Qpath1/\\\\E([^/]+)\\\\Q/path2/\\\\E([^/]+)\", pattern.getPattern().pattern());\n        assertEquals(\"test1\", pattern.getVariableNames().get(0));\n        assertEquals(\"test2\", pattern.getVariableNames().get(1));\n        assertTrue(pattern.getPattern().matcher(\"path1/test1/path2/test2\").matches());\n        assertFalse(pattern.getPattern().matcher(\"path1/test/1/path2/test2\").matches());\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testCompileWithMissingVariableName() {\n        NamedVariablePatternMatcher matcher = new NamedVariablePatternMatcher();\n\n        matcher.compilePattern(\"{}\");\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testCompileWithMissingOpeningBracket1() {\n        NamedVariablePatternMatcher matcher = new NamedVariablePatternMatcher();\n\n        matcher.compilePattern(\"}\");\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testCompileWithMissingOpeningBracket2() {\n        NamedVariablePatternMatcher matcher = new NamedVariablePatternMatcher();\n\n        matcher.compilePattern(\"test}\");\n    }\n\n    @Test\n    public void testMatch() {\n        NamedVariablePatternMatcher matcher = new NamedVariablePatternMatcher();\n\n        Map<String, String> vars = new HashMap<>();\n        CompiledPattern pattern = new CompiledPattern(Pattern.compile(\"foo([^/]+)\"), Arrays.asList(\"bar\"));\n\n        assertTrue(matcher.match(vars, \"foobaz\", pattern));\n        assertEquals(\"baz\", vars.get(\"bar\"));\n    }\n\n    @Test\n    public void testIsLiteral() {\n        NamedVariablePatternMatcher matcher = new NamedVariablePatternMatcher();\n\n        assertTrue(matcher.isLiteral(\"bob\"));\n        assertFalse(matcher.isLiteral(\"bob{jim}\"));\n    }\n}\n", "focal_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2.util;\n\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * An implementation of a pattern matcher that uses simple named wildcards.  The named wildcards are defined using the\n * <code>{VARIABLE_NAME}</code> syntax and will match any characters that aren't '/'.  Internally, the pattern is\n * converted into a regular expression where the named wildcard will be translated into <code>([^/]+)</code> so that\n * at least one character must match in order for the wildcard to be matched successfully.  Matched values will be\n * available in the variable map, indexed by the name they were given in the pattern.\n *\n * <p>For example, the following patterns will be processed as so:</p>\n *\n * <table summary=\"\">\n * <tr>\n *  <th>Pattern</th>\n *  <th>Example</th>\n *  <th>Variable Map Contents</th>\n * </tr>\n * <tr>\n *  <td><code>/animals/{animal}</code></td>\n *  <td><code>/animals/dog</code></td>\n *  <td>{animal -&gt; dog}</td>\n * </tr>\n * <tr>\n *  <td><code>/animals/{animal}/tag/No{id}</code></td>\n *  <td><code>/animals/dog/tag/No23</code></td>\n *  <td>{animal -&gt; dog, id -&gt; 23}</td>\n * </tr>\n * <tr>\n *  <td><code>/{language}</code></td>\n *  <td><code>/en</code></td>\n *  <td>{language -&gt; en}</td>\n * </tr>\n * </table>\n *\n * <p>\n * Escaping hasn't been implemented since the intended use of these patterns will be in matching URLs.\n * </p>\n *\n * @since 2.1\n */\npublic class NamedVariablePatternMatcher implements PatternMatcher<NamedVariablePatternMatcher.CompiledPattern> {\n\n    public boolean isLiteral(String pattern) {\n        return (pattern == null || pattern.indexOf('{') == -1);\n    }\n\n    /**\n     * Compiles the pattern.\n     *\n     * @param data The pattern, must not be null or empty\n     * @return The compiled pattern, null if the pattern was null or empty\n     */\n    public CompiledPattern compilePattern(String data) {\n        if (StringUtils.isEmpty(data)) {\n            return null;\n        }\n\n        int len = data.length();\n        StringBuilder regex = new StringBuilder();\n        List<String> varNames = new ArrayList<>();\n        int s = 0;\n        while (s < len) {\n            int e = data.indexOf('{', s);\n            if (e < 0 && data.indexOf('}', s) > -1) {\n                throw new IllegalArgumentException(\"Missing opening '{' in [\" + data + \"]!\");\n            }\n            if (e < 0) {\n                regex.append(Pattern.quote(data.substring(s)));\n                break;\n            }\n            if (e > s) {\n                regex.append(Pattern.quote(data.substring(s, e)));\n            }\n            s = e + 1;\n            e = data.indexOf('}', s);\n            if (e < 0) {\n                return null;\n            }\n            String varName = data.substring(s, e);\n            if (StringUtils.isEmpty(varName)) {\n                throw new IllegalArgumentException(\"Missing variable name in [\" + data + \"]!\");\n            }\n            varNames.add(varName);\n            regex.append(\"([^/]+)\");\n            s = e + 1;\n        }\n        return new CompiledPattern(Pattern.compile(regex.toString()), varNames);\n    }\n\n    /**\n     * Tries to process the data against the compiled expression.  If successful, the map will contain\n     * the matched data, using the specified variable names in the original pattern.\n     *\n     * @param map  The map of variables\n     * @param data The data to match\n     * @param expr The compiled pattern\n     * @return True if matched, false if not matched, the data was null, or the data was an empty string\n     */\n    public boolean match(Map<String, String> map, String data, CompiledPattern expr) {\n\n        if (data != null && data.length() > 0) {\n            Matcher matcher = expr.getPattern().matcher(data);\n            if (matcher.matches()) {\n                for (int x = 0; x < expr.getVariableNames().size(); x++) {\n                    map.put(expr.getVariableNames().get(x), matcher.group(x + 1));\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Stores the compiled pattern and the variable names matches will correspond to.\n     */\n    public static class CompiledPattern {\n        private final Pattern pattern;\n        private final List<String> variableNames;\n\n\n        public CompiledPattern(Pattern pattern, List<String> variableNames) {\n            this.pattern = pattern;\n            this.variableNames = variableNames;\n        }\n\n        public Pattern getPattern() {\n            return pattern;\n        }\n\n        public List<String> getVariableNames() {\n            return variableNames;\n        }\n    }\n}\n"}
{"test_method": "@Test\n    public void convertUploadedFileToFile() throws Exception {\n        // given\n        UploadedFileConverter ufc = new UploadedFileConverter();\n        UploadedFile uploadedFile = new StrutsUploadedFile(tempFile);\n\n        // when\n        Object result = ufc.convertValue(context, target, member, propertyName, uploadedFile, File.class);\n\n        // then\n        assertThat(result).isInstanceOf(File.class);\n        File file = (File) result;\n        assertThat(file.length()).isEqualTo(tempFile.length());\n        assertThat(file.getAbsolutePath()).isEqualTo(tempFile.getAbsolutePath());\n    }", "focal_method": "@Override\n    public Object convertValue(Map<String, Object> context, Object target, Member member, String propertyName, Object value, Class toType) {\n        if (File.class.equals(toType)) {\n            LOG.debug(\"Converting {} into {}, consider switching to {} and do not access {} directly!\",\n                    File.class.getName(), UploadedFile.class.getName(), UploadedFile.class.getName(), File.class.getName());\n\n            Object obj;\n            if (value.getClass().isArray() && Array.getLength(value) == 1) {\n                obj = Array.get(value, 0);\n            } else {\n                obj = value;\n            }\n\n            if (obj instanceof UploadedFile) {\n                UploadedFile file = (UploadedFile) obj;\n                if (file.getContent() instanceof File) {\n                    return file.getContent();\n                }\n                return new File(file.getAbsolutePath());\n            }\n        }\n\n        return super.convertValue(context, target, member, propertyName, value, toType);\n    }", "test_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.conversion;\n\nimport org.apache.struts2.dispatcher.multipart.StrutsUploadedFile;\nimport org.apache.struts2.dispatcher.multipart.UploadedFile;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.io.File;\nimport java.lang.reflect.Member;\nimport java.util.Collections;\nimport java.util.Map;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\npublic class UploadedFileConverterTest {\n\n    private Map<String, Object> context;\n    private Class target;\n    private Member member;\n    private String propertyName;\n    private File tempFile;\n\n    @Before\n    public void setUp() throws Exception {\n        context = Collections.emptyMap();\n        target = File.class;\n        member = File.class.getMethod(\"length\");\n        propertyName = \"ignore\";\n        tempFile = File.createTempFile(\"struts\", \"test\");\n    }\n\n    @After\n    public void tearDown() throws Exception {\n        tempFile.delete();\n    }\n\n    @Test\n    public void convertUploadedFileToFile() throws Exception {\n        // given\n        UploadedFileConverter ufc = new UploadedFileConverter();\n        UploadedFile uploadedFile = new StrutsUploadedFile(tempFile);\n\n        // when\n        Object result = ufc.convertValue(context, target, member, propertyName, uploadedFile, File.class);\n\n        // then\n        assertThat(result).isInstanceOf(File.class);\n        File file = (File) result;\n        assertThat(file.length()).isEqualTo(tempFile.length());\n        assertThat(file.getAbsolutePath()).isEqualTo(tempFile.getAbsolutePath());\n    }\n\n    @Test\n    public void convertUploadedFileArrayToFile() throws Exception {\n        // given\n        UploadedFileConverter ufc = new UploadedFileConverter();\n        UploadedFile[] uploadedFile = new UploadedFile[] { new StrutsUploadedFile(tempFile) };\n\n        // when\n        Object result = ufc.convertValue(context, target, member, propertyName, uploadedFile, File.class);\n\n        // then\n        assertThat(result).isInstanceOf(File.class);\n        File file = (File) result;\n        assertThat(file.length()).isEqualTo(tempFile.length());\n        assertThat(file.getAbsolutePath()).isEqualTo(tempFile.getAbsolutePath());\n    }\n\n}", "focal_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.conversion;\n\nimport com.opensymphony.xwork2.conversion.impl.DefaultTypeConverter;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.struts2.dispatcher.multipart.UploadedFile;\n\nimport java.io.File;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Member;\nimport java.util.Map;\n\npublic class UploadedFileConverter extends DefaultTypeConverter {\n\n    private static final Logger LOG = LogManager.getLogger(UploadedFileConverter.class);\n\n    @Override\n    public Object convertValue(Map<String, Object> context, Object target, Member member, String propertyName, Object value, Class toType) {\n        if (File.class.equals(toType)) {\n            LOG.debug(\"Converting {} into {}, consider switching to {} and do not access {} directly!\",\n                    File.class.getName(), UploadedFile.class.getName(), UploadedFile.class.getName(), File.class.getName());\n\n            Object obj;\n            if (value.getClass().isArray() && Array.getLength(value) == 1) {\n                obj = Array.get(value, 0);\n            } else {\n                obj = value;\n            }\n\n            if (obj instanceof UploadedFile) {\n                UploadedFile file = (UploadedFile) obj;\n                if (file.getContent() instanceof File) {\n                    return file.getContent();\n                }\n                return new File(file.getAbsolutePath());\n            }\n        }\n\n        return super.convertValue(context, target, member, propertyName, value, toType);\n    }\n\n}\n"}
{"test_method": "@Test\n    public void testMatch() {\n        NamedVariablePatternMatcher matcher = new NamedVariablePatternMatcher();\n\n        Map<String, String> vars = new HashMap<>();\n        CompiledPattern pattern = new CompiledPattern(Pattern.compile(\"foo([^/]+)\"), Arrays.asList(\"bar\"));\n\n        assertTrue(matcher.match(vars, \"foobaz\", pattern));\n        assertEquals(\"baz\", vars.get(\"bar\"));\n    }", "focal_method": "public boolean match(Map<String, String> map, String data, CompiledPattern expr) {\n\n        if (data != null && data.length() > 0) {\n            Matcher matcher = expr.getPattern().matcher(data);\n            if (matcher.matches()) {\n                for (int x=0; x<expr.getVariableNames().size(); x++)  {\n                    map.put(expr.getVariableNames().get(x), matcher.group(x+1));\n                }\n                return true;\n            }\n        }\n        return false;\n    }", "test_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2.util;\n\nimport com.opensymphony.xwork2.util.NamedVariablePatternMatcher.CompiledPattern;\nimport org.junit.Test;\n\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.Pattern;\n\nimport static org.junit.Assert.*;\n\npublic class NamedVariablePatternMatcherTest {\n\n    @Test\n    public void testCompile() {\n        NamedVariablePatternMatcher matcher = new NamedVariablePatternMatcher();\n\n        assertNull(matcher.compilePattern(null));\n        assertNull(matcher.compilePattern(\"\"));\n\n        CompiledPattern pattern = matcher.compilePattern(\"action.{format}\");\n        assertEquals(\"\\\\Qaction.\\\\E([^/]+)\", pattern.getPattern().pattern());\n\n        pattern = matcher.compilePattern(\"foo\");\n        assertEquals(\"\\\\Qfoo\\\\E\", pattern.getPattern().pattern());\n\n        pattern = matcher.compilePattern(\"foo{jim}\");\n        assertEquals(\"\\\\Qfoo\\\\E([^/]+)\", pattern.getPattern().pattern());\n        assertEquals(\"jim\", pattern.getVariableNames().get(0));\n\n        pattern = matcher.compilePattern(\"foo{jim}/{bob}\");\n        assertEquals(\"\\\\Qfoo\\\\E([^/]+)\\\\Q/\\\\E([^/]+)\", pattern.getPattern().pattern());\n        assertEquals(\"jim\", pattern.getVariableNames().get(0));\n        assertEquals(\"bob\", pattern.getVariableNames().get(1));\n        assertTrue(pattern.getPattern().matcher(\"foostar/jie\").matches());\n        assertFalse(pattern.getPattern().matcher(\"foo/star/jie\").matches());\n\n        pattern = matcher.compilePattern(\"{urlLocale}/eula_cz\");\n        assertEquals(\"([^/]+)\\\\Q/eula_cz\\\\E\", pattern.getPattern().pattern());\n        assertEquals(\"urlLocale\", pattern.getVariableNames().get(0));\n        assertTrue(pattern.getPattern().matcher(\"foostar/eula_cz\").matches());\n        assertFalse(pattern.getPattern().matcher(\"foo/star/eula_cz\").matches());\n\n        pattern = matcher.compilePattern(\"{test1}/path/{test2}\");\n        assertEquals(\"([^/]+)\\\\Q/path/\\\\E([^/]+)\", pattern.getPattern().pattern());\n        assertEquals(\"test1\", pattern.getVariableNames().get(0));\n        assertEquals(\"test2\", pattern.getVariableNames().get(1));\n        assertTrue(pattern.getPattern().matcher(\"test1/path/test2\").matches());\n        assertFalse(pattern.getPattern().matcher(\"test/1/path/test2\").matches());\n\n        pattern = matcher.compilePattern(\"path1/{test1}/path2/{test2}\");\n        assertEquals(\"\\\\Qpath1/\\\\E([^/]+)\\\\Q/path2/\\\\E([^/]+)\", pattern.getPattern().pattern());\n        assertEquals(\"test1\", pattern.getVariableNames().get(0));\n        assertEquals(\"test2\", pattern.getVariableNames().get(1));\n        assertTrue(pattern.getPattern().matcher(\"path1/test1/path2/test2\").matches());\n        assertFalse(pattern.getPattern().matcher(\"path1/test/1/path2/test2\").matches());\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testCompileWithMissingVariableName() {\n        NamedVariablePatternMatcher matcher = new NamedVariablePatternMatcher();\n\n        matcher.compilePattern(\"{}\");\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testCompileWithMissingOpeningBracket1() {\n        NamedVariablePatternMatcher matcher = new NamedVariablePatternMatcher();\n\n        matcher.compilePattern(\"}\");\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testCompileWithMissingOpeningBracket2() {\n        NamedVariablePatternMatcher matcher = new NamedVariablePatternMatcher();\n\n        matcher.compilePattern(\"test}\");\n    }\n\n    @Test\n    public void testMatch() {\n        NamedVariablePatternMatcher matcher = new NamedVariablePatternMatcher();\n\n        Map<String, String> vars = new HashMap<>();\n        CompiledPattern pattern = new CompiledPattern(Pattern.compile(\"foo([^/]+)\"), Arrays.asList(\"bar\"));\n\n        assertTrue(matcher.match(vars, \"foobaz\", pattern));\n        assertEquals(\"baz\", vars.get(\"bar\"));\n    }\n\n    @Test\n    public void testIsLiteral() {\n        NamedVariablePatternMatcher matcher = new NamedVariablePatternMatcher();\n\n        assertTrue(matcher.isLiteral(\"bob\"));\n        assertFalse(matcher.isLiteral(\"bob{jim}\"));\n    }\n}\n", "focal_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2.util;\n\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * An implementation of a pattern matcher that uses simple named wildcards.  The named wildcards are defined using the\n * <code>{VARIABLE_NAME}</code> syntax and will match any characters that aren't '/'.  Internally, the pattern is\n * converted into a regular expression where the named wildcard will be translated into <code>([^/]+)</code> so that\n * at least one character must match in order for the wildcard to be matched successfully.  Matched values will be\n * available in the variable map, indexed by the name they were given in the pattern.\n *\n * <p>For example, the following patterns will be processed as so:</p>\n *\n * <table summary=\"\">\n * <tr>\n *  <th>Pattern</th>\n *  <th>Example</th>\n *  <th>Variable Map Contents</th>\n * </tr>\n * <tr>\n *  <td><code>/animals/{animal}</code></td>\n *  <td><code>/animals/dog</code></td>\n *  <td>{animal -&gt; dog}</td>\n * </tr>\n * <tr>\n *  <td><code>/animals/{animal}/tag/No{id}</code></td>\n *  <td><code>/animals/dog/tag/No23</code></td>\n *  <td>{animal -&gt; dog, id -&gt; 23}</td>\n * </tr>\n * <tr>\n *  <td><code>/{language}</code></td>\n *  <td><code>/en</code></td>\n *  <td>{language -&gt; en}</td>\n * </tr>\n * </table>\n *\n * <p>\n * Escaping hasn't been implemented since the intended use of these patterns will be in matching URLs.\n * </p>\n *\n * @since 2.1\n */\npublic class NamedVariablePatternMatcher implements PatternMatcher<NamedVariablePatternMatcher.CompiledPattern> {\n\n    public boolean isLiteral(String pattern) {\n        return (pattern == null || pattern.indexOf('{') == -1);\n    }\n\n    /**\n     * Compiles the pattern.\n     *\n     * @param data The pattern, must not be null or empty\n     * @return The compiled pattern, null if the pattern was null or empty\n     */\n    public CompiledPattern compilePattern(String data) {\n        if (StringUtils.isEmpty(data)) {\n            return null;\n        }\n\n        int len = data.length();\n        StringBuilder regex = new StringBuilder();\n        List<String> varNames = new ArrayList<>();\n        int s = 0;\n        while (s < len) {\n            int e = data.indexOf('{', s);\n            if (e < 0 && data.indexOf('}', s) > -1) {\n                throw new IllegalArgumentException(\"Missing opening '{' in [\" + data + \"]!\");\n            }\n            if (e < 0) {\n                regex.append(Pattern.quote(data.substring(s)));\n                break;\n            }\n            if (e > s) {\n                regex.append(Pattern.quote(data.substring(s, e)));\n            }\n            s = e + 1;\n            e = data.indexOf('}', s);\n            if (e < 0) {\n                return null;\n            }\n            String varName = data.substring(s, e);\n            if (StringUtils.isEmpty(varName)) {\n                throw new IllegalArgumentException(\"Missing variable name in [\" + data + \"]!\");\n            }\n            varNames.add(varName);\n            regex.append(\"([^/]+)\");\n            s = e + 1;\n        }\n        return new CompiledPattern(Pattern.compile(regex.toString()), varNames);\n    }\n\n    /**\n     * Tries to process the data against the compiled expression.  If successful, the map will contain\n     * the matched data, using the specified variable names in the original pattern.\n     *\n     * @param map  The map of variables\n     * @param data The data to match\n     * @param expr The compiled pattern\n     * @return True if matched, false if not matched, the data was null, or the data was an empty string\n     */\n    public boolean match(Map<String, String> map, String data, CompiledPattern expr) {\n\n        if (data != null && data.length() > 0) {\n            Matcher matcher = expr.getPattern().matcher(data);\n            if (matcher.matches()) {\n                for (int x = 0; x < expr.getVariableNames().size(); x++) {\n                    map.put(expr.getVariableNames().get(x), matcher.group(x + 1));\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Stores the compiled pattern and the variable names matches will correspond to.\n     */\n    public static class CompiledPattern {\n        private final Pattern pattern;\n        private final List<String> variableNames;\n\n\n        public CompiledPattern(Pattern pattern, List<String> variableNames) {\n            this.pattern = pattern;\n            this.variableNames = variableNames;\n        }\n\n        public Pattern getPattern() {\n            return pattern;\n        }\n\n        public List<String> getVariableNames() {\n            return variableNames;\n        }\n    }\n}\n"}
{"test_method": "@Test\n    public void testGetBean() {\n        MockBeanFactory mockBeanFactory = new MockBeanFactory();\n\n        Object mockBean = OsgiUtil.getBean(mockBeanFactory, \"1000\");\n        Assert.assertNotNull(\"OsgiUtil getBean() on mock bean factory returned null ?\", mockBean);\n        Assert.assertTrue(\"Mock bean from mock bean factory has mismatched id ?\", mockBeanFactory.beanMatchesId(mockBean, \"1000\"));\n\n        mockBean = OsgiUtil.getBean(new Object(), \"1000\");  // Logs an error (coverage only).\n        Assert.assertNull(\"OsgiUtil getBean() on normal object found a getBean() method ?\", mockBean);\n    }", "focal_method": "public static Object getBean(Object beanFactory, String beanId) {\n        try {\n            Method getBeanMethod = beanFactory.getClass().getMethod(\"getBean\", String.class);\n            return getBeanMethod.invoke(beanFactory, beanId);\n        } catch (Exception ex) {\n            LOG.error(\"Unable to call getBean() on object of type [{}], with bean id [{}]\",  beanFactory.getClass().getName(), beanId, ex);\n        }\n\n        return null;\n    }", "test_file": "/*\n * Copyright 2020 Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.struts2.osgi;\n\nimport org.junit.Assert;\nimport org.junit.Test;\n\n/**\n *  Basic tests for OsgiUtil\n */\npublic class OsgiUtilTest  {\n\n    /*\n     * An independent unit test for OsgiUtil.translateBundleURLToJarURL() would be nice, but appears\n     * complicated to do without either creating and installing a custom URL handler or using\n     * one of the Mock frameworks that can mock final classes like URL.\n     */\n\n    @Test\n    public void testGetBean() {\n        MockBeanFactory mockBeanFactory = new MockBeanFactory();\n\n        Object mockBean = OsgiUtil.getBean(mockBeanFactory, \"1000\");\n        Assert.assertNotNull(\"OsgiUtil getBean() on mock bean factory returned null ?\", mockBean);\n        Assert.assertTrue(\"Mock bean from mock bean factory has mismatched id ?\", mockBeanFactory.beanMatchesId(mockBean, \"1000\"));\n\n        mockBean = OsgiUtil.getBean(new Object(), \"1000\");  // Logs an error (coverage only).\n        Assert.assertNull(\"OsgiUtil getBean() on normal object found a getBean() method ?\", mockBean);\n    }\n\n    @Test\n    public void testContainsBean() {\n        MockBeanFactory mockBeanFactory = new MockBeanFactory();\n\n        Assert.assertTrue(\"OsgiUtil containsBean() on mock bean factory with numeric id is false ?\", OsgiUtil.containsBean(mockBeanFactory, \"1000\"));\n        Assert.assertFalse(\"OsgiUtil containsBean() on mock bean factory with nonnumeric id is true ?\", OsgiUtil.containsBean(mockBeanFactory, \"NotANumber\"));\n        Assert.assertFalse(\"OsgiUtil containsBean() on mock bean factory with null id is true ?\", OsgiUtil.containsBean(mockBeanFactory, null));\n    }\n\n    @Test\n    public void testGenerateJavaVersionForSystemPackages() {\n        // Some test patterns copied from OgnlRuntimeTest.testMajorJavaVersionParse() in OGNL 3.2.x.\n        // Pre-JDK 9 version strings.\n        Assert.assertEquals(\"JDK 5 generate java version failed ?\", \"1.5\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.5\"));\n        Assert.assertEquals(\"JDK 5 generate java version failed ?\", \"1.5\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.5.0\"));\n        Assert.assertEquals(\"JDK 5 generate java version failed ?\", \"1.5\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.5.0_21-b11\"));\n        Assert.assertEquals(\"JDK 6 generate java version failed ?\", \"1.6\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.6\"));\n        Assert.assertEquals(\"JDK 6 generate java version failed ?\", \"1.6\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.6.0\"));\n        Assert.assertEquals(\"JDK 6 generate java version failed ?\", \"1.6\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.6.0_43-b19\"));\n        Assert.assertEquals(\"JDK 7 generate java version failed ?\", \"1.7\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.7\"));\n        Assert.assertEquals(\"JDK 7 generate java version failed ?\", \"1.7\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.7.0\"));\n        Assert.assertEquals(\"JDK 7 generate java version failed ?\", \"1.7\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.7.0_79-b15\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"1.8\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.8\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"1.8\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.8.0\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"1.8\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.8.0_201-b20\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"1.8\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.8.0-someopenjdkstyle\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"1.8\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.8.0_201-someopenjdkstyle\"));\n        // JDK 9 and later version strings.\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"9.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"9\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"9.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"9-ea+19\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"9.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"9+100\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"9.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"9-ea+19\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"9.1\", OsgiUtil.generateJavaVersionForSystemPackages(\"9.1.3+15\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"9.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"9-someopenjdkstyle\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"10.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"10\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"10.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"10-ea+11\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"10.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"10+10\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"10.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"10-ea+11\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"10.1\", OsgiUtil.generateJavaVersionForSystemPackages(\"10.1.3+15\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"10.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"10-someopenjdkstyle\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"11.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"11\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"11.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"11-ea+22\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"11.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"11+33\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"11.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"11-ea+19\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"11.1\", OsgiUtil.generateJavaVersionForSystemPackages(\"11.1.3+15\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"11.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"11-someopenjdkstyle\"));\n    }\n\n    @Test\n    public void testGenerateJava_SE_SystemPackageVersionString() {\n        // Some test patterns copied from OgnlRuntimeTest.testMajorJavaVersionParse() in OGNL 3.2.x.\n        // Pre-JDK 9 version strings.\n        Assert.assertEquals(\"JDK 5 generate java version failed ?\", \"0.0.0.JavaSE_001_005\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.5\"));\n        Assert.assertEquals(\"JDK 5 generate java version failed ?\", \"0.0.0.JavaSE_001_005\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.5.0\"));\n        Assert.assertEquals(\"JDK 5 generate java version failed ?\", \"0.0.0.JavaSE_001_005\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.5.0_21-b11\"));\n        Assert.assertEquals(\"JDK 6 generate java version failed ?\", \"0.0.0.JavaSE_001_006\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.6\"));\n        Assert.assertEquals(\"JDK 6 generate java version failed ?\", \"0.0.0.JavaSE_001_006\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.6.0\"));\n        Assert.assertEquals(\"JDK 6 generate java version failed ?\", \"0.0.0.JavaSE_001_006\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.6.0_43-b19\"));\n        Assert.assertEquals(\"JDK 7 generate java version failed ?\", \"0.0.0.JavaSE_001_007\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.7\"));\n        Assert.assertEquals(\"JDK 7 generate java version failed ?\", \"0.0.0.JavaSE_001_007\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.7.0\"));\n        Assert.assertEquals(\"JDK 7 generate java version failed ?\", \"0.0.0.JavaSE_001_007\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.7.0_79-b15\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"0.0.0.JavaSE_001_008\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.8\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"0.0.0.JavaSE_001_008\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.8.0\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"0.0.0.JavaSE_001_008\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.8.0_201-b20\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"0.0.0.JavaSE_001_008\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.8.0-someopenjdkstyle\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"0.0.0.JavaSE_001_008\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.8.0_201-someopenjdkstyle\"));\n        // JDK 9 and later version strings.\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"0.0.0.JavaSE_009\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"9\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"0.0.0.JavaSE_009\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"9-ea+19\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"0.0.0.JavaSE_009\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"9+100\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"0.0.0.JavaSE_009\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"9-ea+19\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"0.0.0.JavaSE_009\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"9.1.3+15\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"0.0.0.JavaSE_009\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"9-someopenjdkstyle\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"0.0.0.JavaSE_010\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"10\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"0.0.0.JavaSE_010\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"10-ea+11\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"0.0.0.JavaSE_010\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"10+10\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"0.0.0.JavaSE_010\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"10-ea+11\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"0.0.0.JavaSE_010\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"10.1.3+15\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"0.0.0.JavaSE_010\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"10-someopenjdkstyle\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"0.0.0.JavaSE_011\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"11\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"0.0.0.JavaSE_011\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"11-ea+22\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"0.0.0.JavaSE_011\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"11+33\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"0.0.0.JavaSE_011\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"11-ea+19\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"0.0.0.JavaSE_011\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"11.1.3+15\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"0.0.0.JavaSE_011\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"11-someopenjdkstyle\"));\n    }\n\n    private class MockBeanFactory {\n\n        public Object getBean(String beanId) {\n            return \"MockBean: \" + beanId;\n        }\n\n        public boolean containsBean(String beanId) {\n            boolean result = false;\n\n            if (beanId != null) {\n                try {\n                    Integer.parseInt(beanId);\n                    result = true;\n                } catch (NumberFormatException nfe) {\n                    result = false;\n                }\n            }\n\n            return result;\n        }\n\n        public final boolean beanMatchesId(Object mockBean, String beanId) {\n            return mockBean.equals(\"MockBean: \" + beanId);\n        }\n\n    }\n\n}\n", "focal_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.osgi;\n\nimport org.apache.logging.log4j.Logger;\nimport org.apache.logging.log4j.LogManager;\nimport org.osgi.framework.Bundle;\n\nimport java.lang.reflect.Method;\nimport java.net.MalformedURLException;\nimport java.net.URL;\n\npublic class OsgiUtil {\n\n    private static final Logger LOG = LogManager.getLogger(OsgiUtil.class);\n\n    /**\n     * A bundle is a jar, and a bundle URL will be useless to clients, this method translates\n     * a URL to a resource inside a bundle from \"bundle:something/path\" to \"jar:file:bundlelocation!/path\"\n     *\n     * @param bundleUrl URL to translate\n     * @param bundle the bundle\n     *\n     * @return translated URL\n     *\n     * @throws MalformedURLException if URL is malformed\n     */\n    public static URL translateBundleURLToJarURL(URL bundleUrl, Bundle bundle) throws MalformedURLException {\n        if (bundleUrl != null && \"bundle\".equalsIgnoreCase(bundleUrl.getProtocol())) {\n            StringBuilder sb = new StringBuilder(\"jar:\");\n            sb.append(bundle.getLocation());\n            sb.append(\"!\");\n            sb.append(bundleUrl.getFile());\n            return new URL(sb.toString());\n        }\n\n        return bundleUrl;\n    }\n\n    /**\n     * Calls getBean() on the passed object using reflection. Used on Spring context\n     * because they are loaded from bundles (in another class loader)\n     *\n     * @param beanFactory bean factory\n     * @param beanId id of bean\n     *\n     * @return the object found\n     */\n    public static Object getBean(Object beanFactory, String beanId) {\n        try {\n            Method getBeanMethod = beanFactory.getClass().getMethod(\"getBean\", String.class);\n            return getBeanMethod.invoke(beanFactory, beanId);\n        } catch (Exception ex) {\n            LOG.error(\"Unable to call getBean() on object of type [{}], with bean id [{}]\",  beanFactory.getClass().getName(), beanId, ex);\n        }\n\n        return null;\n    }\n\n    /**\n     * Calls containsBean on the passed object using reflection. Used on Spring context\n     * because they are loaded from bundles (in another class loader)\n     *\n     * @param beanFactory bean factory\n     * @param beanId id of bean\n     *\n     * @return true if bean factory contains bean with bean id\n     */\n    public static boolean containsBean(Object beanFactory, String beanId) {\n        try {\n            Method getBeanMethod = beanFactory.getClass().getMethod(\"containsBean\", String.class);\n            return (Boolean) getBeanMethod.invoke(beanFactory, beanId);\n        } catch (Exception ex) {\n            LOG.error(\"Unable to call containsBean() on object of type [{}], with bean id [{}]\", beanFactory.getClass().getName(), beanId, ex);\n        }\n\n        return false;\n    }\n\n    /**\n     * Attempt to generate an OSGi compatible Java version String from the System \"java.version\" property,\n     * with the form (where x is the major version number): 1.x for Java 8 and earlier, x.y for Java 9+.\n     * See <a href=\"https://openjdk.java.net/jeps/223\">JEP 223: New Version-String Scheme</a> for details\n     * on version naming changes.\n     * \n     * @param systemJavaVersion a Java version string from System.getProperty(\"java.version\") or equivalent.\n     * @return a String of the form (where x is the major version number): 1.x for Java 8 and earlier, x.y for Java 9+.\n     */\n    public static String generateJavaVersionForSystemPackages(String systemJavaVersion) {\n        if (systemJavaVersion == null || systemJavaVersion.isEmpty()) {\n            throw new IllegalArgumentException(\"Cannot parse Java version from null or empty string\");\n        } else {\n            String parsedResult;\n            final int dotIndex1 = systemJavaVersion.indexOf('.');\n            final int dotIndex2 = (dotIndex1 > 0 ? systemJavaVersion.indexOf('.', dotIndex1 + 1) : -1);\n            if (dotIndex1 > 0 && dotIndex2 > 0) {\n                parsedResult = systemJavaVersion.substring(0, dotIndex2);  // Assuming Java 8 or older style, or Java 9+ with a minor or security update.\n            } else if (dotIndex1 > 0) {\n                parsedResult = systemJavaVersion;  // Assuming a truncated Java 8 or older style, or Java 9+ with a minor or security update.\n            } else if (dotIndex1 == -1) {\n                final int minusIndex = systemJavaVersion.indexOf('-');\n                final int plusIndex = systemJavaVersion.indexOf('+');\n                if (minusIndex > 0) {\n                    parsedResult = systemJavaVersion.substring(0, minusIndex);  // Assuming Java 9+ early-access\n                } else if (plusIndex > 0) {\n                    parsedResult = systemJavaVersion.substring(0, plusIndex);  // Assuming Java 9+ java.runime.version or java.vm.version string\n                } else {\n                    parsedResult = systemJavaVersion;\n                }\n                try {\n                    final int firstNumber = Integer.parseInt(parsedResult);\n                    if (firstNumber >= 9) {\n                        parsedResult = parsedResult + \".0\";  // Assuming Java 9+ and no minor or security update, append standard value.\n                    } else {\n                        throw new IllegalArgumentException(\"Single digit Java version string less than 9 (nonsense)\");\n                    }\n                } catch (Exception ex) {\n                    throw new IllegalArgumentException(\"Cannot parse Java version string (probable non-numeric start)\", ex);\n                }\n            } else {\n                throw new IllegalArgumentException(\"Cannot parse Java version from a string starting with a '.'\");\n            }\n            return parsedResult;\n        }\n    }\n\n    /**\n     * Attempt to generate an OSGi compatible Java SE system package version String from the System \"java.version\" property,\n     * with the form (where x or xx is the major version number): 0.0.0.JavaSE_001_00x for Java 8 and earlier (e.g. 0.0.0.JavaSE_001_008),\n     * 0.0.0.JavaSE_0xx for Java 9+ (e.g. 0.0.0.JavaSE_009 for Java 9, 0.0.0.JavaSE_011 for Java 11).\n     * \n     * @param systemJavaVersion a Java version string from System.getProperty(\"java.version\") or equivalent.\n     * @return a String of the form (where x or xx is the major version number): JavaSE_001_00x for Java 8 and earlier, JavaSE_0xx for Java 9+.\n     */\n    public static String generateJava_SE_SystemPackageVersionString(String systemJavaVersion) {\n        final String javaVersionForSystemPackages = generateJavaVersionForSystemPackages(systemJavaVersion);\n        final int dotIndex = javaVersionForSystemPackages.indexOf('.');\n        if (dotIndex > 0) {\n            final String generatedResult;\n            try {\n                final String prefix = javaVersionForSystemPackages.substring(0, dotIndex);\n                final String suffix = javaVersionForSystemPackages.substring(dotIndex + 1);\n                final int firstNumber = Integer.parseInt(prefix);\n                final int secondNumber = Integer.parseInt(suffix);\n                if (firstNumber >= 9) {\n                    generatedResult = String.format(\"0.0.0.JavaSE_%03d\", firstNumber);  // Assuming Java 9+\n                } else {\n                    generatedResult = String.format(\"0.0.0.JavaSE_001_%03d\", secondNumber);  // Assuming Java 8 or earlier\n                }\n                return generatedResult;\n            } catch (Exception ex) {\n                throw new IllegalArgumentException(\"Cannot parse Java version string (probable non-numeric start)\", ex);\n            }\n        } else {\n                throw new IllegalArgumentException(\"Cannot parse Java version from a system packages string missing or starting with a '.'\");\n        }\n    }\n}\n"}
{"test_method": "@Test\n\tpublic void testSanitizeInputPathShouldAllowSimpleParameter() throws Exception {\n\t\tassertEquals(\"foo\", fileDownloadAction.sanitizeInputPath(\"foo\"));\n\t}", "focal_method": "String sanitizeInputPath( String value ) {\n\t\tif (value != null && value.toUpperCase().contains(\"WEB-INF\")) {\n\t\t\treturn null;\n\t\t}\n\t\treturn value;\n\t}", "test_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.showcase.filedownload;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static junit.framework.Assert.assertEquals;\nimport static junit.framework.Assert.assertNull;\n\npublic class FileDownloadActionTest {\n\n\tprivate FileDownloadAction fileDownloadAction;\n\n\t@Before\n\tpublic void setUp() {\n\t    this.fileDownloadAction = new FileDownloadAction();\n\t}\n\n\t@Test\n\tpublic void testSanitizeInputPathShouldAllowSimpleParameter() throws Exception {\n\t\tassertEquals(\"foo\", fileDownloadAction.sanitizeInputPath(\"foo\"));\n\t}\n\n\t@Test\n\tpublic void testSanitizeInputPathShouldReturnNullForNullInput() throws Exception {\n\t\tassertNull(fileDownloadAction.sanitizeInputPath(null));\n\t}\n\n\t@Test\n\tpublic void testSanitizeInputPathShouldReturnNullForLeadingWebInf() throws Exception {\n\t\tassertNull(fileDownloadAction.sanitizeInputPath(\"WEB-INF/foo\"));\n\t}\n\n\t@Test\n\tpublic void testSanitizeInputPathShouldReturnNullForNonLeadingWebInf() throws Exception {\n\t\tassertNull(fileDownloadAction.sanitizeInputPath(\"./WEB-INF/foo\"));\n\t}\n\n\t@Test\n\tpublic void testSanitizeInputPathShouldReturnNullForNonUppercaseWebInf() throws Exception {\n\t\tassertNull(fileDownloadAction.sanitizeInputPath(\"./wEB-Inf/foo\"));\n\t}\n}\n", "focal_file": "/*\n * $Id$\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.showcase.filedownload;\n\nimport com.opensymphony.xwork2.Action;\nimport org.apache.struts2.ServletActionContext;\n\nimport java.io.InputStream;\n\n/**\n * Demonstrates file resource download.\n * Set filePath to the local file resource to download,\n * relative to the application root (\"/images/struts.gif\").\n */\npublic class FileDownloadAction implements Action {\n\n\tprivate String inputPath;\n\n\tpublic String execute() throws Exception {\n\t\treturn SUCCESS;\n\t}\n\n\tpublic void setInputPath(String value) {\n\t\tinputPath = sanitizeInputPath(value);\n\t}\n\n\t/**\n\t * As the user modifiable parameter inputPath will be used to access server side resources, we want the path to be\n\t * sanitized - in this case it is demonstrated to disallow inputPath parameter values containing \"WEB-INF\". Consider to\n\t * use even stricter rules in production environments.\n\t *\n\t * @param value the raw parameter input value to sanitize\n\t *\n\t * @return the sanitized value; <tt>null</tt> if value contains an invalid path segment like WEB-INF\n\t */\n\tString sanitizeInputPath( String value ) {\n\t\tif (value != null && value.toUpperCase().contains(\"WEB-INF\")) {\n\t\t\treturn null;\n\t\t}\n\t\treturn value;\n\t}\n\n\tpublic InputStream getInputStream() throws Exception {\n\t\treturn ServletActionContext.getServletContext().getResourceAsStream(inputPath);\n\t}\n}\n"}
{"test_method": "@Test\n\tpublic void testSanitizeInputPathShouldReturnNullForNonUppercaseWebInf() throws Exception {\n\t\tassertNull(fileDownloadAction.sanitizeInputPath(\"./wEB-Inf/foo\"));\n\t}", "focal_method": "String sanitizeInputPath( String value ) {\n\t\tif (value != null && value.toUpperCase().contains(\"WEB-INF\")) {\n\t\t\treturn null;\n\t\t}\n\t\treturn value;\n\t}", "test_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.showcase.filedownload;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static junit.framework.Assert.assertEquals;\nimport static junit.framework.Assert.assertNull;\n\npublic class FileDownloadActionTest {\n\n\tprivate FileDownloadAction fileDownloadAction;\n\n\t@Before\n\tpublic void setUp() {\n\t    this.fileDownloadAction = new FileDownloadAction();\n\t}\n\n\t@Test\n\tpublic void testSanitizeInputPathShouldAllowSimpleParameter() throws Exception {\n\t\tassertEquals(\"foo\", fileDownloadAction.sanitizeInputPath(\"foo\"));\n\t}\n\n\t@Test\n\tpublic void testSanitizeInputPathShouldReturnNullForNullInput() throws Exception {\n\t\tassertNull(fileDownloadAction.sanitizeInputPath(null));\n\t}\n\n\t@Test\n\tpublic void testSanitizeInputPathShouldReturnNullForLeadingWebInf() throws Exception {\n\t\tassertNull(fileDownloadAction.sanitizeInputPath(\"WEB-INF/foo\"));\n\t}\n\n\t@Test\n\tpublic void testSanitizeInputPathShouldReturnNullForNonLeadingWebInf() throws Exception {\n\t\tassertNull(fileDownloadAction.sanitizeInputPath(\"./WEB-INF/foo\"));\n\t}\n\n\t@Test\n\tpublic void testSanitizeInputPathShouldReturnNullForNonUppercaseWebInf() throws Exception {\n\t\tassertNull(fileDownloadAction.sanitizeInputPath(\"./wEB-Inf/foo\"));\n\t}\n}\n", "focal_file": "/*\n * $Id$\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.showcase.filedownload;\n\nimport com.opensymphony.xwork2.Action;\nimport org.apache.struts2.ServletActionContext;\n\nimport java.io.InputStream;\n\n/**\n * Demonstrates file resource download.\n * Set filePath to the local file resource to download,\n * relative to the application root (\"/images/struts.gif\").\n */\npublic class FileDownloadAction implements Action {\n\n\tprivate String inputPath;\n\n\tpublic String execute() throws Exception {\n\t\treturn SUCCESS;\n\t}\n\n\tpublic void setInputPath(String value) {\n\t\tinputPath = sanitizeInputPath(value);\n\t}\n\n\t/**\n\t * As the user modifiable parameter inputPath will be used to access server side resources, we want the path to be\n\t * sanitized - in this case it is demonstrated to disallow inputPath parameter values containing \"WEB-INF\". Consider to\n\t * use even stricter rules in production environments.\n\t *\n\t * @param value the raw parameter input value to sanitize\n\t *\n\t * @return the sanitized value; <tt>null</tt> if value contains an invalid path segment like WEB-INF\n\t */\n\tString sanitizeInputPath( String value ) {\n\t\tif (value != null && value.toUpperCase().contains(\"WEB-INF\")) {\n\t\t\treturn null;\n\t\t}\n\t\treturn value;\n\t}\n\n\tpublic InputStream getInputStream() throws Exception {\n\t\treturn ServletActionContext.getServletContext().getResourceAsStream(inputPath);\n\t}\n}\n"}
{"test_method": "@Test\n    public void testGenerateJavaVersionForSystemPackages() {\n        // Some test patterns copied from OgnlRuntimeTest.testMajorJavaVersionParse() in OGNL 3.2.x.\n        // Pre-JDK 9 version strings.\n        Assert.assertEquals(\"JDK 5 generate java version failed ?\", \"1.5\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.5\"));\n        Assert.assertEquals(\"JDK 5 generate java version failed ?\", \"1.5\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.5.0\"));\n        Assert.assertEquals(\"JDK 5 generate java version failed ?\", \"1.5\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.5.0_21-b11\"));\n        Assert.assertEquals(\"JDK 6 generate java version failed ?\", \"1.6\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.6\"));\n        Assert.assertEquals(\"JDK 6 generate java version failed ?\", \"1.6\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.6.0\"));\n        Assert.assertEquals(\"JDK 6 generate java version failed ?\", \"1.6\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.6.0_43-b19\"));\n        Assert.assertEquals(\"JDK 7 generate java version failed ?\", \"1.7\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.7\"));\n        Assert.assertEquals(\"JDK 7 generate java version failed ?\", \"1.7\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.7.0\"));\n        Assert.assertEquals(\"JDK 7 generate java version failed ?\", \"1.7\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.7.0_79-b15\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"1.8\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.8\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"1.8\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.8.0\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"1.8\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.8.0_201-b20\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"1.8\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.8.0-someopenjdkstyle\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"1.8\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.8.0_201-someopenjdkstyle\"));\n        // JDK 9 and later version strings.\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"9.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"9\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"9.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"9-ea+19\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"9.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"9+100\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"9.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"9-ea+19\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"9.1\", OsgiUtil.generateJavaVersionForSystemPackages(\"9.1.3+15\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"9.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"9-someopenjdkstyle\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"10.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"10\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"10.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"10-ea+11\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"10.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"10+10\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"10.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"10-ea+11\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"10.1\", OsgiUtil.generateJavaVersionForSystemPackages(\"10.1.3+15\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"10.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"10-someopenjdkstyle\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"11.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"11\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"11.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"11-ea+22\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"11.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"11+33\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"11.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"11-ea+19\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"11.1\", OsgiUtil.generateJavaVersionForSystemPackages(\"11.1.3+15\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"11.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"11-someopenjdkstyle\"));\n    }", "focal_method": "public static String generateJavaVersionForSystemPackages(String systemJavaVersion) {\n        if (systemJavaVersion == null || systemJavaVersion.isEmpty()) {\n            throw new IllegalArgumentException(\"Cannot parse Java version from null or empty string\");\n        } else {\n            String parsedResult;\n            final int dotIndex1 = systemJavaVersion.indexOf('.');\n            final int dotIndex2 = (dotIndex1 > 0 ? systemJavaVersion.indexOf('.', dotIndex1 + 1) : -1);\n            if (dotIndex1 > 0 && dotIndex2 > 0) {\n                parsedResult = systemJavaVersion.substring(0, dotIndex2);  // Assuming Java 8 or older style, or Java 9+ with a minor or security update.\n            } else if (dotIndex1 > 0) {\n                parsedResult = systemJavaVersion;  // Assuming a truncated Java 8 or older style, or Java 9+ with a minor or security update.\n            } else if (dotIndex1 == -1) {\n                final int minusIndex = systemJavaVersion.indexOf('-');\n                final int plusIndex = systemJavaVersion.indexOf('+');\n                if (minusIndex > 0) {\n                    parsedResult = systemJavaVersion.substring(0, minusIndex);  // Assuming Java 9+ early-access\n                } else if (plusIndex > 0) {\n                    parsedResult = systemJavaVersion.substring(0, plusIndex);  // Assuming Java 9+ java.runime.version or java.vm.version string\n                } else {\n                    parsedResult = systemJavaVersion;\n                }\n                try {\n                    final int firstNumber = Integer.parseInt(parsedResult);\n                    if (firstNumber >= 9) {\n                        parsedResult = parsedResult + \".0\";  // Assuming Java 9+ and no minor or security update, append standard value.\n                    } else {\n                        throw new IllegalArgumentException(\"Single digit Java version string less than 9 (nonsense)\");\n                    }\n                } catch (Exception ex) {\n                    throw new IllegalArgumentException(\"Cannot parse Java version string (probable non-numeric start)\", ex);\n                }\n            } else {\n                throw new IllegalArgumentException(\"Cannot parse Java version from a string starting with a '.'\");\n            }\n            return parsedResult;\n        }\n    }", "test_file": "/*\n * Copyright 2020 Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.struts2.osgi;\n\nimport org.junit.Assert;\nimport org.junit.Test;\n\n/**\n *  Basic tests for OsgiUtil\n */\npublic class OsgiUtilTest  {\n\n    /*\n     * An independent unit test for OsgiUtil.translateBundleURLToJarURL() would be nice, but appears\n     * complicated to do without either creating and installing a custom URL handler or using\n     * one of the Mock frameworks that can mock final classes like URL.\n     */\n\n    @Test\n    public void testGetBean() {\n        MockBeanFactory mockBeanFactory = new MockBeanFactory();\n\n        Object mockBean = OsgiUtil.getBean(mockBeanFactory, \"1000\");\n        Assert.assertNotNull(\"OsgiUtil getBean() on mock bean factory returned null ?\", mockBean);\n        Assert.assertTrue(\"Mock bean from mock bean factory has mismatched id ?\", mockBeanFactory.beanMatchesId(mockBean, \"1000\"));\n\n        mockBean = OsgiUtil.getBean(new Object(), \"1000\");  // Logs an error (coverage only).\n        Assert.assertNull(\"OsgiUtil getBean() on normal object found a getBean() method ?\", mockBean);\n    }\n\n    @Test\n    public void testContainsBean() {\n        MockBeanFactory mockBeanFactory = new MockBeanFactory();\n\n        Assert.assertTrue(\"OsgiUtil containsBean() on mock bean factory with numeric id is false ?\", OsgiUtil.containsBean(mockBeanFactory, \"1000\"));\n        Assert.assertFalse(\"OsgiUtil containsBean() on mock bean factory with nonnumeric id is true ?\", OsgiUtil.containsBean(mockBeanFactory, \"NotANumber\"));\n        Assert.assertFalse(\"OsgiUtil containsBean() on mock bean factory with null id is true ?\", OsgiUtil.containsBean(mockBeanFactory, null));\n    }\n\n    @Test\n    public void testGenerateJavaVersionForSystemPackages() {\n        // Some test patterns copied from OgnlRuntimeTest.testMajorJavaVersionParse() in OGNL 3.2.x.\n        // Pre-JDK 9 version strings.\n        Assert.assertEquals(\"JDK 5 generate java version failed ?\", \"1.5\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.5\"));\n        Assert.assertEquals(\"JDK 5 generate java version failed ?\", \"1.5\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.5.0\"));\n        Assert.assertEquals(\"JDK 5 generate java version failed ?\", \"1.5\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.5.0_21-b11\"));\n        Assert.assertEquals(\"JDK 6 generate java version failed ?\", \"1.6\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.6\"));\n        Assert.assertEquals(\"JDK 6 generate java version failed ?\", \"1.6\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.6.0\"));\n        Assert.assertEquals(\"JDK 6 generate java version failed ?\", \"1.6\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.6.0_43-b19\"));\n        Assert.assertEquals(\"JDK 7 generate java version failed ?\", \"1.7\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.7\"));\n        Assert.assertEquals(\"JDK 7 generate java version failed ?\", \"1.7\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.7.0\"));\n        Assert.assertEquals(\"JDK 7 generate java version failed ?\", \"1.7\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.7.0_79-b15\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"1.8\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.8\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"1.8\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.8.0\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"1.8\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.8.0_201-b20\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"1.8\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.8.0-someopenjdkstyle\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"1.8\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.8.0_201-someopenjdkstyle\"));\n        // JDK 9 and later version strings.\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"9.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"9\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"9.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"9-ea+19\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"9.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"9+100\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"9.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"9-ea+19\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"9.1\", OsgiUtil.generateJavaVersionForSystemPackages(\"9.1.3+15\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"9.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"9-someopenjdkstyle\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"10.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"10\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"10.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"10-ea+11\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"10.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"10+10\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"10.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"10-ea+11\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"10.1\", OsgiUtil.generateJavaVersionForSystemPackages(\"10.1.3+15\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"10.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"10-someopenjdkstyle\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"11.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"11\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"11.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"11-ea+22\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"11.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"11+33\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"11.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"11-ea+19\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"11.1\", OsgiUtil.generateJavaVersionForSystemPackages(\"11.1.3+15\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"11.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"11-someopenjdkstyle\"));\n    }\n\n    @Test\n    public void testGenerateJava_SE_SystemPackageVersionString() {\n        // Some test patterns copied from OgnlRuntimeTest.testMajorJavaVersionParse() in OGNL 3.2.x.\n        // Pre-JDK 9 version strings.\n        Assert.assertEquals(\"JDK 5 generate java version failed ?\", \"0.0.0.JavaSE_001_005\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.5\"));\n        Assert.assertEquals(\"JDK 5 generate java version failed ?\", \"0.0.0.JavaSE_001_005\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.5.0\"));\n        Assert.assertEquals(\"JDK 5 generate java version failed ?\", \"0.0.0.JavaSE_001_005\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.5.0_21-b11\"));\n        Assert.assertEquals(\"JDK 6 generate java version failed ?\", \"0.0.0.JavaSE_001_006\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.6\"));\n        Assert.assertEquals(\"JDK 6 generate java version failed ?\", \"0.0.0.JavaSE_001_006\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.6.0\"));\n        Assert.assertEquals(\"JDK 6 generate java version failed ?\", \"0.0.0.JavaSE_001_006\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.6.0_43-b19\"));\n        Assert.assertEquals(\"JDK 7 generate java version failed ?\", \"0.0.0.JavaSE_001_007\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.7\"));\n        Assert.assertEquals(\"JDK 7 generate java version failed ?\", \"0.0.0.JavaSE_001_007\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.7.0\"));\n        Assert.assertEquals(\"JDK 7 generate java version failed ?\", \"0.0.0.JavaSE_001_007\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.7.0_79-b15\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"0.0.0.JavaSE_001_008\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.8\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"0.0.0.JavaSE_001_008\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.8.0\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"0.0.0.JavaSE_001_008\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.8.0_201-b20\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"0.0.0.JavaSE_001_008\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.8.0-someopenjdkstyle\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"0.0.0.JavaSE_001_008\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.8.0_201-someopenjdkstyle\"));\n        // JDK 9 and later version strings.\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"0.0.0.JavaSE_009\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"9\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"0.0.0.JavaSE_009\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"9-ea+19\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"0.0.0.JavaSE_009\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"9+100\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"0.0.0.JavaSE_009\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"9-ea+19\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"0.0.0.JavaSE_009\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"9.1.3+15\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"0.0.0.JavaSE_009\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"9-someopenjdkstyle\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"0.0.0.JavaSE_010\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"10\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"0.0.0.JavaSE_010\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"10-ea+11\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"0.0.0.JavaSE_010\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"10+10\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"0.0.0.JavaSE_010\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"10-ea+11\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"0.0.0.JavaSE_010\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"10.1.3+15\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"0.0.0.JavaSE_010\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"10-someopenjdkstyle\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"0.0.0.JavaSE_011\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"11\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"0.0.0.JavaSE_011\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"11-ea+22\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"0.0.0.JavaSE_011\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"11+33\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"0.0.0.JavaSE_011\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"11-ea+19\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"0.0.0.JavaSE_011\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"11.1.3+15\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"0.0.0.JavaSE_011\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"11-someopenjdkstyle\"));\n    }\n\n    private class MockBeanFactory {\n\n        public Object getBean(String beanId) {\n            return \"MockBean: \" + beanId;\n        }\n\n        public boolean containsBean(String beanId) {\n            boolean result = false;\n\n            if (beanId != null) {\n                try {\n                    Integer.parseInt(beanId);\n                    result = true;\n                } catch (NumberFormatException nfe) {\n                    result = false;\n                }\n            }\n\n            return result;\n        }\n\n        public final boolean beanMatchesId(Object mockBean, String beanId) {\n            return mockBean.equals(\"MockBean: \" + beanId);\n        }\n\n    }\n\n}\n", "focal_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.osgi;\n\nimport org.apache.logging.log4j.Logger;\nimport org.apache.logging.log4j.LogManager;\nimport org.osgi.framework.Bundle;\n\nimport java.lang.reflect.Method;\nimport java.net.MalformedURLException;\nimport java.net.URL;\n\npublic class OsgiUtil {\n\n    private static final Logger LOG = LogManager.getLogger(OsgiUtil.class);\n\n    /**\n     * A bundle is a jar, and a bundle URL will be useless to clients, this method translates\n     * a URL to a resource inside a bundle from \"bundle:something/path\" to \"jar:file:bundlelocation!/path\"\n     *\n     * @param bundleUrl URL to translate\n     * @param bundle the bundle\n     *\n     * @return translated URL\n     *\n     * @throws MalformedURLException if URL is malformed\n     */\n    public static URL translateBundleURLToJarURL(URL bundleUrl, Bundle bundle) throws MalformedURLException {\n        if (bundleUrl != null && \"bundle\".equalsIgnoreCase(bundleUrl.getProtocol())) {\n            StringBuilder sb = new StringBuilder(\"jar:\");\n            sb.append(bundle.getLocation());\n            sb.append(\"!\");\n            sb.append(bundleUrl.getFile());\n            return new URL(sb.toString());\n        }\n\n        return bundleUrl;\n    }\n\n    /**\n     * Calls getBean() on the passed object using reflection. Used on Spring context\n     * because they are loaded from bundles (in another class loader)\n     *\n     * @param beanFactory bean factory\n     * @param beanId id of bean\n     *\n     * @return the object found\n     */\n    public static Object getBean(Object beanFactory, String beanId) {\n        try {\n            Method getBeanMethod = beanFactory.getClass().getMethod(\"getBean\", String.class);\n            return getBeanMethod.invoke(beanFactory, beanId);\n        } catch (Exception ex) {\n            LOG.error(\"Unable to call getBean() on object of type [{}], with bean id [{}]\",  beanFactory.getClass().getName(), beanId, ex);\n        }\n\n        return null;\n    }\n\n    /**\n     * Calls containsBean on the passed object using reflection. Used on Spring context\n     * because they are loaded from bundles (in another class loader)\n     *\n     * @param beanFactory bean factory\n     * @param beanId id of bean\n     *\n     * @return true if bean factory contains bean with bean id\n     */\n    public static boolean containsBean(Object beanFactory, String beanId) {\n        try {\n            Method getBeanMethod = beanFactory.getClass().getMethod(\"containsBean\", String.class);\n            return (Boolean) getBeanMethod.invoke(beanFactory, beanId);\n        } catch (Exception ex) {\n            LOG.error(\"Unable to call containsBean() on object of type [{}], with bean id [{}]\", beanFactory.getClass().getName(), beanId, ex);\n        }\n\n        return false;\n    }\n\n    /**\n     * Attempt to generate an OSGi compatible Java version String from the System \"java.version\" property,\n     * with the form (where x is the major version number): 1.x for Java 8 and earlier, x.y for Java 9+.\n     * See <a href=\"https://openjdk.java.net/jeps/223\">JEP 223: New Version-String Scheme</a> for details\n     * on version naming changes.\n     * \n     * @param systemJavaVersion a Java version string from System.getProperty(\"java.version\") or equivalent.\n     * @return a String of the form (where x is the major version number): 1.x for Java 8 and earlier, x.y for Java 9+.\n     */\n    public static String generateJavaVersionForSystemPackages(String systemJavaVersion) {\n        if (systemJavaVersion == null || systemJavaVersion.isEmpty()) {\n            throw new IllegalArgumentException(\"Cannot parse Java version from null or empty string\");\n        } else {\n            String parsedResult;\n            final int dotIndex1 = systemJavaVersion.indexOf('.');\n            final int dotIndex2 = (dotIndex1 > 0 ? systemJavaVersion.indexOf('.', dotIndex1 + 1) : -1);\n            if (dotIndex1 > 0 && dotIndex2 > 0) {\n                parsedResult = systemJavaVersion.substring(0, dotIndex2);  // Assuming Java 8 or older style, or Java 9+ with a minor or security update.\n            } else if (dotIndex1 > 0) {\n                parsedResult = systemJavaVersion;  // Assuming a truncated Java 8 or older style, or Java 9+ with a minor or security update.\n            } else if (dotIndex1 == -1) {\n                final int minusIndex = systemJavaVersion.indexOf('-');\n                final int plusIndex = systemJavaVersion.indexOf('+');\n                if (minusIndex > 0) {\n                    parsedResult = systemJavaVersion.substring(0, minusIndex);  // Assuming Java 9+ early-access\n                } else if (plusIndex > 0) {\n                    parsedResult = systemJavaVersion.substring(0, plusIndex);  // Assuming Java 9+ java.runime.version or java.vm.version string\n                } else {\n                    parsedResult = systemJavaVersion;\n                }\n                try {\n                    final int firstNumber = Integer.parseInt(parsedResult);\n                    if (firstNumber >= 9) {\n                        parsedResult = parsedResult + \".0\";  // Assuming Java 9+ and no minor or security update, append standard value.\n                    } else {\n                        throw new IllegalArgumentException(\"Single digit Java version string less than 9 (nonsense)\");\n                    }\n                } catch (Exception ex) {\n                    throw new IllegalArgumentException(\"Cannot parse Java version string (probable non-numeric start)\", ex);\n                }\n            } else {\n                throw new IllegalArgumentException(\"Cannot parse Java version from a string starting with a '.'\");\n            }\n            return parsedResult;\n        }\n    }\n\n    /**\n     * Attempt to generate an OSGi compatible Java SE system package version String from the System \"java.version\" property,\n     * with the form (where x or xx is the major version number): 0.0.0.JavaSE_001_00x for Java 8 and earlier (e.g. 0.0.0.JavaSE_001_008),\n     * 0.0.0.JavaSE_0xx for Java 9+ (e.g. 0.0.0.JavaSE_009 for Java 9, 0.0.0.JavaSE_011 for Java 11).\n     * \n     * @param systemJavaVersion a Java version string from System.getProperty(\"java.version\") or equivalent.\n     * @return a String of the form (where x or xx is the major version number): JavaSE_001_00x for Java 8 and earlier, JavaSE_0xx for Java 9+.\n     */\n    public static String generateJava_SE_SystemPackageVersionString(String systemJavaVersion) {\n        final String javaVersionForSystemPackages = generateJavaVersionForSystemPackages(systemJavaVersion);\n        final int dotIndex = javaVersionForSystemPackages.indexOf('.');\n        if (dotIndex > 0) {\n            final String generatedResult;\n            try {\n                final String prefix = javaVersionForSystemPackages.substring(0, dotIndex);\n                final String suffix = javaVersionForSystemPackages.substring(dotIndex + 1);\n                final int firstNumber = Integer.parseInt(prefix);\n                final int secondNumber = Integer.parseInt(suffix);\n                if (firstNumber >= 9) {\n                    generatedResult = String.format(\"0.0.0.JavaSE_%03d\", firstNumber);  // Assuming Java 9+\n                } else {\n                    generatedResult = String.format(\"0.0.0.JavaSE_001_%03d\", secondNumber);  // Assuming Java 8 or earlier\n                }\n                return generatedResult;\n            } catch (Exception ex) {\n                throw new IllegalArgumentException(\"Cannot parse Java version string (probable non-numeric start)\", ex);\n            }\n        } else {\n                throw new IllegalArgumentException(\"Cannot parse Java version from a system packages string missing or starting with a '.'\");\n        }\n    }\n}\n"}
{"test_method": "@Test\n    public void testGenerateJava_SE_SystemPackageVersionString() {\n        // Some test patterns copied from OgnlRuntimeTest.testMajorJavaVersionParse() in OGNL 3.2.x.\n        // Pre-JDK 9 version strings.\n        Assert.assertEquals(\"JDK 5 generate java version failed ?\", \"0.0.0.JavaSE_001_005\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.5\"));\n        Assert.assertEquals(\"JDK 5 generate java version failed ?\", \"0.0.0.JavaSE_001_005\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.5.0\"));\n        Assert.assertEquals(\"JDK 5 generate java version failed ?\", \"0.0.0.JavaSE_001_005\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.5.0_21-b11\"));\n        Assert.assertEquals(\"JDK 6 generate java version failed ?\", \"0.0.0.JavaSE_001_006\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.6\"));\n        Assert.assertEquals(\"JDK 6 generate java version failed ?\", \"0.0.0.JavaSE_001_006\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.6.0\"));\n        Assert.assertEquals(\"JDK 6 generate java version failed ?\", \"0.0.0.JavaSE_001_006\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.6.0_43-b19\"));\n        Assert.assertEquals(\"JDK 7 generate java version failed ?\", \"0.0.0.JavaSE_001_007\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.7\"));\n        Assert.assertEquals(\"JDK 7 generate java version failed ?\", \"0.0.0.JavaSE_001_007\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.7.0\"));\n        Assert.assertEquals(\"JDK 7 generate java version failed ?\", \"0.0.0.JavaSE_001_007\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.7.0_79-b15\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"0.0.0.JavaSE_001_008\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.8\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"0.0.0.JavaSE_001_008\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.8.0\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"0.0.0.JavaSE_001_008\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.8.0_201-b20\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"0.0.0.JavaSE_001_008\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.8.0-someopenjdkstyle\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"0.0.0.JavaSE_001_008\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.8.0_201-someopenjdkstyle\"));\n        // JDK 9 and later version strings.\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"0.0.0.JavaSE_009\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"9\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"0.0.0.JavaSE_009\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"9-ea+19\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"0.0.0.JavaSE_009\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"9+100\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"0.0.0.JavaSE_009\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"9-ea+19\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"0.0.0.JavaSE_009\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"9.1.3+15\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"0.0.0.JavaSE_009\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"9-someopenjdkstyle\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"0.0.0.JavaSE_010\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"10\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"0.0.0.JavaSE_010\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"10-ea+11\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"0.0.0.JavaSE_010\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"10+10\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"0.0.0.JavaSE_010\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"10-ea+11\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"0.0.0.JavaSE_010\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"10.1.3+15\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"0.0.0.JavaSE_010\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"10-someopenjdkstyle\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"0.0.0.JavaSE_011\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"11\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"0.0.0.JavaSE_011\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"11-ea+22\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"0.0.0.JavaSE_011\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"11+33\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"0.0.0.JavaSE_011\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"11-ea+19\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"0.0.0.JavaSE_011\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"11.1.3+15\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"0.0.0.JavaSE_011\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"11-someopenjdkstyle\"));\n    }", "focal_method": "public static String generateJava_SE_SystemPackageVersionString(String systemJavaVersion) {\n        final String javaVersionForSystemPackages = generateJavaVersionForSystemPackages(systemJavaVersion);\n        final int dotIndex = javaVersionForSystemPackages.indexOf('.');\n        if (dotIndex > 0) {\n            final String generatedResult;\n            try {\n                final String prefix = javaVersionForSystemPackages.substring(0, dotIndex);\n                final String suffix = javaVersionForSystemPackages.substring(dotIndex + 1);\n                final int firstNumber = Integer.parseInt(prefix);\n                final int secondNumber = Integer.parseInt(suffix);\n                if (firstNumber >= 9) {\n                    generatedResult = String.format(\"0.0.0.JavaSE_%03d\", firstNumber);  // Assuming Java 9+\n                } else {\n                    generatedResult = String.format(\"0.0.0.JavaSE_001_%03d\", secondNumber);  // Assuming Java 8 or earlier\n                }\n                return generatedResult;\n            } catch (Exception ex) {\n                throw new IllegalArgumentException(\"Cannot parse Java version string (probable non-numeric start)\", ex);\n            }\n        } else {\n                throw new IllegalArgumentException(\"Cannot parse Java version from a system packages string missing or starting with a '.'\");\n        }\n    }", "test_file": "/*\n * Copyright 2020 Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.struts2.osgi;\n\nimport org.junit.Assert;\nimport org.junit.Test;\n\n/**\n *  Basic tests for OsgiUtil\n */\npublic class OsgiUtilTest  {\n\n    /*\n     * An independent unit test for OsgiUtil.translateBundleURLToJarURL() would be nice, but appears\n     * complicated to do without either creating and installing a custom URL handler or using\n     * one of the Mock frameworks that can mock final classes like URL.\n     */\n\n    @Test\n    public void testGetBean() {\n        MockBeanFactory mockBeanFactory = new MockBeanFactory();\n\n        Object mockBean = OsgiUtil.getBean(mockBeanFactory, \"1000\");\n        Assert.assertNotNull(\"OsgiUtil getBean() on mock bean factory returned null ?\", mockBean);\n        Assert.assertTrue(\"Mock bean from mock bean factory has mismatched id ?\", mockBeanFactory.beanMatchesId(mockBean, \"1000\"));\n\n        mockBean = OsgiUtil.getBean(new Object(), \"1000\");  // Logs an error (coverage only).\n        Assert.assertNull(\"OsgiUtil getBean() on normal object found a getBean() method ?\", mockBean);\n    }\n\n    @Test\n    public void testContainsBean() {\n        MockBeanFactory mockBeanFactory = new MockBeanFactory();\n\n        Assert.assertTrue(\"OsgiUtil containsBean() on mock bean factory with numeric id is false ?\", OsgiUtil.containsBean(mockBeanFactory, \"1000\"));\n        Assert.assertFalse(\"OsgiUtil containsBean() on mock bean factory with nonnumeric id is true ?\", OsgiUtil.containsBean(mockBeanFactory, \"NotANumber\"));\n        Assert.assertFalse(\"OsgiUtil containsBean() on mock bean factory with null id is true ?\", OsgiUtil.containsBean(mockBeanFactory, null));\n    }\n\n    @Test\n    public void testGenerateJavaVersionForSystemPackages() {\n        // Some test patterns copied from OgnlRuntimeTest.testMajorJavaVersionParse() in OGNL 3.2.x.\n        // Pre-JDK 9 version strings.\n        Assert.assertEquals(\"JDK 5 generate java version failed ?\", \"1.5\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.5\"));\n        Assert.assertEquals(\"JDK 5 generate java version failed ?\", \"1.5\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.5.0\"));\n        Assert.assertEquals(\"JDK 5 generate java version failed ?\", \"1.5\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.5.0_21-b11\"));\n        Assert.assertEquals(\"JDK 6 generate java version failed ?\", \"1.6\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.6\"));\n        Assert.assertEquals(\"JDK 6 generate java version failed ?\", \"1.6\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.6.0\"));\n        Assert.assertEquals(\"JDK 6 generate java version failed ?\", \"1.6\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.6.0_43-b19\"));\n        Assert.assertEquals(\"JDK 7 generate java version failed ?\", \"1.7\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.7\"));\n        Assert.assertEquals(\"JDK 7 generate java version failed ?\", \"1.7\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.7.0\"));\n        Assert.assertEquals(\"JDK 7 generate java version failed ?\", \"1.7\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.7.0_79-b15\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"1.8\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.8\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"1.8\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.8.0\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"1.8\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.8.0_201-b20\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"1.8\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.8.0-someopenjdkstyle\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"1.8\", OsgiUtil.generateJavaVersionForSystemPackages(\"1.8.0_201-someopenjdkstyle\"));\n        // JDK 9 and later version strings.\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"9.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"9\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"9.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"9-ea+19\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"9.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"9+100\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"9.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"9-ea+19\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"9.1\", OsgiUtil.generateJavaVersionForSystemPackages(\"9.1.3+15\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"9.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"9-someopenjdkstyle\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"10.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"10\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"10.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"10-ea+11\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"10.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"10+10\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"10.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"10-ea+11\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"10.1\", OsgiUtil.generateJavaVersionForSystemPackages(\"10.1.3+15\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"10.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"10-someopenjdkstyle\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"11.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"11\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"11.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"11-ea+22\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"11.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"11+33\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"11.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"11-ea+19\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"11.1\", OsgiUtil.generateJavaVersionForSystemPackages(\"11.1.3+15\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"11.0\", OsgiUtil.generateJavaVersionForSystemPackages(\"11-someopenjdkstyle\"));\n    }\n\n    @Test\n    public void testGenerateJava_SE_SystemPackageVersionString() {\n        // Some test patterns copied from OgnlRuntimeTest.testMajorJavaVersionParse() in OGNL 3.2.x.\n        // Pre-JDK 9 version strings.\n        Assert.assertEquals(\"JDK 5 generate java version failed ?\", \"0.0.0.JavaSE_001_005\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.5\"));\n        Assert.assertEquals(\"JDK 5 generate java version failed ?\", \"0.0.0.JavaSE_001_005\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.5.0\"));\n        Assert.assertEquals(\"JDK 5 generate java version failed ?\", \"0.0.0.JavaSE_001_005\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.5.0_21-b11\"));\n        Assert.assertEquals(\"JDK 6 generate java version failed ?\", \"0.0.0.JavaSE_001_006\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.6\"));\n        Assert.assertEquals(\"JDK 6 generate java version failed ?\", \"0.0.0.JavaSE_001_006\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.6.0\"));\n        Assert.assertEquals(\"JDK 6 generate java version failed ?\", \"0.0.0.JavaSE_001_006\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.6.0_43-b19\"));\n        Assert.assertEquals(\"JDK 7 generate java version failed ?\", \"0.0.0.JavaSE_001_007\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.7\"));\n        Assert.assertEquals(\"JDK 7 generate java version failed ?\", \"0.0.0.JavaSE_001_007\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.7.0\"));\n        Assert.assertEquals(\"JDK 7 generate java version failed ?\", \"0.0.0.JavaSE_001_007\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.7.0_79-b15\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"0.0.0.JavaSE_001_008\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.8\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"0.0.0.JavaSE_001_008\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.8.0\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"0.0.0.JavaSE_001_008\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.8.0_201-b20\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"0.0.0.JavaSE_001_008\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.8.0-someopenjdkstyle\"));\n        Assert.assertEquals(\"JDK 8 generate java version failed ?\", \"0.0.0.JavaSE_001_008\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"1.8.0_201-someopenjdkstyle\"));\n        // JDK 9 and later version strings.\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"0.0.0.JavaSE_009\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"9\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"0.0.0.JavaSE_009\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"9-ea+19\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"0.0.0.JavaSE_009\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"9+100\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"0.0.0.JavaSE_009\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"9-ea+19\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"0.0.0.JavaSE_009\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"9.1.3+15\"));\n        Assert.assertEquals(\"JDK 9 generate java version failed ?\", \"0.0.0.JavaSE_009\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"9-someopenjdkstyle\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"0.0.0.JavaSE_010\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"10\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"0.0.0.JavaSE_010\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"10-ea+11\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"0.0.0.JavaSE_010\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"10+10\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"0.0.0.JavaSE_010\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"10-ea+11\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"0.0.0.JavaSE_010\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"10.1.3+15\"));\n        Assert.assertEquals(\"JDK 10 generate java version failed ?\", \"0.0.0.JavaSE_010\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"10-someopenjdkstyle\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"0.0.0.JavaSE_011\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"11\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"0.0.0.JavaSE_011\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"11-ea+22\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"0.0.0.JavaSE_011\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"11+33\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"0.0.0.JavaSE_011\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"11-ea+19\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"0.0.0.JavaSE_011\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"11.1.3+15\"));\n        Assert.assertEquals(\"JDK 11 generate java version failed ?\", \"0.0.0.JavaSE_011\", OsgiUtil.generateJava_SE_SystemPackageVersionString(\"11-someopenjdkstyle\"));\n    }\n\n    private class MockBeanFactory {\n\n        public Object getBean(String beanId) {\n            return \"MockBean: \" + beanId;\n        }\n\n        public boolean containsBean(String beanId) {\n            boolean result = false;\n\n            if (beanId != null) {\n                try {\n                    Integer.parseInt(beanId);\n                    result = true;\n                } catch (NumberFormatException nfe) {\n                    result = false;\n                }\n            }\n\n            return result;\n        }\n\n        public final boolean beanMatchesId(Object mockBean, String beanId) {\n            return mockBean.equals(\"MockBean: \" + beanId);\n        }\n\n    }\n\n}\n", "focal_file": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.osgi;\n\nimport org.apache.logging.log4j.Logger;\nimport org.apache.logging.log4j.LogManager;\nimport org.osgi.framework.Bundle;\n\nimport java.lang.reflect.Method;\nimport java.net.MalformedURLException;\nimport java.net.URL;\n\npublic class OsgiUtil {\n\n    private static final Logger LOG = LogManager.getLogger(OsgiUtil.class);\n\n    /**\n     * A bundle is a jar, and a bundle URL will be useless to clients, this method translates\n     * a URL to a resource inside a bundle from \"bundle:something/path\" to \"jar:file:bundlelocation!/path\"\n     *\n     * @param bundleUrl URL to translate\n     * @param bundle the bundle\n     *\n     * @return translated URL\n     *\n     * @throws MalformedURLException if URL is malformed\n     */\n    public static URL translateBundleURLToJarURL(URL bundleUrl, Bundle bundle) throws MalformedURLException {\n        if (bundleUrl != null && \"bundle\".equalsIgnoreCase(bundleUrl.getProtocol())) {\n            StringBuilder sb = new StringBuilder(\"jar:\");\n            sb.append(bundle.getLocation());\n            sb.append(\"!\");\n            sb.append(bundleUrl.getFile());\n            return new URL(sb.toString());\n        }\n\n        return bundleUrl;\n    }\n\n    /**\n     * Calls getBean() on the passed object using reflection. Used on Spring context\n     * because they are loaded from bundles (in another class loader)\n     *\n     * @param beanFactory bean factory\n     * @param beanId id of bean\n     *\n     * @return the object found\n     */\n    public static Object getBean(Object beanFactory, String beanId) {\n        try {\n            Method getBeanMethod = beanFactory.getClass().getMethod(\"getBean\", String.class);\n            return getBeanMethod.invoke(beanFactory, beanId);\n        } catch (Exception ex) {\n            LOG.error(\"Unable to call getBean() on object of type [{}], with bean id [{}]\",  beanFactory.getClass().getName(), beanId, ex);\n        }\n\n        return null;\n    }\n\n    /**\n     * Calls containsBean on the passed object using reflection. Used on Spring context\n     * because they are loaded from bundles (in another class loader)\n     *\n     * @param beanFactory bean factory\n     * @param beanId id of bean\n     *\n     * @return true if bean factory contains bean with bean id\n     */\n    public static boolean containsBean(Object beanFactory, String beanId) {\n        try {\n            Method getBeanMethod = beanFactory.getClass().getMethod(\"containsBean\", String.class);\n            return (Boolean) getBeanMethod.invoke(beanFactory, beanId);\n        } catch (Exception ex) {\n            LOG.error(\"Unable to call containsBean() on object of type [{}], with bean id [{}]\", beanFactory.getClass().getName(), beanId, ex);\n        }\n\n        return false;\n    }\n\n    /**\n     * Attempt to generate an OSGi compatible Java version String from the System \"java.version\" property,\n     * with the form (where x is the major version number): 1.x for Java 8 and earlier, x.y for Java 9+.\n     * See <a href=\"https://openjdk.java.net/jeps/223\">JEP 223: New Version-String Scheme</a> for details\n     * on version naming changes.\n     * \n     * @param systemJavaVersion a Java version string from System.getProperty(\"java.version\") or equivalent.\n     * @return a String of the form (where x is the major version number): 1.x for Java 8 and earlier, x.y for Java 9+.\n     */\n    public static String generateJavaVersionForSystemPackages(String systemJavaVersion) {\n        if (systemJavaVersion == null || systemJavaVersion.isEmpty()) {\n            throw new IllegalArgumentException(\"Cannot parse Java version from null or empty string\");\n        } else {\n            String parsedResult;\n            final int dotIndex1 = systemJavaVersion.indexOf('.');\n            final int dotIndex2 = (dotIndex1 > 0 ? systemJavaVersion.indexOf('.', dotIndex1 + 1) : -1);\n            if (dotIndex1 > 0 && dotIndex2 > 0) {\n                parsedResult = systemJavaVersion.substring(0, dotIndex2);  // Assuming Java 8 or older style, or Java 9+ with a minor or security update.\n            } else if (dotIndex1 > 0) {\n                parsedResult = systemJavaVersion;  // Assuming a truncated Java 8 or older style, or Java 9+ with a minor or security update.\n            } else if (dotIndex1 == -1) {\n                final int minusIndex = systemJavaVersion.indexOf('-');\n                final int plusIndex = systemJavaVersion.indexOf('+');\n                if (minusIndex > 0) {\n                    parsedResult = systemJavaVersion.substring(0, minusIndex);  // Assuming Java 9+ early-access\n                } else if (plusIndex > 0) {\n                    parsedResult = systemJavaVersion.substring(0, plusIndex);  // Assuming Java 9+ java.runime.version or java.vm.version string\n                } else {\n                    parsedResult = systemJavaVersion;\n                }\n                try {\n                    final int firstNumber = Integer.parseInt(parsedResult);\n                    if (firstNumber >= 9) {\n                        parsedResult = parsedResult + \".0\";  // Assuming Java 9+ and no minor or security update, append standard value.\n                    } else {\n                        throw new IllegalArgumentException(\"Single digit Java version string less than 9 (nonsense)\");\n                    }\n                } catch (Exception ex) {\n                    throw new IllegalArgumentException(\"Cannot parse Java version string (probable non-numeric start)\", ex);\n                }\n            } else {\n                throw new IllegalArgumentException(\"Cannot parse Java version from a string starting with a '.'\");\n            }\n            return parsedResult;\n        }\n    }\n\n    /**\n     * Attempt to generate an OSGi compatible Java SE system package version String from the System \"java.version\" property,\n     * with the form (where x or xx is the major version number): 0.0.0.JavaSE_001_00x for Java 8 and earlier (e.g. 0.0.0.JavaSE_001_008),\n     * 0.0.0.JavaSE_0xx for Java 9+ (e.g. 0.0.0.JavaSE_009 for Java 9, 0.0.0.JavaSE_011 for Java 11).\n     * \n     * @param systemJavaVersion a Java version string from System.getProperty(\"java.version\") or equivalent.\n     * @return a String of the form (where x or xx is the major version number): JavaSE_001_00x for Java 8 and earlier, JavaSE_0xx for Java 9+.\n     */\n    public static String generateJava_SE_SystemPackageVersionString(String systemJavaVersion) {\n        final String javaVersionForSystemPackages = generateJavaVersionForSystemPackages(systemJavaVersion);\n        final int dotIndex = javaVersionForSystemPackages.indexOf('.');\n        if (dotIndex > 0) {\n            final String generatedResult;\n            try {\n                final String prefix = javaVersionForSystemPackages.substring(0, dotIndex);\n                final String suffix = javaVersionForSystemPackages.substring(dotIndex + 1);\n                final int firstNumber = Integer.parseInt(prefix);\n                final int secondNumber = Integer.parseInt(suffix);\n                if (firstNumber >= 9) {\n                    generatedResult = String.format(\"0.0.0.JavaSE_%03d\", firstNumber);  // Assuming Java 9+\n                } else {\n                    generatedResult = String.format(\"0.0.0.JavaSE_001_%03d\", secondNumber);  // Assuming Java 8 or earlier\n                }\n                return generatedResult;\n            } catch (Exception ex) {\n                throw new IllegalArgumentException(\"Cannot parse Java version string (probable non-numeric start)\", ex);\n            }\n        } else {\n                throw new IllegalArgumentException(\"Cannot parse Java version from a system packages string missing or starting with a '.'\");\n        }\n    }\n}\n"}
{"test_method": "@Test public void readFromSlowStreamWithLength() throws Exception {\n    assertThat(fullSlow.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }", "focal_method": "public byte[] read(Integer length) throws IOException {\n    if (length == null) {\n      return readToEof();\n    } else {\n      return readTo(length);\n    }\n  }", "test_file": "package com.squareup.rack;\n\nimport java.io.ByteArrayInputStream;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static java.util.Arrays.copyOfRange;\nimport static org.fest.assertions.api.Assertions.assertThat;\n\npublic class RackInputTest {\n  public static final byte[] EMPTY_BYTES = \"\".getBytes();\n  public static final byte[] BYTES = \"Hello,\\nWorld!\".getBytes();\n\n  private RackInput empty;\n  private RackInput full;\n  private RackInput fullSlow;\n\n  @Before public void setUp() throws Exception {\n    empty = rackInputFor(EMPTY_BYTES);\n    full = rackInputFor(BYTES);\n    fullSlow = slowRackInputFor(BYTES);\n  }\n\n  @Test public void getsAtEof() throws Exception {\n    assertThat(empty.gets()).isNull();\n  }\n\n  @Test public void gets() throws Exception {\n    assertThat(full.gets()).isEqualTo(\"Hello,\\n\".getBytes());\n  }\n\n  @Test public void getsWithCrLf() throws Exception {\n    assertThat(rackInputFor(\"Hello,\\r\\nWorld!\").gets()).isEqualTo(\"Hello,\\r\\n\".getBytes());\n  }\n\n  @Test public void getsAgain() throws Exception {\n    full.gets();\n    assertThat(full.gets()).isEqualTo(\"World!\".getBytes());\n  }\n\n  @Test public void readWithLengthNilAtEof() throws Exception {\n    assertThat(empty.read(null)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthZeroAtEof() throws Exception {\n    assertThat(empty.read(0)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthAtEof() throws Exception {\n    assertThat(empty.read(1)).isNull();\n  }\n\n  @Test public void readWithLengthNil() throws Exception {\n    assertThat(full.read(null)).isEqualTo(BYTES);\n  }\n\n  @Test public void readWithLengthNilAgain() throws Exception {\n    full.read(null);\n    assertThat(full.read(null)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthZero() throws Exception {\n    assertThat(full.read(0)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLength() throws Exception {\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void readWithLengthAgain() throws Exception {\n    full.read(4);\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 4, 8));\n  }\n\n  @Test public void readFromSlowStreamWithLength() throws Exception {\n    assertThat(fullSlow.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void readFromSlowStreamWithLengthAgain() throws Exception {\n    fullSlow.read(4);\n    assertThat(fullSlow.read(4)).isEqualTo(copyOfRange(BYTES, 4, 8));\n  }\n\n  @Test public void readWithLengthTooLong() throws Exception {\n    assertThat(full.read(BYTES.length + 1)).isEqualTo(BYTES);\n  }\n\n  @Test public void readWithLengthTooLongAgain() throws Exception {\n    full.read(BYTES.length + 1);\n    assertThat(full.read(BYTES.length + 1)).isNull();\n  }\n\n  @Test public void rewind() throws Exception {\n    full.read(4);\n    full.rewind();\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void rewind_shouldDiscardAnyBufferedBytes() throws Exception {\n    RackInput subject = rackInputFor(\"first line\\r\\n123\\r\\n456\\r\\n\");\n    subject.gets();\n    subject.rewind();\n    assertThat(subject.gets()).isEqualTo(\"first line\\r\\n\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"123\\r\\n\".getBytes());\n  }\n\n  @Test public void intermixingReadMethodsIsSafe() throws Exception {\n    RackInput subject = rackInputFor(\"first line\\r\\n123\\r\\n456\\r\\n\");\n    assertThat(subject.read(1)).isEqualTo(\"f\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"irst line\\r\\n\".getBytes());\n    assertThat(subject.read(null)).isEqualTo(\"123\\r\\n456\\r\\n\".getBytes());\n    subject.rewind();\n    assertThat(subject.gets()).isEqualTo(\"first line\\r\\n\".getBytes());\n    assertThat(subject.read(3)).isEqualTo(\"123\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"\\r\\n\".getBytes());\n    assertThat(subject.read(null)).isEqualTo(\"456\\r\\n\".getBytes());\n  }\n\n  private RackInput rackInputFor(String string) throws Exception {\n    return rackInputFor(string.getBytes());\n  }\n\n  private RackInput rackInputFor(byte[] bytes) throws Exception {\n    return new RackInput(new ByteArrayInputStream(bytes));\n  }\n\n  private RackInput slowRackInputFor(byte[] bytes) throws Exception {\n    return new RackInput(new SlowByteArrayInputStream(bytes));\n  }\n}\n", "focal_file": "/*\n * Copyright (C) 2013 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.squareup.rack;\n\nimport com.google.common.io.ByteStreams;\nimport com.squareup.rack.io.ByteArrayBuffer;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\n/**\n * <p>Adapts an {@link InputStream} to the required interface for {@code rack.input}.</p>\n *\n * <p>Speaks {@code byte[]}, not {@code String}, because {@code rack.input} is required to have\n * binary encoding.</p>\n */\npublic class RackInput implements Closeable {\n  private static final int LINEFEED = 0xA;\n  private static final int MAX_LINE_LENGTH = 1024 * 1024;\n  private static final int READ_AHEAD_SUGGESTION = 1024 * 1024;\n\n  private final InputStream stream;\n  private final ByteArrayBuffer buffer = new ByteArrayBuffer();\n  private int bufferReadHead;\n\n  /**\n   * Creates a {@link RackInput} stream that draws from the given {@link InputStream}.\n   *\n   * @param inputStream the source stream.\n   */\n  public RackInput(InputStream inputStream) {\n    checkNotNull(inputStream);\n    checkArgument(inputStream.markSupported(),\n        \"rack.input must be rewindable, but inputStream doesn't support mark.\");\n\n    stream = inputStream;\n    stream.mark(READ_AHEAD_SUGGESTION);\n  }\n\n  /**\n   * Reads the next line from the stream.\n   *\n   * @return the next line, or null at EOF.\n   * @throws IOException\n   */\n  public byte[] gets() throws IOException {\n    return readToLinefeed();\n  }\n\n  /**\n   * Reads length bytes from the stream. Reads all the way to EOF when length is null.\n   *\n   * @param length the desired number of bytes, or null.\n   * @return the bytes, or null at EOF when length is present.\n   * @throws IOException\n   */\n  public byte[] read(Integer length) throws IOException {\n    if (length == null) {\n      return readToEof();\n    } else {\n      return readTo(length);\n    }\n  }\n\n  /**\n   * Resets the stream, so that it may be read again from the beginning.\n   *\n   * @throws IOException\n   */\n  public void rewind() throws IOException {\n    stream.reset();\n    buffer.reset();\n    bufferReadHead = 0;\n  }\n\n  /**\n   * Closes the stream.\n   *\n   * @throws IOException\n   */\n  @Override public void close() throws IOException {\n    stream.close();\n  }\n\n  private byte[] readToLinefeed() throws IOException {\n    int startFrom = 0;\n    do {\n      int indexOfNewline = indexOfNextNewlineInBuffer(startFrom);\n\n      if (indexOfNewline == -1) {\n        int bytesPresent = bytesAvailableInBuffer();\n\n        if (bytesPresent > MAX_LINE_LENGTH) {\n          throw new RuntimeException(\n              \"Really, you have a line longer than \" + MAX_LINE_LENGTH + \" bytes?\");\n        }\n\n        // next time through, start where we left off.\n        startFrom = bytesPresent;\n\n        int bytesRead = fillBuffer(8 * 1024);\n        if (bytesRead == -1) {\n          int bytesRemaining = bytesAvailableInBuffer();\n          return consumeBytesFromBuffer(bytesRemaining);\n        }\n      } else {\n        int length = indexOfNewline - bufferReadHead + 1;\n        return consumeBytesFromBuffer(length);\n      }\n    } while (true);\n  }\n\n  private byte[] readToEof() throws IOException {\n    if (bufferReadHead > 0) {\n      compactBuffer(true);\n    }\n\n    ByteStreams.copy(stream, buffer);\n\n    int length = buffer.getLength();\n    if (length == 0) {\n      return new byte[0];\n    } else {\n      return consumeBytesFromBuffer(length);\n    }\n  }\n\n  private byte[] readTo(int length) throws IOException {\n    if (length == 0) {\n      return new byte[0];\n    }\n\n    if (bufferReadHead > 0) {\n      compactBuffer(true);\n    }\n\n    int bytesStillNeeded = length - buffer.getLength();\n    if (bytesStillNeeded > 0) {\n      int bytesRead = fillBuffer(bytesStillNeeded);\n      while (bytesRead != -1 && bytesStillNeeded > 0) {\n        bytesStillNeeded -= bytesRead;\n        bytesRead = fillBuffer(bytesStillNeeded);\n      }\n    }\n\n    return consumeBytesFromBuffer(length);\n  }\n\n  private int bytesAvailableInBuffer() {\n    return buffer.getLength() - bufferReadHead;\n  }\n\n  private int indexOfNextNewlineInBuffer(int startFrom) {\n    byte[] bytes = buffer.getBuffer();\n    int bufferLength = buffer.getLength();\n    for (int i = bufferReadHead + startFrom; i < bufferLength; i++) {\n      if (bytes[i] == LINEFEED) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  private int fillBuffer(int length) throws IOException {\n    compactBuffer(false);\n    byte[] readBuf = new byte[length];\n    int bytesRead = stream.read(readBuf);\n    if (bytesRead > 0) {\n      buffer.write(readBuf, 0, bytesRead);\n    }\n    return bytesRead;\n  }\n\n  private byte[] consumeBytesFromBuffer(int length) {\n    int bytesAvailable = bytesAvailableInBuffer();\n    if (length > bytesAvailable) {\n      length = bytesAvailable;\n    }\n\n    if (length == 0) {\n      return null;\n    }\n\n    byte[] bytes = new byte[length];\n    byte[] bufferBytes = buffer.getBuffer();\n    System.arraycopy(bufferBytes, bufferReadHead, bytes, 0, length);\n    bufferReadHead += length;\n    return bytes;\n  }\n\n  private void compactBuffer(boolean force) {\n    byte[] bufferBytes = buffer.getBuffer();\n\n    // normally, only compact if we're at least 1K in, and at least 3/4 of the way in\n    if (force || (bufferReadHead > 1024 && bufferReadHead > (bufferBytes.length * 3 / 4))) {\n      int remainingBytes = bytesAvailableInBuffer();\n      System.arraycopy(bufferBytes, bufferReadHead, bufferBytes, 0, remainingBytes);\n      buffer.setLength(remainingBytes);\n      bufferReadHead = 0;\n    }\n  }\n}\n"}
{"test_method": "@Test public void flushOnEmpty() {\n    rackErrors.flush();\n    verify(logger, never()).error(anyString());\n  }", "focal_method": "public void flush() {\n    if (buffer.length() > 0) {\n      logger.error(buffer.toString());\n      buffer.setLength(0);\n    }\n  }", "test_file": "package com.squareup.rack;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.InOrder;\nimport org.mockito.Mock;\nimport org.mockito.runners.MockitoJUnitRunner;\nimport org.slf4j.Logger;\n\nimport static org.mockito.Matchers.anyString;\nimport static org.mockito.Mockito.inOrder;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.verify;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class RackErrorsTest {\n  private RackErrors rackErrors;\n\n  @Mock private Logger logger;\n\n  @Before public void setUp() {\n    rackErrors = new RackErrors(logger);\n  }\n\n  @Test(expected = NullPointerException.class)\n  public void constructorRequiresALogger() {\n    new RackErrors(null);\n  }\n\n  @Test public void puts() {\n    rackErrors.puts(\"Boom!\");\n    verify(logger).error(\"Boom!\");\n  }\n\n  @Test public void write() {\n    rackErrors.write(\"Boom?\");\n    verify(logger, never()).error(anyString());\n  }\n\n  @Test public void writeThenFlush() {\n    rackErrors.write(\"Boom?\");\n    rackErrors.flush();\n    verify(logger).error(\"Boom?\");\n  }\n\n  @Test public void writeWriteWriteThenFlush() {\n    rackErrors.write(\"Boom?\");\n    rackErrors.write(\"Boom!\");\n    rackErrors.write(\"Boom\u2026\");\n    rackErrors.flush();\n    verify(logger).error(\"Boom?Boom!Boom\u2026\");\n  }\n\n  @Test public void flushOnEmpty() {\n    rackErrors.flush();\n    verify(logger, never()).error(anyString());\n  }\n\n  @Test public void writeFlushWriteFlush() {\n    rackErrors.write(\"A loooong message\");\n    rackErrors.flush();\n    rackErrors.write(\"A short msg\");\n    rackErrors.flush();\n\n    InOrder inOrder = inOrder(logger);\n    inOrder.verify(logger).error(\"A loooong message\");\n    inOrder.verify(logger).error(\"A short msg\");\n  }\n}\n", "focal_file": "/*\n * Copyright (C) 2013 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.squareup.rack;\n\nimport org.slf4j.Logger;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\n/**\n * Adapts a {@link Logger} to the required interface for {@code rack.errors}.\n */\npublic class RackErrors {\n  private final Logger logger;\n  private final StringBuffer buffer;\n\n  /**\n   * Creates a {@link RackErrors} stream that forwards messages to the given {@link Logger}.\n   *\n   * @param logger the destination {@link Logger}.\n   */\n  public RackErrors(Logger logger) {\n    this.logger = checkNotNull(logger);\n    this.buffer = new StringBuffer();\n  }\n\n  /**\n   * Immediately writes the given message out to the error logger.\n   *\n   * @param message\n   */\n  public void puts(String message) {\n    logger.error(message);\n  }\n\n  /**\n   * Buffers the given message internally. You may call {@link #write(String)} as many times as you\n   * like. To then write the composite buffered message to the error logger, call {@link #flush()}.\n   *\n   * @param message\n   */\n  public void write(String message) {\n    buffer.append(message);\n  }\n\n  /**\n   * Writes internally-buffered messages out to the error logger.\n   *\n   * @see #write(String)\n   */\n  public void flush() {\n    if (buffer.length() > 0) {\n      logger.error(buffer.toString());\n      buffer.setLength(0);\n    }\n  }\n}\n"}
{"test_method": "@Test public void readWithLength() throws Exception {\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }", "focal_method": "public byte[] read(Integer length) throws IOException {\n    if (length == null) {\n      return readToEof();\n    } else {\n      return readTo(length);\n    }\n  }", "test_file": "package com.squareup.rack;\n\nimport java.io.ByteArrayInputStream;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static java.util.Arrays.copyOfRange;\nimport static org.fest.assertions.api.Assertions.assertThat;\n\npublic class RackInputTest {\n  public static final byte[] EMPTY_BYTES = \"\".getBytes();\n  public static final byte[] BYTES = \"Hello,\\nWorld!\".getBytes();\n\n  private RackInput empty;\n  private RackInput full;\n  private RackInput fullSlow;\n\n  @Before public void setUp() throws Exception {\n    empty = rackInputFor(EMPTY_BYTES);\n    full = rackInputFor(BYTES);\n    fullSlow = slowRackInputFor(BYTES);\n  }\n\n  @Test public void getsAtEof() throws Exception {\n    assertThat(empty.gets()).isNull();\n  }\n\n  @Test public void gets() throws Exception {\n    assertThat(full.gets()).isEqualTo(\"Hello,\\n\".getBytes());\n  }\n\n  @Test public void getsWithCrLf() throws Exception {\n    assertThat(rackInputFor(\"Hello,\\r\\nWorld!\").gets()).isEqualTo(\"Hello,\\r\\n\".getBytes());\n  }\n\n  @Test public void getsAgain() throws Exception {\n    full.gets();\n    assertThat(full.gets()).isEqualTo(\"World!\".getBytes());\n  }\n\n  @Test public void readWithLengthNilAtEof() throws Exception {\n    assertThat(empty.read(null)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthZeroAtEof() throws Exception {\n    assertThat(empty.read(0)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthAtEof() throws Exception {\n    assertThat(empty.read(1)).isNull();\n  }\n\n  @Test public void readWithLengthNil() throws Exception {\n    assertThat(full.read(null)).isEqualTo(BYTES);\n  }\n\n  @Test public void readWithLengthNilAgain() throws Exception {\n    full.read(null);\n    assertThat(full.read(null)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthZero() throws Exception {\n    assertThat(full.read(0)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLength() throws Exception {\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void readWithLengthAgain() throws Exception {\n    full.read(4);\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 4, 8));\n  }\n\n  @Test public void readFromSlowStreamWithLength() throws Exception {\n    assertThat(fullSlow.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void readFromSlowStreamWithLengthAgain() throws Exception {\n    fullSlow.read(4);\n    assertThat(fullSlow.read(4)).isEqualTo(copyOfRange(BYTES, 4, 8));\n  }\n\n  @Test public void readWithLengthTooLong() throws Exception {\n    assertThat(full.read(BYTES.length + 1)).isEqualTo(BYTES);\n  }\n\n  @Test public void readWithLengthTooLongAgain() throws Exception {\n    full.read(BYTES.length + 1);\n    assertThat(full.read(BYTES.length + 1)).isNull();\n  }\n\n  @Test public void rewind() throws Exception {\n    full.read(4);\n    full.rewind();\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void rewind_shouldDiscardAnyBufferedBytes() throws Exception {\n    RackInput subject = rackInputFor(\"first line\\r\\n123\\r\\n456\\r\\n\");\n    subject.gets();\n    subject.rewind();\n    assertThat(subject.gets()).isEqualTo(\"first line\\r\\n\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"123\\r\\n\".getBytes());\n  }\n\n  @Test public void intermixingReadMethodsIsSafe() throws Exception {\n    RackInput subject = rackInputFor(\"first line\\r\\n123\\r\\n456\\r\\n\");\n    assertThat(subject.read(1)).isEqualTo(\"f\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"irst line\\r\\n\".getBytes());\n    assertThat(subject.read(null)).isEqualTo(\"123\\r\\n456\\r\\n\".getBytes());\n    subject.rewind();\n    assertThat(subject.gets()).isEqualTo(\"first line\\r\\n\".getBytes());\n    assertThat(subject.read(3)).isEqualTo(\"123\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"\\r\\n\".getBytes());\n    assertThat(subject.read(null)).isEqualTo(\"456\\r\\n\".getBytes());\n  }\n\n  private RackInput rackInputFor(String string) throws Exception {\n    return rackInputFor(string.getBytes());\n  }\n\n  private RackInput rackInputFor(byte[] bytes) throws Exception {\n    return new RackInput(new ByteArrayInputStream(bytes));\n  }\n\n  private RackInput slowRackInputFor(byte[] bytes) throws Exception {\n    return new RackInput(new SlowByteArrayInputStream(bytes));\n  }\n}\n", "focal_file": "/*\n * Copyright (C) 2013 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.squareup.rack;\n\nimport com.google.common.io.ByteStreams;\nimport com.squareup.rack.io.ByteArrayBuffer;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\n/**\n * <p>Adapts an {@link InputStream} to the required interface for {@code rack.input}.</p>\n *\n * <p>Speaks {@code byte[]}, not {@code String}, because {@code rack.input} is required to have\n * binary encoding.</p>\n */\npublic class RackInput implements Closeable {\n  private static final int LINEFEED = 0xA;\n  private static final int MAX_LINE_LENGTH = 1024 * 1024;\n  private static final int READ_AHEAD_SUGGESTION = 1024 * 1024;\n\n  private final InputStream stream;\n  private final ByteArrayBuffer buffer = new ByteArrayBuffer();\n  private int bufferReadHead;\n\n  /**\n   * Creates a {@link RackInput} stream that draws from the given {@link InputStream}.\n   *\n   * @param inputStream the source stream.\n   */\n  public RackInput(InputStream inputStream) {\n    checkNotNull(inputStream);\n    checkArgument(inputStream.markSupported(),\n        \"rack.input must be rewindable, but inputStream doesn't support mark.\");\n\n    stream = inputStream;\n    stream.mark(READ_AHEAD_SUGGESTION);\n  }\n\n  /**\n   * Reads the next line from the stream.\n   *\n   * @return the next line, or null at EOF.\n   * @throws IOException\n   */\n  public byte[] gets() throws IOException {\n    return readToLinefeed();\n  }\n\n  /**\n   * Reads length bytes from the stream. Reads all the way to EOF when length is null.\n   *\n   * @param length the desired number of bytes, or null.\n   * @return the bytes, or null at EOF when length is present.\n   * @throws IOException\n   */\n  public byte[] read(Integer length) throws IOException {\n    if (length == null) {\n      return readToEof();\n    } else {\n      return readTo(length);\n    }\n  }\n\n  /**\n   * Resets the stream, so that it may be read again from the beginning.\n   *\n   * @throws IOException\n   */\n  public void rewind() throws IOException {\n    stream.reset();\n    buffer.reset();\n    bufferReadHead = 0;\n  }\n\n  /**\n   * Closes the stream.\n   *\n   * @throws IOException\n   */\n  @Override public void close() throws IOException {\n    stream.close();\n  }\n\n  private byte[] readToLinefeed() throws IOException {\n    int startFrom = 0;\n    do {\n      int indexOfNewline = indexOfNextNewlineInBuffer(startFrom);\n\n      if (indexOfNewline == -1) {\n        int bytesPresent = bytesAvailableInBuffer();\n\n        if (bytesPresent > MAX_LINE_LENGTH) {\n          throw new RuntimeException(\n              \"Really, you have a line longer than \" + MAX_LINE_LENGTH + \" bytes?\");\n        }\n\n        // next time through, start where we left off.\n        startFrom = bytesPresent;\n\n        int bytesRead = fillBuffer(8 * 1024);\n        if (bytesRead == -1) {\n          int bytesRemaining = bytesAvailableInBuffer();\n          return consumeBytesFromBuffer(bytesRemaining);\n        }\n      } else {\n        int length = indexOfNewline - bufferReadHead + 1;\n        return consumeBytesFromBuffer(length);\n      }\n    } while (true);\n  }\n\n  private byte[] readToEof() throws IOException {\n    if (bufferReadHead > 0) {\n      compactBuffer(true);\n    }\n\n    ByteStreams.copy(stream, buffer);\n\n    int length = buffer.getLength();\n    if (length == 0) {\n      return new byte[0];\n    } else {\n      return consumeBytesFromBuffer(length);\n    }\n  }\n\n  private byte[] readTo(int length) throws IOException {\n    if (length == 0) {\n      return new byte[0];\n    }\n\n    if (bufferReadHead > 0) {\n      compactBuffer(true);\n    }\n\n    int bytesStillNeeded = length - buffer.getLength();\n    if (bytesStillNeeded > 0) {\n      int bytesRead = fillBuffer(bytesStillNeeded);\n      while (bytesRead != -1 && bytesStillNeeded > 0) {\n        bytesStillNeeded -= bytesRead;\n        bytesRead = fillBuffer(bytesStillNeeded);\n      }\n    }\n\n    return consumeBytesFromBuffer(length);\n  }\n\n  private int bytesAvailableInBuffer() {\n    return buffer.getLength() - bufferReadHead;\n  }\n\n  private int indexOfNextNewlineInBuffer(int startFrom) {\n    byte[] bytes = buffer.getBuffer();\n    int bufferLength = buffer.getLength();\n    for (int i = bufferReadHead + startFrom; i < bufferLength; i++) {\n      if (bytes[i] == LINEFEED) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  private int fillBuffer(int length) throws IOException {\n    compactBuffer(false);\n    byte[] readBuf = new byte[length];\n    int bytesRead = stream.read(readBuf);\n    if (bytesRead > 0) {\n      buffer.write(readBuf, 0, bytesRead);\n    }\n    return bytesRead;\n  }\n\n  private byte[] consumeBytesFromBuffer(int length) {\n    int bytesAvailable = bytesAvailableInBuffer();\n    if (length > bytesAvailable) {\n      length = bytesAvailable;\n    }\n\n    if (length == 0) {\n      return null;\n    }\n\n    byte[] bytes = new byte[length];\n    byte[] bufferBytes = buffer.getBuffer();\n    System.arraycopy(bufferBytes, bufferReadHead, bytes, 0, length);\n    bufferReadHead += length;\n    return bytes;\n  }\n\n  private void compactBuffer(boolean force) {\n    byte[] bufferBytes = buffer.getBuffer();\n\n    // normally, only compact if we're at least 1K in, and at least 3/4 of the way in\n    if (force || (bufferReadHead > 1024 && bufferReadHead > (bufferBytes.length * 3 / 4))) {\n      int remainingBytes = bytesAvailableInBuffer();\n      System.arraycopy(bufferBytes, bufferReadHead, bufferBytes, 0, remainingBytes);\n      buffer.setLength(remainingBytes);\n      bufferReadHead = 0;\n    }\n  }\n}\n"}
{"test_method": "@Test public void readWithLengthNil() throws Exception {\n    assertThat(full.read(null)).isEqualTo(BYTES);\n  }", "focal_method": "public byte[] read(Integer length) throws IOException {\n    if (length == null) {\n      return readToEof();\n    } else {\n      return readTo(length);\n    }\n  }", "test_file": "package com.squareup.rack;\n\nimport java.io.ByteArrayInputStream;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static java.util.Arrays.copyOfRange;\nimport static org.fest.assertions.api.Assertions.assertThat;\n\npublic class RackInputTest {\n  public static final byte[] EMPTY_BYTES = \"\".getBytes();\n  public static final byte[] BYTES = \"Hello,\\nWorld!\".getBytes();\n\n  private RackInput empty;\n  private RackInput full;\n  private RackInput fullSlow;\n\n  @Before public void setUp() throws Exception {\n    empty = rackInputFor(EMPTY_BYTES);\n    full = rackInputFor(BYTES);\n    fullSlow = slowRackInputFor(BYTES);\n  }\n\n  @Test public void getsAtEof() throws Exception {\n    assertThat(empty.gets()).isNull();\n  }\n\n  @Test public void gets() throws Exception {\n    assertThat(full.gets()).isEqualTo(\"Hello,\\n\".getBytes());\n  }\n\n  @Test public void getsWithCrLf() throws Exception {\n    assertThat(rackInputFor(\"Hello,\\r\\nWorld!\").gets()).isEqualTo(\"Hello,\\r\\n\".getBytes());\n  }\n\n  @Test public void getsAgain() throws Exception {\n    full.gets();\n    assertThat(full.gets()).isEqualTo(\"World!\".getBytes());\n  }\n\n  @Test public void readWithLengthNilAtEof() throws Exception {\n    assertThat(empty.read(null)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthZeroAtEof() throws Exception {\n    assertThat(empty.read(0)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthAtEof() throws Exception {\n    assertThat(empty.read(1)).isNull();\n  }\n\n  @Test public void readWithLengthNil() throws Exception {\n    assertThat(full.read(null)).isEqualTo(BYTES);\n  }\n\n  @Test public void readWithLengthNilAgain() throws Exception {\n    full.read(null);\n    assertThat(full.read(null)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthZero() throws Exception {\n    assertThat(full.read(0)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLength() throws Exception {\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void readWithLengthAgain() throws Exception {\n    full.read(4);\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 4, 8));\n  }\n\n  @Test public void readFromSlowStreamWithLength() throws Exception {\n    assertThat(fullSlow.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void readFromSlowStreamWithLengthAgain() throws Exception {\n    fullSlow.read(4);\n    assertThat(fullSlow.read(4)).isEqualTo(copyOfRange(BYTES, 4, 8));\n  }\n\n  @Test public void readWithLengthTooLong() throws Exception {\n    assertThat(full.read(BYTES.length + 1)).isEqualTo(BYTES);\n  }\n\n  @Test public void readWithLengthTooLongAgain() throws Exception {\n    full.read(BYTES.length + 1);\n    assertThat(full.read(BYTES.length + 1)).isNull();\n  }\n\n  @Test public void rewind() throws Exception {\n    full.read(4);\n    full.rewind();\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void rewind_shouldDiscardAnyBufferedBytes() throws Exception {\n    RackInput subject = rackInputFor(\"first line\\r\\n123\\r\\n456\\r\\n\");\n    subject.gets();\n    subject.rewind();\n    assertThat(subject.gets()).isEqualTo(\"first line\\r\\n\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"123\\r\\n\".getBytes());\n  }\n\n  @Test public void intermixingReadMethodsIsSafe() throws Exception {\n    RackInput subject = rackInputFor(\"first line\\r\\n123\\r\\n456\\r\\n\");\n    assertThat(subject.read(1)).isEqualTo(\"f\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"irst line\\r\\n\".getBytes());\n    assertThat(subject.read(null)).isEqualTo(\"123\\r\\n456\\r\\n\".getBytes());\n    subject.rewind();\n    assertThat(subject.gets()).isEqualTo(\"first line\\r\\n\".getBytes());\n    assertThat(subject.read(3)).isEqualTo(\"123\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"\\r\\n\".getBytes());\n    assertThat(subject.read(null)).isEqualTo(\"456\\r\\n\".getBytes());\n  }\n\n  private RackInput rackInputFor(String string) throws Exception {\n    return rackInputFor(string.getBytes());\n  }\n\n  private RackInput rackInputFor(byte[] bytes) throws Exception {\n    return new RackInput(new ByteArrayInputStream(bytes));\n  }\n\n  private RackInput slowRackInputFor(byte[] bytes) throws Exception {\n    return new RackInput(new SlowByteArrayInputStream(bytes));\n  }\n}\n", "focal_file": "/*\n * Copyright (C) 2013 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.squareup.rack;\n\nimport com.google.common.io.ByteStreams;\nimport com.squareup.rack.io.ByteArrayBuffer;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\n/**\n * <p>Adapts an {@link InputStream} to the required interface for {@code rack.input}.</p>\n *\n * <p>Speaks {@code byte[]}, not {@code String}, because {@code rack.input} is required to have\n * binary encoding.</p>\n */\npublic class RackInput implements Closeable {\n  private static final int LINEFEED = 0xA;\n  private static final int MAX_LINE_LENGTH = 1024 * 1024;\n  private static final int READ_AHEAD_SUGGESTION = 1024 * 1024;\n\n  private final InputStream stream;\n  private final ByteArrayBuffer buffer = new ByteArrayBuffer();\n  private int bufferReadHead;\n\n  /**\n   * Creates a {@link RackInput} stream that draws from the given {@link InputStream}.\n   *\n   * @param inputStream the source stream.\n   */\n  public RackInput(InputStream inputStream) {\n    checkNotNull(inputStream);\n    checkArgument(inputStream.markSupported(),\n        \"rack.input must be rewindable, but inputStream doesn't support mark.\");\n\n    stream = inputStream;\n    stream.mark(READ_AHEAD_SUGGESTION);\n  }\n\n  /**\n   * Reads the next line from the stream.\n   *\n   * @return the next line, or null at EOF.\n   * @throws IOException\n   */\n  public byte[] gets() throws IOException {\n    return readToLinefeed();\n  }\n\n  /**\n   * Reads length bytes from the stream. Reads all the way to EOF when length is null.\n   *\n   * @param length the desired number of bytes, or null.\n   * @return the bytes, or null at EOF when length is present.\n   * @throws IOException\n   */\n  public byte[] read(Integer length) throws IOException {\n    if (length == null) {\n      return readToEof();\n    } else {\n      return readTo(length);\n    }\n  }\n\n  /**\n   * Resets the stream, so that it may be read again from the beginning.\n   *\n   * @throws IOException\n   */\n  public void rewind() throws IOException {\n    stream.reset();\n    buffer.reset();\n    bufferReadHead = 0;\n  }\n\n  /**\n   * Closes the stream.\n   *\n   * @throws IOException\n   */\n  @Override public void close() throws IOException {\n    stream.close();\n  }\n\n  private byte[] readToLinefeed() throws IOException {\n    int startFrom = 0;\n    do {\n      int indexOfNewline = indexOfNextNewlineInBuffer(startFrom);\n\n      if (indexOfNewline == -1) {\n        int bytesPresent = bytesAvailableInBuffer();\n\n        if (bytesPresent > MAX_LINE_LENGTH) {\n          throw new RuntimeException(\n              \"Really, you have a line longer than \" + MAX_LINE_LENGTH + \" bytes?\");\n        }\n\n        // next time through, start where we left off.\n        startFrom = bytesPresent;\n\n        int bytesRead = fillBuffer(8 * 1024);\n        if (bytesRead == -1) {\n          int bytesRemaining = bytesAvailableInBuffer();\n          return consumeBytesFromBuffer(bytesRemaining);\n        }\n      } else {\n        int length = indexOfNewline - bufferReadHead + 1;\n        return consumeBytesFromBuffer(length);\n      }\n    } while (true);\n  }\n\n  private byte[] readToEof() throws IOException {\n    if (bufferReadHead > 0) {\n      compactBuffer(true);\n    }\n\n    ByteStreams.copy(stream, buffer);\n\n    int length = buffer.getLength();\n    if (length == 0) {\n      return new byte[0];\n    } else {\n      return consumeBytesFromBuffer(length);\n    }\n  }\n\n  private byte[] readTo(int length) throws IOException {\n    if (length == 0) {\n      return new byte[0];\n    }\n\n    if (bufferReadHead > 0) {\n      compactBuffer(true);\n    }\n\n    int bytesStillNeeded = length - buffer.getLength();\n    if (bytesStillNeeded > 0) {\n      int bytesRead = fillBuffer(bytesStillNeeded);\n      while (bytesRead != -1 && bytesStillNeeded > 0) {\n        bytesStillNeeded -= bytesRead;\n        bytesRead = fillBuffer(bytesStillNeeded);\n      }\n    }\n\n    return consumeBytesFromBuffer(length);\n  }\n\n  private int bytesAvailableInBuffer() {\n    return buffer.getLength() - bufferReadHead;\n  }\n\n  private int indexOfNextNewlineInBuffer(int startFrom) {\n    byte[] bytes = buffer.getBuffer();\n    int bufferLength = buffer.getLength();\n    for (int i = bufferReadHead + startFrom; i < bufferLength; i++) {\n      if (bytes[i] == LINEFEED) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  private int fillBuffer(int length) throws IOException {\n    compactBuffer(false);\n    byte[] readBuf = new byte[length];\n    int bytesRead = stream.read(readBuf);\n    if (bytesRead > 0) {\n      buffer.write(readBuf, 0, bytesRead);\n    }\n    return bytesRead;\n  }\n\n  private byte[] consumeBytesFromBuffer(int length) {\n    int bytesAvailable = bytesAvailableInBuffer();\n    if (length > bytesAvailable) {\n      length = bytesAvailable;\n    }\n\n    if (length == 0) {\n      return null;\n    }\n\n    byte[] bytes = new byte[length];\n    byte[] bufferBytes = buffer.getBuffer();\n    System.arraycopy(bufferBytes, bufferReadHead, bytes, 0, length);\n    bufferReadHead += length;\n    return bytes;\n  }\n\n  private void compactBuffer(boolean force) {\n    byte[] bufferBytes = buffer.getBuffer();\n\n    // normally, only compact if we're at least 1K in, and at least 3/4 of the way in\n    if (force || (bufferReadHead > 1024 && bufferReadHead > (bufferBytes.length * 3 / 4))) {\n      int remainingBytes = bytesAvailableInBuffer();\n      System.arraycopy(bufferBytes, bufferReadHead, bufferBytes, 0, remainingBytes);\n      buffer.setLength(remainingBytes);\n      bufferReadHead = 0;\n    }\n  }\n}\n"}
{"test_method": "@Test public void rewind() throws Exception {\n    full.read(4);\n    full.rewind();\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }", "focal_method": "public void rewind() throws IOException {\n    stream.reset();\n    buffer.reset();\n    bufferReadHead = 0;\n  }", "test_file": "package com.squareup.rack;\n\nimport java.io.ByteArrayInputStream;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static java.util.Arrays.copyOfRange;\nimport static org.fest.assertions.api.Assertions.assertThat;\n\npublic class RackInputTest {\n  public static final byte[] EMPTY_BYTES = \"\".getBytes();\n  public static final byte[] BYTES = \"Hello,\\nWorld!\".getBytes();\n\n  private RackInput empty;\n  private RackInput full;\n  private RackInput fullSlow;\n\n  @Before public void setUp() throws Exception {\n    empty = rackInputFor(EMPTY_BYTES);\n    full = rackInputFor(BYTES);\n    fullSlow = slowRackInputFor(BYTES);\n  }\n\n  @Test public void getsAtEof() throws Exception {\n    assertThat(empty.gets()).isNull();\n  }\n\n  @Test public void gets() throws Exception {\n    assertThat(full.gets()).isEqualTo(\"Hello,\\n\".getBytes());\n  }\n\n  @Test public void getsWithCrLf() throws Exception {\n    assertThat(rackInputFor(\"Hello,\\r\\nWorld!\").gets()).isEqualTo(\"Hello,\\r\\n\".getBytes());\n  }\n\n  @Test public void getsAgain() throws Exception {\n    full.gets();\n    assertThat(full.gets()).isEqualTo(\"World!\".getBytes());\n  }\n\n  @Test public void readWithLengthNilAtEof() throws Exception {\n    assertThat(empty.read(null)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthZeroAtEof() throws Exception {\n    assertThat(empty.read(0)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthAtEof() throws Exception {\n    assertThat(empty.read(1)).isNull();\n  }\n\n  @Test public void readWithLengthNil() throws Exception {\n    assertThat(full.read(null)).isEqualTo(BYTES);\n  }\n\n  @Test public void readWithLengthNilAgain() throws Exception {\n    full.read(null);\n    assertThat(full.read(null)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthZero() throws Exception {\n    assertThat(full.read(0)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLength() throws Exception {\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void readWithLengthAgain() throws Exception {\n    full.read(4);\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 4, 8));\n  }\n\n  @Test public void readFromSlowStreamWithLength() throws Exception {\n    assertThat(fullSlow.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void readFromSlowStreamWithLengthAgain() throws Exception {\n    fullSlow.read(4);\n    assertThat(fullSlow.read(4)).isEqualTo(copyOfRange(BYTES, 4, 8));\n  }\n\n  @Test public void readWithLengthTooLong() throws Exception {\n    assertThat(full.read(BYTES.length + 1)).isEqualTo(BYTES);\n  }\n\n  @Test public void readWithLengthTooLongAgain() throws Exception {\n    full.read(BYTES.length + 1);\n    assertThat(full.read(BYTES.length + 1)).isNull();\n  }\n\n  @Test public void rewind() throws Exception {\n    full.read(4);\n    full.rewind();\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void rewind_shouldDiscardAnyBufferedBytes() throws Exception {\n    RackInput subject = rackInputFor(\"first line\\r\\n123\\r\\n456\\r\\n\");\n    subject.gets();\n    subject.rewind();\n    assertThat(subject.gets()).isEqualTo(\"first line\\r\\n\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"123\\r\\n\".getBytes());\n  }\n\n  @Test public void intermixingReadMethodsIsSafe() throws Exception {\n    RackInput subject = rackInputFor(\"first line\\r\\n123\\r\\n456\\r\\n\");\n    assertThat(subject.read(1)).isEqualTo(\"f\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"irst line\\r\\n\".getBytes());\n    assertThat(subject.read(null)).isEqualTo(\"123\\r\\n456\\r\\n\".getBytes());\n    subject.rewind();\n    assertThat(subject.gets()).isEqualTo(\"first line\\r\\n\".getBytes());\n    assertThat(subject.read(3)).isEqualTo(\"123\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"\\r\\n\".getBytes());\n    assertThat(subject.read(null)).isEqualTo(\"456\\r\\n\".getBytes());\n  }\n\n  private RackInput rackInputFor(String string) throws Exception {\n    return rackInputFor(string.getBytes());\n  }\n\n  private RackInput rackInputFor(byte[] bytes) throws Exception {\n    return new RackInput(new ByteArrayInputStream(bytes));\n  }\n\n  private RackInput slowRackInputFor(byte[] bytes) throws Exception {\n    return new RackInput(new SlowByteArrayInputStream(bytes));\n  }\n}\n", "focal_file": "/*\n * Copyright (C) 2013 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.squareup.rack;\n\nimport com.google.common.io.ByteStreams;\nimport com.squareup.rack.io.ByteArrayBuffer;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\n/**\n * <p>Adapts an {@link InputStream} to the required interface for {@code rack.input}.</p>\n *\n * <p>Speaks {@code byte[]}, not {@code String}, because {@code rack.input} is required to have\n * binary encoding.</p>\n */\npublic class RackInput implements Closeable {\n  private static final int LINEFEED = 0xA;\n  private static final int MAX_LINE_LENGTH = 1024 * 1024;\n  private static final int READ_AHEAD_SUGGESTION = 1024 * 1024;\n\n  private final InputStream stream;\n  private final ByteArrayBuffer buffer = new ByteArrayBuffer();\n  private int bufferReadHead;\n\n  /**\n   * Creates a {@link RackInput} stream that draws from the given {@link InputStream}.\n   *\n   * @param inputStream the source stream.\n   */\n  public RackInput(InputStream inputStream) {\n    checkNotNull(inputStream);\n    checkArgument(inputStream.markSupported(),\n        \"rack.input must be rewindable, but inputStream doesn't support mark.\");\n\n    stream = inputStream;\n    stream.mark(READ_AHEAD_SUGGESTION);\n  }\n\n  /**\n   * Reads the next line from the stream.\n   *\n   * @return the next line, or null at EOF.\n   * @throws IOException\n   */\n  public byte[] gets() throws IOException {\n    return readToLinefeed();\n  }\n\n  /**\n   * Reads length bytes from the stream. Reads all the way to EOF when length is null.\n   *\n   * @param length the desired number of bytes, or null.\n   * @return the bytes, or null at EOF when length is present.\n   * @throws IOException\n   */\n  public byte[] read(Integer length) throws IOException {\n    if (length == null) {\n      return readToEof();\n    } else {\n      return readTo(length);\n    }\n  }\n\n  /**\n   * Resets the stream, so that it may be read again from the beginning.\n   *\n   * @throws IOException\n   */\n  public void rewind() throws IOException {\n    stream.reset();\n    buffer.reset();\n    bufferReadHead = 0;\n  }\n\n  /**\n   * Closes the stream.\n   *\n   * @throws IOException\n   */\n  @Override public void close() throws IOException {\n    stream.close();\n  }\n\n  private byte[] readToLinefeed() throws IOException {\n    int startFrom = 0;\n    do {\n      int indexOfNewline = indexOfNextNewlineInBuffer(startFrom);\n\n      if (indexOfNewline == -1) {\n        int bytesPresent = bytesAvailableInBuffer();\n\n        if (bytesPresent > MAX_LINE_LENGTH) {\n          throw new RuntimeException(\n              \"Really, you have a line longer than \" + MAX_LINE_LENGTH + \" bytes?\");\n        }\n\n        // next time through, start where we left off.\n        startFrom = bytesPresent;\n\n        int bytesRead = fillBuffer(8 * 1024);\n        if (bytesRead == -1) {\n          int bytesRemaining = bytesAvailableInBuffer();\n          return consumeBytesFromBuffer(bytesRemaining);\n        }\n      } else {\n        int length = indexOfNewline - bufferReadHead + 1;\n        return consumeBytesFromBuffer(length);\n      }\n    } while (true);\n  }\n\n  private byte[] readToEof() throws IOException {\n    if (bufferReadHead > 0) {\n      compactBuffer(true);\n    }\n\n    ByteStreams.copy(stream, buffer);\n\n    int length = buffer.getLength();\n    if (length == 0) {\n      return new byte[0];\n    } else {\n      return consumeBytesFromBuffer(length);\n    }\n  }\n\n  private byte[] readTo(int length) throws IOException {\n    if (length == 0) {\n      return new byte[0];\n    }\n\n    if (bufferReadHead > 0) {\n      compactBuffer(true);\n    }\n\n    int bytesStillNeeded = length - buffer.getLength();\n    if (bytesStillNeeded > 0) {\n      int bytesRead = fillBuffer(bytesStillNeeded);\n      while (bytesRead != -1 && bytesStillNeeded > 0) {\n        bytesStillNeeded -= bytesRead;\n        bytesRead = fillBuffer(bytesStillNeeded);\n      }\n    }\n\n    return consumeBytesFromBuffer(length);\n  }\n\n  private int bytesAvailableInBuffer() {\n    return buffer.getLength() - bufferReadHead;\n  }\n\n  private int indexOfNextNewlineInBuffer(int startFrom) {\n    byte[] bytes = buffer.getBuffer();\n    int bufferLength = buffer.getLength();\n    for (int i = bufferReadHead + startFrom; i < bufferLength; i++) {\n      if (bytes[i] == LINEFEED) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  private int fillBuffer(int length) throws IOException {\n    compactBuffer(false);\n    byte[] readBuf = new byte[length];\n    int bytesRead = stream.read(readBuf);\n    if (bytesRead > 0) {\n      buffer.write(readBuf, 0, bytesRead);\n    }\n    return bytesRead;\n  }\n\n  private byte[] consumeBytesFromBuffer(int length) {\n    int bytesAvailable = bytesAvailableInBuffer();\n    if (length > bytesAvailable) {\n      length = bytesAvailable;\n    }\n\n    if (length == 0) {\n      return null;\n    }\n\n    byte[] bytes = new byte[length];\n    byte[] bufferBytes = buffer.getBuffer();\n    System.arraycopy(bufferBytes, bufferReadHead, bytes, 0, length);\n    bufferReadHead += length;\n    return bytes;\n  }\n\n  private void compactBuffer(boolean force) {\n    byte[] bufferBytes = buffer.getBuffer();\n\n    // normally, only compact if we're at least 1K in, and at least 3/4 of the way in\n    if (force || (bufferReadHead > 1024 && bufferReadHead > (bufferBytes.length * 3 / 4))) {\n      int remainingBytes = bytesAvailableInBuffer();\n      System.arraycopy(bufferBytes, bufferReadHead, bufferBytes, 0, remainingBytes);\n      buffer.setLength(remainingBytes);\n      bufferReadHead = 0;\n    }\n  }\n}\n"}
{"test_method": "@Test public void readWithLengthTooLong() throws Exception {\n    assertThat(full.read(BYTES.length + 1)).isEqualTo(BYTES);\n  }", "focal_method": "public byte[] read(Integer length) throws IOException {\n    if (length == null) {\n      return readToEof();\n    } else {\n      return readTo(length);\n    }\n  }", "test_file": "package com.squareup.rack;\n\nimport java.io.ByteArrayInputStream;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static java.util.Arrays.copyOfRange;\nimport static org.fest.assertions.api.Assertions.assertThat;\n\npublic class RackInputTest {\n  public static final byte[] EMPTY_BYTES = \"\".getBytes();\n  public static final byte[] BYTES = \"Hello,\\nWorld!\".getBytes();\n\n  private RackInput empty;\n  private RackInput full;\n  private RackInput fullSlow;\n\n  @Before public void setUp() throws Exception {\n    empty = rackInputFor(EMPTY_BYTES);\n    full = rackInputFor(BYTES);\n    fullSlow = slowRackInputFor(BYTES);\n  }\n\n  @Test public void getsAtEof() throws Exception {\n    assertThat(empty.gets()).isNull();\n  }\n\n  @Test public void gets() throws Exception {\n    assertThat(full.gets()).isEqualTo(\"Hello,\\n\".getBytes());\n  }\n\n  @Test public void getsWithCrLf() throws Exception {\n    assertThat(rackInputFor(\"Hello,\\r\\nWorld!\").gets()).isEqualTo(\"Hello,\\r\\n\".getBytes());\n  }\n\n  @Test public void getsAgain() throws Exception {\n    full.gets();\n    assertThat(full.gets()).isEqualTo(\"World!\".getBytes());\n  }\n\n  @Test public void readWithLengthNilAtEof() throws Exception {\n    assertThat(empty.read(null)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthZeroAtEof() throws Exception {\n    assertThat(empty.read(0)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthAtEof() throws Exception {\n    assertThat(empty.read(1)).isNull();\n  }\n\n  @Test public void readWithLengthNil() throws Exception {\n    assertThat(full.read(null)).isEqualTo(BYTES);\n  }\n\n  @Test public void readWithLengthNilAgain() throws Exception {\n    full.read(null);\n    assertThat(full.read(null)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthZero() throws Exception {\n    assertThat(full.read(0)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLength() throws Exception {\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void readWithLengthAgain() throws Exception {\n    full.read(4);\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 4, 8));\n  }\n\n  @Test public void readFromSlowStreamWithLength() throws Exception {\n    assertThat(fullSlow.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void readFromSlowStreamWithLengthAgain() throws Exception {\n    fullSlow.read(4);\n    assertThat(fullSlow.read(4)).isEqualTo(copyOfRange(BYTES, 4, 8));\n  }\n\n  @Test public void readWithLengthTooLong() throws Exception {\n    assertThat(full.read(BYTES.length + 1)).isEqualTo(BYTES);\n  }\n\n  @Test public void readWithLengthTooLongAgain() throws Exception {\n    full.read(BYTES.length + 1);\n    assertThat(full.read(BYTES.length + 1)).isNull();\n  }\n\n  @Test public void rewind() throws Exception {\n    full.read(4);\n    full.rewind();\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void rewind_shouldDiscardAnyBufferedBytes() throws Exception {\n    RackInput subject = rackInputFor(\"first line\\r\\n123\\r\\n456\\r\\n\");\n    subject.gets();\n    subject.rewind();\n    assertThat(subject.gets()).isEqualTo(\"first line\\r\\n\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"123\\r\\n\".getBytes());\n  }\n\n  @Test public void intermixingReadMethodsIsSafe() throws Exception {\n    RackInput subject = rackInputFor(\"first line\\r\\n123\\r\\n456\\r\\n\");\n    assertThat(subject.read(1)).isEqualTo(\"f\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"irst line\\r\\n\".getBytes());\n    assertThat(subject.read(null)).isEqualTo(\"123\\r\\n456\\r\\n\".getBytes());\n    subject.rewind();\n    assertThat(subject.gets()).isEqualTo(\"first line\\r\\n\".getBytes());\n    assertThat(subject.read(3)).isEqualTo(\"123\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"\\r\\n\".getBytes());\n    assertThat(subject.read(null)).isEqualTo(\"456\\r\\n\".getBytes());\n  }\n\n  private RackInput rackInputFor(String string) throws Exception {\n    return rackInputFor(string.getBytes());\n  }\n\n  private RackInput rackInputFor(byte[] bytes) throws Exception {\n    return new RackInput(new ByteArrayInputStream(bytes));\n  }\n\n  private RackInput slowRackInputFor(byte[] bytes) throws Exception {\n    return new RackInput(new SlowByteArrayInputStream(bytes));\n  }\n}\n", "focal_file": "/*\n * Copyright (C) 2013 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.squareup.rack;\n\nimport com.google.common.io.ByteStreams;\nimport com.squareup.rack.io.ByteArrayBuffer;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\n/**\n * <p>Adapts an {@link InputStream} to the required interface for {@code rack.input}.</p>\n *\n * <p>Speaks {@code byte[]}, not {@code String}, because {@code rack.input} is required to have\n * binary encoding.</p>\n */\npublic class RackInput implements Closeable {\n  private static final int LINEFEED = 0xA;\n  private static final int MAX_LINE_LENGTH = 1024 * 1024;\n  private static final int READ_AHEAD_SUGGESTION = 1024 * 1024;\n\n  private final InputStream stream;\n  private final ByteArrayBuffer buffer = new ByteArrayBuffer();\n  private int bufferReadHead;\n\n  /**\n   * Creates a {@link RackInput} stream that draws from the given {@link InputStream}.\n   *\n   * @param inputStream the source stream.\n   */\n  public RackInput(InputStream inputStream) {\n    checkNotNull(inputStream);\n    checkArgument(inputStream.markSupported(),\n        \"rack.input must be rewindable, but inputStream doesn't support mark.\");\n\n    stream = inputStream;\n    stream.mark(READ_AHEAD_SUGGESTION);\n  }\n\n  /**\n   * Reads the next line from the stream.\n   *\n   * @return the next line, or null at EOF.\n   * @throws IOException\n   */\n  public byte[] gets() throws IOException {\n    return readToLinefeed();\n  }\n\n  /**\n   * Reads length bytes from the stream. Reads all the way to EOF when length is null.\n   *\n   * @param length the desired number of bytes, or null.\n   * @return the bytes, or null at EOF when length is present.\n   * @throws IOException\n   */\n  public byte[] read(Integer length) throws IOException {\n    if (length == null) {\n      return readToEof();\n    } else {\n      return readTo(length);\n    }\n  }\n\n  /**\n   * Resets the stream, so that it may be read again from the beginning.\n   *\n   * @throws IOException\n   */\n  public void rewind() throws IOException {\n    stream.reset();\n    buffer.reset();\n    bufferReadHead = 0;\n  }\n\n  /**\n   * Closes the stream.\n   *\n   * @throws IOException\n   */\n  @Override public void close() throws IOException {\n    stream.close();\n  }\n\n  private byte[] readToLinefeed() throws IOException {\n    int startFrom = 0;\n    do {\n      int indexOfNewline = indexOfNextNewlineInBuffer(startFrom);\n\n      if (indexOfNewline == -1) {\n        int bytesPresent = bytesAvailableInBuffer();\n\n        if (bytesPresent > MAX_LINE_LENGTH) {\n          throw new RuntimeException(\n              \"Really, you have a line longer than \" + MAX_LINE_LENGTH + \" bytes?\");\n        }\n\n        // next time through, start where we left off.\n        startFrom = bytesPresent;\n\n        int bytesRead = fillBuffer(8 * 1024);\n        if (bytesRead == -1) {\n          int bytesRemaining = bytesAvailableInBuffer();\n          return consumeBytesFromBuffer(bytesRemaining);\n        }\n      } else {\n        int length = indexOfNewline - bufferReadHead + 1;\n        return consumeBytesFromBuffer(length);\n      }\n    } while (true);\n  }\n\n  private byte[] readToEof() throws IOException {\n    if (bufferReadHead > 0) {\n      compactBuffer(true);\n    }\n\n    ByteStreams.copy(stream, buffer);\n\n    int length = buffer.getLength();\n    if (length == 0) {\n      return new byte[0];\n    } else {\n      return consumeBytesFromBuffer(length);\n    }\n  }\n\n  private byte[] readTo(int length) throws IOException {\n    if (length == 0) {\n      return new byte[0];\n    }\n\n    if (bufferReadHead > 0) {\n      compactBuffer(true);\n    }\n\n    int bytesStillNeeded = length - buffer.getLength();\n    if (bytesStillNeeded > 0) {\n      int bytesRead = fillBuffer(bytesStillNeeded);\n      while (bytesRead != -1 && bytesStillNeeded > 0) {\n        bytesStillNeeded -= bytesRead;\n        bytesRead = fillBuffer(bytesStillNeeded);\n      }\n    }\n\n    return consumeBytesFromBuffer(length);\n  }\n\n  private int bytesAvailableInBuffer() {\n    return buffer.getLength() - bufferReadHead;\n  }\n\n  private int indexOfNextNewlineInBuffer(int startFrom) {\n    byte[] bytes = buffer.getBuffer();\n    int bufferLength = buffer.getLength();\n    for (int i = bufferReadHead + startFrom; i < bufferLength; i++) {\n      if (bytes[i] == LINEFEED) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  private int fillBuffer(int length) throws IOException {\n    compactBuffer(false);\n    byte[] readBuf = new byte[length];\n    int bytesRead = stream.read(readBuf);\n    if (bytesRead > 0) {\n      buffer.write(readBuf, 0, bytesRead);\n    }\n    return bytesRead;\n  }\n\n  private byte[] consumeBytesFromBuffer(int length) {\n    int bytesAvailable = bytesAvailableInBuffer();\n    if (length > bytesAvailable) {\n      length = bytesAvailable;\n    }\n\n    if (length == 0) {\n      return null;\n    }\n\n    byte[] bytes = new byte[length];\n    byte[] bufferBytes = buffer.getBuffer();\n    System.arraycopy(bufferBytes, bufferReadHead, bytes, 0, length);\n    bufferReadHead += length;\n    return bytes;\n  }\n\n  private void compactBuffer(boolean force) {\n    byte[] bufferBytes = buffer.getBuffer();\n\n    // normally, only compact if we're at least 1K in, and at least 3/4 of the way in\n    if (force || (bufferReadHead > 1024 && bufferReadHead > (bufferBytes.length * 3 / 4))) {\n      int remainingBytes = bytesAvailableInBuffer();\n      System.arraycopy(bufferBytes, bufferReadHead, bufferBytes, 0, remainingBytes);\n      buffer.setLength(remainingBytes);\n      bufferReadHead = 0;\n    }\n  }\n}\n"}
{"test_method": "@Test public void write() {\n    rackErrors.write(\"Boom?\");\n    verify(logger, never()).error(anyString());\n  }", "focal_method": "public void write(String message) {\n    buffer.append(message);\n  }", "test_file": "package com.squareup.rack;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.InOrder;\nimport org.mockito.Mock;\nimport org.mockito.runners.MockitoJUnitRunner;\nimport org.slf4j.Logger;\n\nimport static org.mockito.Matchers.anyString;\nimport static org.mockito.Mockito.inOrder;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.verify;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class RackErrorsTest {\n  private RackErrors rackErrors;\n\n  @Mock private Logger logger;\n\n  @Before public void setUp() {\n    rackErrors = new RackErrors(logger);\n  }\n\n  @Test(expected = NullPointerException.class)\n  public void constructorRequiresALogger() {\n    new RackErrors(null);\n  }\n\n  @Test public void puts() {\n    rackErrors.puts(\"Boom!\");\n    verify(logger).error(\"Boom!\");\n  }\n\n  @Test public void write() {\n    rackErrors.write(\"Boom?\");\n    verify(logger, never()).error(anyString());\n  }\n\n  @Test public void writeThenFlush() {\n    rackErrors.write(\"Boom?\");\n    rackErrors.flush();\n    verify(logger).error(\"Boom?\");\n  }\n\n  @Test public void writeWriteWriteThenFlush() {\n    rackErrors.write(\"Boom?\");\n    rackErrors.write(\"Boom!\");\n    rackErrors.write(\"Boom\u2026\");\n    rackErrors.flush();\n    verify(logger).error(\"Boom?Boom!Boom\u2026\");\n  }\n\n  @Test public void flushOnEmpty() {\n    rackErrors.flush();\n    verify(logger, never()).error(anyString());\n  }\n\n  @Test public void writeFlushWriteFlush() {\n    rackErrors.write(\"A loooong message\");\n    rackErrors.flush();\n    rackErrors.write(\"A short msg\");\n    rackErrors.flush();\n\n    InOrder inOrder = inOrder(logger);\n    inOrder.verify(logger).error(\"A loooong message\");\n    inOrder.verify(logger).error(\"A short msg\");\n  }\n}\n", "focal_file": "/*\n * Copyright (C) 2013 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.squareup.rack;\n\nimport org.slf4j.Logger;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\n/**\n * Adapts a {@link Logger} to the required interface for {@code rack.errors}.\n */\npublic class RackErrors {\n  private final Logger logger;\n  private final StringBuffer buffer;\n\n  /**\n   * Creates a {@link RackErrors} stream that forwards messages to the given {@link Logger}.\n   *\n   * @param logger the destination {@link Logger}.\n   */\n  public RackErrors(Logger logger) {\n    this.logger = checkNotNull(logger);\n    this.buffer = new StringBuffer();\n  }\n\n  /**\n   * Immediately writes the given message out to the error logger.\n   *\n   * @param message\n   */\n  public void puts(String message) {\n    logger.error(message);\n  }\n\n  /**\n   * Buffers the given message internally. You may call {@link #write(String)} as many times as you\n   * like. To then write the composite buffered message to the error logger, call {@link #flush()}.\n   *\n   * @param message\n   */\n  public void write(String message) {\n    buffer.append(message);\n  }\n\n  /**\n   * Writes internally-buffered messages out to the error logger.\n   *\n   * @see #write(String)\n   */\n  public void flush() {\n    if (buffer.length() > 0) {\n      logger.error(buffer.toString());\n      buffer.setLength(0);\n    }\n  }\n}\n"}
{"test_method": "@Test public void shouldNotLeaveTempFilesLingering() throws Exception {\n    String originalTmpdir = System.getProperty(\"java.io.tmpdir\");\n    System.setProperty(\"java.io.tmpdir\", tempDir.getRoot().toString());\n\n    try {\n      InputStream subject = new TempfileBufferedInputStream(containing(\"123456789\"), 3);\n      read(subject);\n      assertThat(tempDir.getRoot().listFiles()).isEmpty();\n    } finally {\n      System.setProperty(\"java.io.tmpdir\", originalTmpdir);\n    }\n  }", "focal_method": "@Override public int read() throws IOException {\n    byte[] bytes = new byte[1];\n    int read = read(bytes);\n    return (read > 0) ? bytes[0] & 0xff : -1;\n  }", "test_file": "package com.squareup.rack.io;\n\nimport com.google.common.io.CharStreams;\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.TemporaryFolder;\n\nimport static org.fest.assertions.api.Assertions.assertThat;\n\npublic class TempfileBufferedInputStreamTest {\n  public @Rule TemporaryFolder tempDir = new TemporaryFolder();\n\n  @Test public void readingAShortStreamTwice() throws IOException {\n    InputStream subject = new TempfileBufferedInputStream(containing(\"Hello!\"));\n    subject.mark(10);\n    assertThat(read(subject)).isEqualTo(\"Hello!\");\n    subject.reset();\n    assertThat(read(subject)).isEqualTo(\"Hello!\");\n  }\n\n  @Test public void readingALongStreamTwice() throws IOException {\n    InputStream subject = new TempfileBufferedInputStream(containing(\"Hello!\"), 3);\n    subject.mark(10);\n    assertThat(read(subject)).isEqualTo(\"Hello!\");\n    subject.reset();\n    assertThat(read(subject)).isEqualTo(\"Hello!\");\n  }\n\n  @Test public void shouldResetToMarkUnderThreshold() throws Exception {\n    InputStream subject = new TempfileBufferedInputStream(containing(\"Hello!\"));\n    read(subject, 2);\n    subject.mark(10);\n    read(subject);\n    subject.reset();\n    assertThat(read(subject)).isEqualTo(\"llo!\");\n  }\n\n  @Test public void shouldResetToMarkOverThreshold() throws Exception {\n    InputStream subject = new TempfileBufferedInputStream(containing(\"Hello!\"), 3);\n    read(subject, 4);\n    subject.mark(10);\n    read(subject);\n    subject.reset();\n    assertThat(read(subject)).isEqualTo(\"o!\");\n  }\n\n  @Test public void shouldSupportMultipleMarks() throws Exception {\n    InputStream subject = new TempfileBufferedInputStream(containing(\"123456789\"), 3);\n    subject.mark(10); // set the mark at '1'\n    read(subject, 4);\n    subject.reset();\n    read(subject, 4);\n    subject.mark(10); // move the mark to '5'\n    read(subject, 1);\n    assertThat(read(subject)).isEqualTo(\"6789\");\n\n    subject.reset();\n    assertThat(read(subject)).isEqualTo(\"56789\");\n  }\n\n  @Test public void shouldNotLeaveTempFilesLingering() throws Exception {\n    String originalTmpdir = System.getProperty(\"java.io.tmpdir\");\n    System.setProperty(\"java.io.tmpdir\", tempDir.getRoot().toString());\n\n    try {\n      InputStream subject = new TempfileBufferedInputStream(containing(\"123456789\"), 3);\n      read(subject);\n      assertThat(tempDir.getRoot().listFiles()).isEmpty();\n    } finally {\n      System.setProperty(\"java.io.tmpdir\", originalTmpdir);\n    }\n  }\n\n  @Test public void whenClosed_shouldCloseSourceStream() throws Exception {\n    final List<String> log = new ArrayList<String>();\n    InputStream source = new ByteArrayInputStream(\"bytes\".getBytes()) {\n      @Override public void close() throws IOException {\n        log.add(\"closed InputStream\");\n        super.close();\n      }\n    };\n    InputStream subject = new TempfileBufferedInputStream(source, 3);\n    read(subject);\n    subject.close();\n    assertThat(log).contains(\"closed InputStream\");\n  }\n\n  @Test public void whenClosed_shouldCloseTempFileStreamsIgnoringExceptions() throws Exception {\n    final List<String> log = new ArrayList<String>();\n\n    InputStream subject =\n        new TempfileBufferedInputStream(containing(\"123456789\"), 3) {\n          @Override FileInputStream createFileInputStream(File tempFile)\n              throws FileNotFoundException {\n            return new FileInputStream(tempFile) {\n              @Override public void close() throws IOException {\n                log.add(\"closed FileInputStream\");\n                throw new IOException(\"fake exception\");\n              }\n            };\n          }\n\n          @Override FileOutputStream createFileOutputStream(File tempFile)\n              throws FileNotFoundException {\n            return new FileOutputStream(tempFile) {\n              @Override public void close() throws IOException {\n                log.add(\"closed FileOutputStream\");\n                throw new IOException(\"fake exception\");\n              }\n            };\n          }\n        };\n\n    read(subject);\n    subject.close();\n    assertThat(log).contains(\"closed FileInputStream\", \"closed FileOutputStream\");\n  }\n\n  private ByteArrayInputStream containing(String content) {\n    return new ByteArrayInputStream(content.getBytes());\n  }\n\n  private String read(InputStream subject) throws IOException {\n    return CharStreams.toString(new InputStreamReader(subject));\n  }\n\n  private void read(InputStream subject, int count) throws IOException {\n    subject.read(new byte[count], 0, count);\n  }\n}\n", "focal_file": "/*\n * Copyright (C) 2013 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.squareup.rack.io;\n\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Preconditions;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\n\n/**\n * <p>Buffers an {@link InputStream}, making it effectively rewindable.</p>\n *\n * <p>Operates in-memory, just like a {@link java.io.BufferedInputStream}, up to a size threshold,\n * then begins buffering to disk once that size threshold is crossed.</p>\n *\n * <p>As compared with Guava's {@link com.google.common.io.FileBackedOutputStream}, does not require\n * processing the entire stream before offering its contents to client code.</p>\n *\n * <p>Uses the default temporary-file directory, which you can control by setting the\n * {@code java.io.tmpdir} system property.</p>\n *\n * @see File#createTempFile(String, String)\n */\npublic class TempfileBufferedInputStream extends InputStream {\n  private static final int DEFAULT_THRESHOLD = 1024 * 1024;\n\n  private final InputStream source;\n\n  private long readHead;\n  private long writeHead;\n  private long markPos;\n  private Buffer buffer;\n\n  /**\n   * Buffers a source InputStream, dropping to disk once a default size threshold has been crossed.\n   *\n   * @param source the InputStream to buffer.\n   */\n  public TempfileBufferedInputStream(InputStream source) {\n    this(source, DEFAULT_THRESHOLD);\n  }\n\n  /**\n   * Buffers a source InputStream, dropping to disk once the given size threshold has been crossed.\n   *\n   * @param source the InputStream to buffer.\n   * @param threshold the size threshold beyond which to buffer to disk.\n   */\n  public TempfileBufferedInputStream(InputStream source, int threshold) {\n    Preconditions.checkNotNull(source);\n    this.source = source;\n    this.buffer = new MemoryBuffer(threshold);\n  }\n\n  @Override public int read() throws IOException {\n    byte[] bytes = new byte[1];\n    int read = read(bytes);\n    return (read > 0) ? bytes[0] & 0xff : -1;\n  }\n\n  @Override public int read(byte[] bytes) throws IOException {\n    return read(bytes, 0, bytes.length);\n  }\n\n  @Override public int read(byte[] bytes, int offset, int length) throws IOException {\n    int bytesRead;\n\n    long cachedReadable = writeHead - readHead;\n    if (cachedReadable > 0) {\n      int bytesToTransfer = Math.min(length, (int) cachedReadable);\n      buffer.replay(bytes, offset, bytesToTransfer);\n      bytesRead = bytesToTransfer;\n      readHead += bytesRead;\n    } else {\n      bytesRead = source.read(bytes, offset, length);\n      if (bytesRead > 0) {\n        if (buffer.wouldOverflow(writeHead + bytesRead)) {\n          buffer = buffer.embiggened();\n        }\n\n        buffer.append(bytes, offset, bytesRead);\n        writeHead += bytesRead;\n        readHead += bytesRead;\n      }\n    }\n\n    return bytesRead;\n  }\n\n  @Override public synchronized void reset() throws IOException {\n    readHead = markPos;\n    buffer.sync();\n  }\n\n  @Override public synchronized void mark(int i) {\n    markPos = readHead;\n  }\n\n  @Override public boolean markSupported() {\n    return true;\n  }\n\n  @Override public void close() throws IOException {\n    try {\n      buffer.close();\n    } catch (IOException e) {\n      // safe to ignore, we're just closing a buffer\n    }\n    source.close();\n  }\n\n  interface Buffer {\n    void replay(byte[] bytes, int offset, int length) throws IOException;\n\n    void append(byte[] bytes, int offset, int length) throws IOException;\n\n    boolean wouldOverflow(long length);\n\n    Buffer embiggened() throws IOException;\n\n    void sync() throws IOException;\n\n    void close() throws IOException;\n  }\n\n  class MemoryBuffer implements Buffer {\n    private final ByteArrayBuffer cacheOutputStream;\n    private final int threshold;\n\n    public MemoryBuffer(int threshold) {\n      this.threshold = threshold;\n      this.cacheOutputStream = new ByteArrayBuffer();\n    }\n\n    public void replay(byte[] bytes, int offset, int bytesToTransfer) {\n      byte[] cacheBytes = cacheOutputStream.getBuffer();\n      // Cast is safe because threshold is an int. (Arrays can only have integer indexes.)\n      System.arraycopy(cacheBytes, (int) readHead, bytes, offset, bytesToTransfer);\n    }\n\n    @Override public void append(byte[] bytes, int offset, int length) {\n      cacheOutputStream.write(bytes, offset, length);\n    }\n\n    @Override public boolean wouldOverflow(long length) {\n      return length > threshold;\n    }\n\n    @Override public Buffer embiggened() throws IOException {\n      return new FileBackedBuffer(cacheOutputStream);\n    }\n\n    @Override public void sync() {\n    }\n\n    @Override public void close() {\n    }\n  }\n\n  private class FileBackedBuffer implements Buffer {\n    private final BufferedOutputStream outputStream;\n    private final FileChannel inputChannel;\n    private MappedByteBuffer mappedByteBuffer;\n\n    public FileBackedBuffer(ByteArrayBuffer baos) throws IOException {\n      File tempFile = File.createTempFile(\"stream-buffer\", \".buf\");\n      try {\n        FileOutputStream fileOutputStream = createFileOutputStream(tempFile);\n        outputStream = new BufferedOutputStream(fileOutputStream);\n        outputStream.write(baos.getBuffer(), 0, baos.getLength());\n\n        inputChannel = createFileInputStream(tempFile).getChannel();\n      } finally {\n        //noinspection ResultOfMethodCallIgnored\n        tempFile.delete();\n      }\n    }\n\n    @Override public void replay(byte[] bytes, int offset, int length) throws IOException {\n      if (mappedByteBuffer == null) {\n        mappedByteBuffer = inputChannel.map(FileChannel.MapMode.READ_ONLY, 0, writeHead);\n      }\n      // This cast is only unsafe if writeHead is > MAX_INT, i.e., the file is > 2GB. Unlikely?\n      mappedByteBuffer.position((int) readHead);\n      mappedByteBuffer.get(bytes, offset, length);\n    }\n\n    @Override public void append(byte[] bytes, int offset, int length) throws IOException {\n      outputStream.write(bytes, offset, length);\n    }\n\n    @Override public boolean wouldOverflow(long length) {\n      return false;\n    }\n\n    @Override public Buffer embiggened() {\n      throw new UnsupportedOperationException();\n    }\n\n    @Override public void sync() throws IOException {\n      outputStream.flush();\n      mappedByteBuffer = null;\n    }\n\n    @Override public void close() throws IOException {\n      mappedByteBuffer = null;\n      try {\n        outputStream.close();\n      } finally {\n        inputChannel.close();\n      }\n    }\n  }\n\n  @VisibleForTesting FileInputStream createFileInputStream(File tempFile)\n      throws FileNotFoundException {\n    return new FileInputStream(tempFile);\n  }\n\n  @VisibleForTesting FileOutputStream createFileOutputStream(File tempFile)\n      throws FileNotFoundException {\n    return new FileOutputStream(tempFile);\n  }\n}\n"}
{"test_method": "@Test public void getsAtEof() throws Exception {\n    assertThat(empty.gets()).isNull();\n  }", "focal_method": "public byte[] gets() throws IOException {\n    return readToLinefeed();\n  }", "test_file": "package com.squareup.rack;\n\nimport java.io.ByteArrayInputStream;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static java.util.Arrays.copyOfRange;\nimport static org.fest.assertions.api.Assertions.assertThat;\n\npublic class RackInputTest {\n  public static final byte[] EMPTY_BYTES = \"\".getBytes();\n  public static final byte[] BYTES = \"Hello,\\nWorld!\".getBytes();\n\n  private RackInput empty;\n  private RackInput full;\n  private RackInput fullSlow;\n\n  @Before public void setUp() throws Exception {\n    empty = rackInputFor(EMPTY_BYTES);\n    full = rackInputFor(BYTES);\n    fullSlow = slowRackInputFor(BYTES);\n  }\n\n  @Test public void getsAtEof() throws Exception {\n    assertThat(empty.gets()).isNull();\n  }\n\n  @Test public void gets() throws Exception {\n    assertThat(full.gets()).isEqualTo(\"Hello,\\n\".getBytes());\n  }\n\n  @Test public void getsWithCrLf() throws Exception {\n    assertThat(rackInputFor(\"Hello,\\r\\nWorld!\").gets()).isEqualTo(\"Hello,\\r\\n\".getBytes());\n  }\n\n  @Test public void getsAgain() throws Exception {\n    full.gets();\n    assertThat(full.gets()).isEqualTo(\"World!\".getBytes());\n  }\n\n  @Test public void readWithLengthNilAtEof() throws Exception {\n    assertThat(empty.read(null)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthZeroAtEof() throws Exception {\n    assertThat(empty.read(0)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthAtEof() throws Exception {\n    assertThat(empty.read(1)).isNull();\n  }\n\n  @Test public void readWithLengthNil() throws Exception {\n    assertThat(full.read(null)).isEqualTo(BYTES);\n  }\n\n  @Test public void readWithLengthNilAgain() throws Exception {\n    full.read(null);\n    assertThat(full.read(null)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthZero() throws Exception {\n    assertThat(full.read(0)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLength() throws Exception {\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void readWithLengthAgain() throws Exception {\n    full.read(4);\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 4, 8));\n  }\n\n  @Test public void readFromSlowStreamWithLength() throws Exception {\n    assertThat(fullSlow.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void readFromSlowStreamWithLengthAgain() throws Exception {\n    fullSlow.read(4);\n    assertThat(fullSlow.read(4)).isEqualTo(copyOfRange(BYTES, 4, 8));\n  }\n\n  @Test public void readWithLengthTooLong() throws Exception {\n    assertThat(full.read(BYTES.length + 1)).isEqualTo(BYTES);\n  }\n\n  @Test public void readWithLengthTooLongAgain() throws Exception {\n    full.read(BYTES.length + 1);\n    assertThat(full.read(BYTES.length + 1)).isNull();\n  }\n\n  @Test public void rewind() throws Exception {\n    full.read(4);\n    full.rewind();\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void rewind_shouldDiscardAnyBufferedBytes() throws Exception {\n    RackInput subject = rackInputFor(\"first line\\r\\n123\\r\\n456\\r\\n\");\n    subject.gets();\n    subject.rewind();\n    assertThat(subject.gets()).isEqualTo(\"first line\\r\\n\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"123\\r\\n\".getBytes());\n  }\n\n  @Test public void intermixingReadMethodsIsSafe() throws Exception {\n    RackInput subject = rackInputFor(\"first line\\r\\n123\\r\\n456\\r\\n\");\n    assertThat(subject.read(1)).isEqualTo(\"f\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"irst line\\r\\n\".getBytes());\n    assertThat(subject.read(null)).isEqualTo(\"123\\r\\n456\\r\\n\".getBytes());\n    subject.rewind();\n    assertThat(subject.gets()).isEqualTo(\"first line\\r\\n\".getBytes());\n    assertThat(subject.read(3)).isEqualTo(\"123\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"\\r\\n\".getBytes());\n    assertThat(subject.read(null)).isEqualTo(\"456\\r\\n\".getBytes());\n  }\n\n  private RackInput rackInputFor(String string) throws Exception {\n    return rackInputFor(string.getBytes());\n  }\n\n  private RackInput rackInputFor(byte[] bytes) throws Exception {\n    return new RackInput(new ByteArrayInputStream(bytes));\n  }\n\n  private RackInput slowRackInputFor(byte[] bytes) throws Exception {\n    return new RackInput(new SlowByteArrayInputStream(bytes));\n  }\n}\n", "focal_file": "/*\n * Copyright (C) 2013 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.squareup.rack;\n\nimport com.google.common.io.ByteStreams;\nimport com.squareup.rack.io.ByteArrayBuffer;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\n/**\n * <p>Adapts an {@link InputStream} to the required interface for {@code rack.input}.</p>\n *\n * <p>Speaks {@code byte[]}, not {@code String}, because {@code rack.input} is required to have\n * binary encoding.</p>\n */\npublic class RackInput implements Closeable {\n  private static final int LINEFEED = 0xA;\n  private static final int MAX_LINE_LENGTH = 1024 * 1024;\n  private static final int READ_AHEAD_SUGGESTION = 1024 * 1024;\n\n  private final InputStream stream;\n  private final ByteArrayBuffer buffer = new ByteArrayBuffer();\n  private int bufferReadHead;\n\n  /**\n   * Creates a {@link RackInput} stream that draws from the given {@link InputStream}.\n   *\n   * @param inputStream the source stream.\n   */\n  public RackInput(InputStream inputStream) {\n    checkNotNull(inputStream);\n    checkArgument(inputStream.markSupported(),\n        \"rack.input must be rewindable, but inputStream doesn't support mark.\");\n\n    stream = inputStream;\n    stream.mark(READ_AHEAD_SUGGESTION);\n  }\n\n  /**\n   * Reads the next line from the stream.\n   *\n   * @return the next line, or null at EOF.\n   * @throws IOException\n   */\n  public byte[] gets() throws IOException {\n    return readToLinefeed();\n  }\n\n  /**\n   * Reads length bytes from the stream. Reads all the way to EOF when length is null.\n   *\n   * @param length the desired number of bytes, or null.\n   * @return the bytes, or null at EOF when length is present.\n   * @throws IOException\n   */\n  public byte[] read(Integer length) throws IOException {\n    if (length == null) {\n      return readToEof();\n    } else {\n      return readTo(length);\n    }\n  }\n\n  /**\n   * Resets the stream, so that it may be read again from the beginning.\n   *\n   * @throws IOException\n   */\n  public void rewind() throws IOException {\n    stream.reset();\n    buffer.reset();\n    bufferReadHead = 0;\n  }\n\n  /**\n   * Closes the stream.\n   *\n   * @throws IOException\n   */\n  @Override public void close() throws IOException {\n    stream.close();\n  }\n\n  private byte[] readToLinefeed() throws IOException {\n    int startFrom = 0;\n    do {\n      int indexOfNewline = indexOfNextNewlineInBuffer(startFrom);\n\n      if (indexOfNewline == -1) {\n        int bytesPresent = bytesAvailableInBuffer();\n\n        if (bytesPresent > MAX_LINE_LENGTH) {\n          throw new RuntimeException(\n              \"Really, you have a line longer than \" + MAX_LINE_LENGTH + \" bytes?\");\n        }\n\n        // next time through, start where we left off.\n        startFrom = bytesPresent;\n\n        int bytesRead = fillBuffer(8 * 1024);\n        if (bytesRead == -1) {\n          int bytesRemaining = bytesAvailableInBuffer();\n          return consumeBytesFromBuffer(bytesRemaining);\n        }\n      } else {\n        int length = indexOfNewline - bufferReadHead + 1;\n        return consumeBytesFromBuffer(length);\n      }\n    } while (true);\n  }\n\n  private byte[] readToEof() throws IOException {\n    if (bufferReadHead > 0) {\n      compactBuffer(true);\n    }\n\n    ByteStreams.copy(stream, buffer);\n\n    int length = buffer.getLength();\n    if (length == 0) {\n      return new byte[0];\n    } else {\n      return consumeBytesFromBuffer(length);\n    }\n  }\n\n  private byte[] readTo(int length) throws IOException {\n    if (length == 0) {\n      return new byte[0];\n    }\n\n    if (bufferReadHead > 0) {\n      compactBuffer(true);\n    }\n\n    int bytesStillNeeded = length - buffer.getLength();\n    if (bytesStillNeeded > 0) {\n      int bytesRead = fillBuffer(bytesStillNeeded);\n      while (bytesRead != -1 && bytesStillNeeded > 0) {\n        bytesStillNeeded -= bytesRead;\n        bytesRead = fillBuffer(bytesStillNeeded);\n      }\n    }\n\n    return consumeBytesFromBuffer(length);\n  }\n\n  private int bytesAvailableInBuffer() {\n    return buffer.getLength() - bufferReadHead;\n  }\n\n  private int indexOfNextNewlineInBuffer(int startFrom) {\n    byte[] bytes = buffer.getBuffer();\n    int bufferLength = buffer.getLength();\n    for (int i = bufferReadHead + startFrom; i < bufferLength; i++) {\n      if (bytes[i] == LINEFEED) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  private int fillBuffer(int length) throws IOException {\n    compactBuffer(false);\n    byte[] readBuf = new byte[length];\n    int bytesRead = stream.read(readBuf);\n    if (bytesRead > 0) {\n      buffer.write(readBuf, 0, bytesRead);\n    }\n    return bytesRead;\n  }\n\n  private byte[] consumeBytesFromBuffer(int length) {\n    int bytesAvailable = bytesAvailableInBuffer();\n    if (length > bytesAvailable) {\n      length = bytesAvailable;\n    }\n\n    if (length == 0) {\n      return null;\n    }\n\n    byte[] bytes = new byte[length];\n    byte[] bufferBytes = buffer.getBuffer();\n    System.arraycopy(bufferBytes, bufferReadHead, bytes, 0, length);\n    bufferReadHead += length;\n    return bytes;\n  }\n\n  private void compactBuffer(boolean force) {\n    byte[] bufferBytes = buffer.getBuffer();\n\n    // normally, only compact if we're at least 1K in, and at least 3/4 of the way in\n    if (force || (bufferReadHead > 1024 && bufferReadHead > (bufferBytes.length * 3 / 4))) {\n      int remainingBytes = bytesAvailableInBuffer();\n      System.arraycopy(bufferBytes, bufferReadHead, bufferBytes, 0, remainingBytes);\n      buffer.setLength(remainingBytes);\n      bufferReadHead = 0;\n    }\n  }\n}\n"}
{"test_method": "@Test public void propagateHeadersMultipleValues() {\n    rackResponse.header(\"Set-Cookie\", \"foo=bar\\nbar=foo\");\n    subject.propagate(rackResponse.build(), response);\n    verify(response).addHeader(\"Set-Cookie\", \"foo=bar\");\n    verify(response).addHeader(\"Set-Cookie\", \"bar=foo\");\n  }", "focal_method": "public void propagate(RackResponse rackResponse, HttpServletResponse response) {\n    propagateStatus(rackResponse, response);\n    propagateHeaders(rackResponse, response);\n    propagateBody(rackResponse, response);\n  }", "test_file": "package com.squareup.rack.servlet;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.squareup.rack.RackResponse;\nimport java.io.IOException;\nimport javax.servlet.ServletOutputStream;\nimport javax.servlet.http.HttpServletResponse;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.InOrder;\nimport org.mockito.Mock;\nimport org.mockito.runners.MockitoJUnitRunner;\n\nimport static org.mockito.Matchers.anyString;\nimport static org.mockito.Matchers.eq;\nimport static org.mockito.Mockito.inOrder;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class RackResponsePropagatorTest {\n  private RackResponsePropagator subject;\n  private RackResponseBuilder rackResponse;\n\n  @Mock private HttpServletResponse response;\n  @Mock private ServletOutputStream outputStream;\n\n  @Before public void setUp() throws IOException {\n    subject = new RackResponsePropagator();\n    rackResponse = new RackResponseBuilder();\n    when(response.getOutputStream()).thenReturn(outputStream);\n  }\n\n  @Test public void propagateStatus() {\n    rackResponse.status(404);\n    subject.propagate(rackResponse.build(), response);\n    verify(response).setStatus(404);\n  }\n\n  @Test public void propagateHeaders() {\n    rackResponse.header(\"Content-Type\", \"text/plain\");\n    subject.propagate(rackResponse.build(), response);\n    verify(response).addHeader(\"Content-Type\", \"text/plain\");\n  }\n\n  @Test public void propagateHeadersSkipsHeadsRackHeaders() {\n    rackResponse.header(\"rack.internal\", \"42\");\n    subject.propagate(rackResponse.build(), response);\n    verify(response, never()).addHeader(eq(\"rack.internal\"), anyString());\n  }\n\n  @Test public void propagateHeadersMultipleValues() {\n    rackResponse.header(\"Set-Cookie\", \"foo=bar\\nbar=foo\");\n    subject.propagate(rackResponse.build(), response);\n    verify(response).addHeader(\"Set-Cookie\", \"foo=bar\");\n    verify(response).addHeader(\"Set-Cookie\", \"bar=foo\");\n  }\n\n  @Test public void propagateBody() throws IOException {\n    rackResponse.body(\"Here \".getBytes(), \"are \".getBytes(), \"the \".getBytes(), \"parts.\".getBytes());\n\n    subject.propagate(rackResponse.build(), response);\n\n    InOrder inOrder = inOrder(outputStream);\n    inOrder.verify(outputStream).write(\"Here \".getBytes());\n    inOrder.verify(outputStream).write(\"are \".getBytes());\n    inOrder.verify(outputStream).write(\"the \".getBytes());\n    inOrder.verify(outputStream).write(\"parts.\".getBytes());\n    inOrder.verify(outputStream).flush();\n  }\n\n  private static class RackResponseBuilder {\n    private int status;\n    private final ImmutableMap.Builder<String, String> headers;\n    private final ImmutableList.Builder<byte[]> body;\n\n    public RackResponseBuilder() {\n      this.status = 200;\n      this.headers = ImmutableMap.builder();\n      this.body = ImmutableList.builder();\n    }\n\n    public RackResponseBuilder status(int status) {\n      this.status = status;\n      return this;\n    }\n\n    public RackResponseBuilder header(String key, String value) {\n      this.headers.put(key, value);\n      return this;\n    }\n\n    public RackResponseBuilder body(byte[]... parts) {\n      body.add(parts);\n      return this;\n    }\n\n    public RackResponse build() {\n      return new RackResponse(status, headers.build(), body.build().iterator());\n    }\n  }\n}\n", "focal_file": "/*\n * Copyright (C) 2013 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.squareup.rack.servlet;\n\nimport com.google.common.base.Throwables;\nimport com.squareup.rack.RackResponse;\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.Map;\nimport javax.servlet.ServletOutputStream;\nimport javax.servlet.http.HttpServletResponse;\n\n/**\n * Writes a {@link RackResponse} onto an {@link HttpServletResponse}.\n */\npublic class RackResponsePropagator {\n  private static final String RACK_INTERNAL_HEADER_PREFIX = \"rack.\";\n\n  public void propagate(RackResponse rackResponse, HttpServletResponse response) {\n    propagateStatus(rackResponse, response);\n    propagateHeaders(rackResponse, response);\n    propagateBody(rackResponse, response);\n  }\n\n  private void propagateStatus(RackResponse rackResponse, HttpServletResponse response) {\n    response.setStatus(rackResponse.getStatus());\n  }\n\n  private void propagateHeaders(RackResponse rackResponse, HttpServletResponse response) {\n    for (Map.Entry<String, String> header : rackResponse.getHeaders().entrySet()) {\n      if (shouldPropagateHeaderToClient(header)) {\n        for (String val : header.getValue().split(\"\\n\")) {\n          response.addHeader(header.getKey(), val);\n        }\n      }\n    }\n\n    try {\n      response.flushBuffer();\n    } catch (IOException e) {\n      Throwables.propagate(e);\n    }\n  }\n\n  private boolean shouldPropagateHeaderToClient(Map.Entry<String, String> header) {\n    return !header.getKey().startsWith(RACK_INTERNAL_HEADER_PREFIX);\n  }\n\n  private void propagateBody(RackResponse rackResponse, HttpServletResponse response) {\n    ServletOutputStream outputStream = null;\n\n    try {\n      outputStream = response.getOutputStream();\n    } catch (IOException e) {\n      Throwables.propagate(e);\n    }\n\n    Iterator<byte[]> body = rackResponse.getBody();\n\n    while (body.hasNext()) {\n      try {\n        outputStream.write(body.next());\n      } catch (IOException e) {\n        Throwables.propagate(e);\n      }\n    }\n\n    try {\n      outputStream.flush();\n    } catch (IOException e) {\n      Throwables.propagate(e);\n    }\n  }\n}\n"}
{"test_method": "@Test public void fatal() {\n    subject.fatal(MESSAGE);\n    verify(delegate).error(FATAL, MESSAGE);\n  }", "focal_method": "public void fatal(String message) {\n    // See http://www.slf4j.org/faq.html#fatal\n    logger.error(FATAL, message);\n  }", "test_file": "package com.squareup.rack;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.runners.MockitoJUnitRunner;\nimport org.slf4j.Logger;\n\nimport static com.squareup.rack.RackLogger.FATAL;\nimport static org.mockito.Mockito.verify;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class RackLoggerTest {\n  private static final String MESSAGE = \"message\";\n\n  private RackLogger subject;\n  @Mock private Logger delegate;\n\n  @Before public void setUp() {\n    subject = new RackLogger(delegate);\n  }\n\n  @Test(expected = NullPointerException.class)\n  public void constructorRequiresALogger() {\n    new RackLogger(null);\n  }\n\n  @Test public void info() {\n    subject.info(MESSAGE);\n    verify(delegate).info(MESSAGE);\n  }\n\n  @Test public void debug() {\n    subject.debug(MESSAGE);\n    verify(delegate).debug(MESSAGE);\n  }\n\n  @Test public void warn() {\n    subject.warn(MESSAGE);\n    verify(delegate).warn(MESSAGE);\n  }\n\n  @Test public void error() {\n    subject.error(MESSAGE);\n    verify(delegate).error(MESSAGE);\n  }\n\n  @Test public void fatal() {\n    subject.fatal(MESSAGE);\n    verify(delegate).error(FATAL, MESSAGE);\n  }\n}\n", "focal_file": "/*\n * Copyright (C) 2013 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.squareup.rack;\n\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.MarkerFactory;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\n/**\n * Adapts a {@link Logger} to the required interface for {@code rack.logger}.\n */\npublic class RackLogger {\n  public static final Marker FATAL = MarkerFactory.getMarker(\"FATAL\");\n\n  private final Logger logger;\n\n  /**\n   * Creates a {@link RackLogger} that forwards messages to the given {@link Logger}.\n   *\n   * @param logger\n   */\n  public RackLogger(Logger logger) {\n    this.logger = checkNotNull(logger);\n  }\n\n  public void info(String message) {\n    logger.info(message);\n  }\n\n  public void debug(String message) {\n    logger.debug(message);\n  }\n\n  public void warn(String message) {\n    logger.warn(message);\n  }\n\n  public void error(String message) {\n    logger.error(message);\n  }\n\n  public void fatal(String message) {\n    // See http://www.slf4j.org/faq.html#fatal\n    logger.error(FATAL, message);\n  }\n}\n"}
{"test_method": "@Test public void debug() {\n    subject.debug(MESSAGE);\n    verify(delegate).debug(MESSAGE);\n  }", "focal_method": "public void debug(String message) {\n    logger.debug(message);\n  }", "test_file": "package com.squareup.rack;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.runners.MockitoJUnitRunner;\nimport org.slf4j.Logger;\n\nimport static com.squareup.rack.RackLogger.FATAL;\nimport static org.mockito.Mockito.verify;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class RackLoggerTest {\n  private static final String MESSAGE = \"message\";\n\n  private RackLogger subject;\n  @Mock private Logger delegate;\n\n  @Before public void setUp() {\n    subject = new RackLogger(delegate);\n  }\n\n  @Test(expected = NullPointerException.class)\n  public void constructorRequiresALogger() {\n    new RackLogger(null);\n  }\n\n  @Test public void info() {\n    subject.info(MESSAGE);\n    verify(delegate).info(MESSAGE);\n  }\n\n  @Test public void debug() {\n    subject.debug(MESSAGE);\n    verify(delegate).debug(MESSAGE);\n  }\n\n  @Test public void warn() {\n    subject.warn(MESSAGE);\n    verify(delegate).warn(MESSAGE);\n  }\n\n  @Test public void error() {\n    subject.error(MESSAGE);\n    verify(delegate).error(MESSAGE);\n  }\n\n  @Test public void fatal() {\n    subject.fatal(MESSAGE);\n    verify(delegate).error(FATAL, MESSAGE);\n  }\n}\n", "focal_file": "/*\n * Copyright (C) 2013 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.squareup.rack;\n\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.MarkerFactory;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\n/**\n * Adapts a {@link Logger} to the required interface for {@code rack.logger}.\n */\npublic class RackLogger {\n  public static final Marker FATAL = MarkerFactory.getMarker(\"FATAL\");\n\n  private final Logger logger;\n\n  /**\n   * Creates a {@link RackLogger} that forwards messages to the given {@link Logger}.\n   *\n   * @param logger\n   */\n  public RackLogger(Logger logger) {\n    this.logger = checkNotNull(logger);\n  }\n\n  public void info(String message) {\n    logger.info(message);\n  }\n\n  public void debug(String message) {\n    logger.debug(message);\n  }\n\n  public void warn(String message) {\n    logger.warn(message);\n  }\n\n  public void error(String message) {\n    logger.error(message);\n  }\n\n  public void fatal(String message) {\n    // See http://www.slf4j.org/faq.html#fatal\n    logger.error(FATAL, message);\n  }\n}\n"}
{"test_method": "@Test public void readWithLengthNilAgain() throws Exception {\n    full.read(null);\n    assertThat(full.read(null)).isEqualTo(EMPTY_BYTES);\n  }", "focal_method": "public byte[] read(Integer length) throws IOException {\n    if (length == null) {\n      return readToEof();\n    } else {\n      return readTo(length);\n    }\n  }", "test_file": "package com.squareup.rack;\n\nimport java.io.ByteArrayInputStream;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static java.util.Arrays.copyOfRange;\nimport static org.fest.assertions.api.Assertions.assertThat;\n\npublic class RackInputTest {\n  public static final byte[] EMPTY_BYTES = \"\".getBytes();\n  public static final byte[] BYTES = \"Hello,\\nWorld!\".getBytes();\n\n  private RackInput empty;\n  private RackInput full;\n  private RackInput fullSlow;\n\n  @Before public void setUp() throws Exception {\n    empty = rackInputFor(EMPTY_BYTES);\n    full = rackInputFor(BYTES);\n    fullSlow = slowRackInputFor(BYTES);\n  }\n\n  @Test public void getsAtEof() throws Exception {\n    assertThat(empty.gets()).isNull();\n  }\n\n  @Test public void gets() throws Exception {\n    assertThat(full.gets()).isEqualTo(\"Hello,\\n\".getBytes());\n  }\n\n  @Test public void getsWithCrLf() throws Exception {\n    assertThat(rackInputFor(\"Hello,\\r\\nWorld!\").gets()).isEqualTo(\"Hello,\\r\\n\".getBytes());\n  }\n\n  @Test public void getsAgain() throws Exception {\n    full.gets();\n    assertThat(full.gets()).isEqualTo(\"World!\".getBytes());\n  }\n\n  @Test public void readWithLengthNilAtEof() throws Exception {\n    assertThat(empty.read(null)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthZeroAtEof() throws Exception {\n    assertThat(empty.read(0)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthAtEof() throws Exception {\n    assertThat(empty.read(1)).isNull();\n  }\n\n  @Test public void readWithLengthNil() throws Exception {\n    assertThat(full.read(null)).isEqualTo(BYTES);\n  }\n\n  @Test public void readWithLengthNilAgain() throws Exception {\n    full.read(null);\n    assertThat(full.read(null)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthZero() throws Exception {\n    assertThat(full.read(0)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLength() throws Exception {\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void readWithLengthAgain() throws Exception {\n    full.read(4);\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 4, 8));\n  }\n\n  @Test public void readFromSlowStreamWithLength() throws Exception {\n    assertThat(fullSlow.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void readFromSlowStreamWithLengthAgain() throws Exception {\n    fullSlow.read(4);\n    assertThat(fullSlow.read(4)).isEqualTo(copyOfRange(BYTES, 4, 8));\n  }\n\n  @Test public void readWithLengthTooLong() throws Exception {\n    assertThat(full.read(BYTES.length + 1)).isEqualTo(BYTES);\n  }\n\n  @Test public void readWithLengthTooLongAgain() throws Exception {\n    full.read(BYTES.length + 1);\n    assertThat(full.read(BYTES.length + 1)).isNull();\n  }\n\n  @Test public void rewind() throws Exception {\n    full.read(4);\n    full.rewind();\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void rewind_shouldDiscardAnyBufferedBytes() throws Exception {\n    RackInput subject = rackInputFor(\"first line\\r\\n123\\r\\n456\\r\\n\");\n    subject.gets();\n    subject.rewind();\n    assertThat(subject.gets()).isEqualTo(\"first line\\r\\n\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"123\\r\\n\".getBytes());\n  }\n\n  @Test public void intermixingReadMethodsIsSafe() throws Exception {\n    RackInput subject = rackInputFor(\"first line\\r\\n123\\r\\n456\\r\\n\");\n    assertThat(subject.read(1)).isEqualTo(\"f\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"irst line\\r\\n\".getBytes());\n    assertThat(subject.read(null)).isEqualTo(\"123\\r\\n456\\r\\n\".getBytes());\n    subject.rewind();\n    assertThat(subject.gets()).isEqualTo(\"first line\\r\\n\".getBytes());\n    assertThat(subject.read(3)).isEqualTo(\"123\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"\\r\\n\".getBytes());\n    assertThat(subject.read(null)).isEqualTo(\"456\\r\\n\".getBytes());\n  }\n\n  private RackInput rackInputFor(String string) throws Exception {\n    return rackInputFor(string.getBytes());\n  }\n\n  private RackInput rackInputFor(byte[] bytes) throws Exception {\n    return new RackInput(new ByteArrayInputStream(bytes));\n  }\n\n  private RackInput slowRackInputFor(byte[] bytes) throws Exception {\n    return new RackInput(new SlowByteArrayInputStream(bytes));\n  }\n}\n", "focal_file": "/*\n * Copyright (C) 2013 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.squareup.rack;\n\nimport com.google.common.io.ByteStreams;\nimport com.squareup.rack.io.ByteArrayBuffer;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\n/**\n * <p>Adapts an {@link InputStream} to the required interface for {@code rack.input}.</p>\n *\n * <p>Speaks {@code byte[]}, not {@code String}, because {@code rack.input} is required to have\n * binary encoding.</p>\n */\npublic class RackInput implements Closeable {\n  private static final int LINEFEED = 0xA;\n  private static final int MAX_LINE_LENGTH = 1024 * 1024;\n  private static final int READ_AHEAD_SUGGESTION = 1024 * 1024;\n\n  private final InputStream stream;\n  private final ByteArrayBuffer buffer = new ByteArrayBuffer();\n  private int bufferReadHead;\n\n  /**\n   * Creates a {@link RackInput} stream that draws from the given {@link InputStream}.\n   *\n   * @param inputStream the source stream.\n   */\n  public RackInput(InputStream inputStream) {\n    checkNotNull(inputStream);\n    checkArgument(inputStream.markSupported(),\n        \"rack.input must be rewindable, but inputStream doesn't support mark.\");\n\n    stream = inputStream;\n    stream.mark(READ_AHEAD_SUGGESTION);\n  }\n\n  /**\n   * Reads the next line from the stream.\n   *\n   * @return the next line, or null at EOF.\n   * @throws IOException\n   */\n  public byte[] gets() throws IOException {\n    return readToLinefeed();\n  }\n\n  /**\n   * Reads length bytes from the stream. Reads all the way to EOF when length is null.\n   *\n   * @param length the desired number of bytes, or null.\n   * @return the bytes, or null at EOF when length is present.\n   * @throws IOException\n   */\n  public byte[] read(Integer length) throws IOException {\n    if (length == null) {\n      return readToEof();\n    } else {\n      return readTo(length);\n    }\n  }\n\n  /**\n   * Resets the stream, so that it may be read again from the beginning.\n   *\n   * @throws IOException\n   */\n  public void rewind() throws IOException {\n    stream.reset();\n    buffer.reset();\n    bufferReadHead = 0;\n  }\n\n  /**\n   * Closes the stream.\n   *\n   * @throws IOException\n   */\n  @Override public void close() throws IOException {\n    stream.close();\n  }\n\n  private byte[] readToLinefeed() throws IOException {\n    int startFrom = 0;\n    do {\n      int indexOfNewline = indexOfNextNewlineInBuffer(startFrom);\n\n      if (indexOfNewline == -1) {\n        int bytesPresent = bytesAvailableInBuffer();\n\n        if (bytesPresent > MAX_LINE_LENGTH) {\n          throw new RuntimeException(\n              \"Really, you have a line longer than \" + MAX_LINE_LENGTH + \" bytes?\");\n        }\n\n        // next time through, start where we left off.\n        startFrom = bytesPresent;\n\n        int bytesRead = fillBuffer(8 * 1024);\n        if (bytesRead == -1) {\n          int bytesRemaining = bytesAvailableInBuffer();\n          return consumeBytesFromBuffer(bytesRemaining);\n        }\n      } else {\n        int length = indexOfNewline - bufferReadHead + 1;\n        return consumeBytesFromBuffer(length);\n      }\n    } while (true);\n  }\n\n  private byte[] readToEof() throws IOException {\n    if (bufferReadHead > 0) {\n      compactBuffer(true);\n    }\n\n    ByteStreams.copy(stream, buffer);\n\n    int length = buffer.getLength();\n    if (length == 0) {\n      return new byte[0];\n    } else {\n      return consumeBytesFromBuffer(length);\n    }\n  }\n\n  private byte[] readTo(int length) throws IOException {\n    if (length == 0) {\n      return new byte[0];\n    }\n\n    if (bufferReadHead > 0) {\n      compactBuffer(true);\n    }\n\n    int bytesStillNeeded = length - buffer.getLength();\n    if (bytesStillNeeded > 0) {\n      int bytesRead = fillBuffer(bytesStillNeeded);\n      while (bytesRead != -1 && bytesStillNeeded > 0) {\n        bytesStillNeeded -= bytesRead;\n        bytesRead = fillBuffer(bytesStillNeeded);\n      }\n    }\n\n    return consumeBytesFromBuffer(length);\n  }\n\n  private int bytesAvailableInBuffer() {\n    return buffer.getLength() - bufferReadHead;\n  }\n\n  private int indexOfNextNewlineInBuffer(int startFrom) {\n    byte[] bytes = buffer.getBuffer();\n    int bufferLength = buffer.getLength();\n    for (int i = bufferReadHead + startFrom; i < bufferLength; i++) {\n      if (bytes[i] == LINEFEED) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  private int fillBuffer(int length) throws IOException {\n    compactBuffer(false);\n    byte[] readBuf = new byte[length];\n    int bytesRead = stream.read(readBuf);\n    if (bytesRead > 0) {\n      buffer.write(readBuf, 0, bytesRead);\n    }\n    return bytesRead;\n  }\n\n  private byte[] consumeBytesFromBuffer(int length) {\n    int bytesAvailable = bytesAvailableInBuffer();\n    if (length > bytesAvailable) {\n      length = bytesAvailable;\n    }\n\n    if (length == 0) {\n      return null;\n    }\n\n    byte[] bytes = new byte[length];\n    byte[] bufferBytes = buffer.getBuffer();\n    System.arraycopy(bufferBytes, bufferReadHead, bytes, 0, length);\n    bufferReadHead += length;\n    return bytes;\n  }\n\n  private void compactBuffer(boolean force) {\n    byte[] bufferBytes = buffer.getBuffer();\n\n    // normally, only compact if we're at least 1K in, and at least 3/4 of the way in\n    if (force || (bufferReadHead > 1024 && bufferReadHead > (bufferBytes.length * 3 / 4))) {\n      int remainingBytes = bytesAvailableInBuffer();\n      System.arraycopy(bufferBytes, bufferReadHead, bufferBytes, 0, remainingBytes);\n      buffer.setLength(remainingBytes);\n      bufferReadHead = 0;\n    }\n  }\n}\n"}
{"test_method": "@Test public void puts() {\n    rackErrors.puts(\"Boom!\");\n    verify(logger).error(\"Boom!\");\n  }", "focal_method": "public void puts(String message) {\n    logger.error(message);\n  }", "test_file": "package com.squareup.rack;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.InOrder;\nimport org.mockito.Mock;\nimport org.mockito.runners.MockitoJUnitRunner;\nimport org.slf4j.Logger;\n\nimport static org.mockito.Matchers.anyString;\nimport static org.mockito.Mockito.inOrder;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.verify;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class RackErrorsTest {\n  private RackErrors rackErrors;\n\n  @Mock private Logger logger;\n\n  @Before public void setUp() {\n    rackErrors = new RackErrors(logger);\n  }\n\n  @Test(expected = NullPointerException.class)\n  public void constructorRequiresALogger() {\n    new RackErrors(null);\n  }\n\n  @Test public void puts() {\n    rackErrors.puts(\"Boom!\");\n    verify(logger).error(\"Boom!\");\n  }\n\n  @Test public void write() {\n    rackErrors.write(\"Boom?\");\n    verify(logger, never()).error(anyString());\n  }\n\n  @Test public void writeThenFlush() {\n    rackErrors.write(\"Boom?\");\n    rackErrors.flush();\n    verify(logger).error(\"Boom?\");\n  }\n\n  @Test public void writeWriteWriteThenFlush() {\n    rackErrors.write(\"Boom?\");\n    rackErrors.write(\"Boom!\");\n    rackErrors.write(\"Boom\u2026\");\n    rackErrors.flush();\n    verify(logger).error(\"Boom?Boom!Boom\u2026\");\n  }\n\n  @Test public void flushOnEmpty() {\n    rackErrors.flush();\n    verify(logger, never()).error(anyString());\n  }\n\n  @Test public void writeFlushWriteFlush() {\n    rackErrors.write(\"A loooong message\");\n    rackErrors.flush();\n    rackErrors.write(\"A short msg\");\n    rackErrors.flush();\n\n    InOrder inOrder = inOrder(logger);\n    inOrder.verify(logger).error(\"A loooong message\");\n    inOrder.verify(logger).error(\"A short msg\");\n  }\n}\n", "focal_file": "/*\n * Copyright (C) 2013 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.squareup.rack;\n\nimport org.slf4j.Logger;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\n/**\n * Adapts a {@link Logger} to the required interface for {@code rack.errors}.\n */\npublic class RackErrors {\n  private final Logger logger;\n  private final StringBuffer buffer;\n\n  /**\n   * Creates a {@link RackErrors} stream that forwards messages to the given {@link Logger}.\n   *\n   * @param logger the destination {@link Logger}.\n   */\n  public RackErrors(Logger logger) {\n    this.logger = checkNotNull(logger);\n    this.buffer = new StringBuffer();\n  }\n\n  /**\n   * Immediately writes the given message out to the error logger.\n   *\n   * @param message\n   */\n  public void puts(String message) {\n    logger.error(message);\n  }\n\n  /**\n   * Buffers the given message internally. You may call {@link #write(String)} as many times as you\n   * like. To then write the composite buffered message to the error logger, call {@link #flush()}.\n   *\n   * @param message\n   */\n  public void write(String message) {\n    buffer.append(message);\n  }\n\n  /**\n   * Writes internally-buffered messages out to the error logger.\n   *\n   * @see #write(String)\n   */\n  public void flush() {\n    if (buffer.length() > 0) {\n      logger.error(buffer.toString());\n      buffer.setLength(0);\n    }\n  }\n}\n"}
{"test_method": "@Test public void gets() throws Exception {\n    assertThat(full.gets()).isEqualTo(\"Hello,\\n\".getBytes());\n  }", "focal_method": "public byte[] gets() throws IOException {\n    return readToLinefeed();\n  }", "test_file": "package com.squareup.rack;\n\nimport java.io.ByteArrayInputStream;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static java.util.Arrays.copyOfRange;\nimport static org.fest.assertions.api.Assertions.assertThat;\n\npublic class RackInputTest {\n  public static final byte[] EMPTY_BYTES = \"\".getBytes();\n  public static final byte[] BYTES = \"Hello,\\nWorld!\".getBytes();\n\n  private RackInput empty;\n  private RackInput full;\n  private RackInput fullSlow;\n\n  @Before public void setUp() throws Exception {\n    empty = rackInputFor(EMPTY_BYTES);\n    full = rackInputFor(BYTES);\n    fullSlow = slowRackInputFor(BYTES);\n  }\n\n  @Test public void getsAtEof() throws Exception {\n    assertThat(empty.gets()).isNull();\n  }\n\n  @Test public void gets() throws Exception {\n    assertThat(full.gets()).isEqualTo(\"Hello,\\n\".getBytes());\n  }\n\n  @Test public void getsWithCrLf() throws Exception {\n    assertThat(rackInputFor(\"Hello,\\r\\nWorld!\").gets()).isEqualTo(\"Hello,\\r\\n\".getBytes());\n  }\n\n  @Test public void getsAgain() throws Exception {\n    full.gets();\n    assertThat(full.gets()).isEqualTo(\"World!\".getBytes());\n  }\n\n  @Test public void readWithLengthNilAtEof() throws Exception {\n    assertThat(empty.read(null)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthZeroAtEof() throws Exception {\n    assertThat(empty.read(0)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthAtEof() throws Exception {\n    assertThat(empty.read(1)).isNull();\n  }\n\n  @Test public void readWithLengthNil() throws Exception {\n    assertThat(full.read(null)).isEqualTo(BYTES);\n  }\n\n  @Test public void readWithLengthNilAgain() throws Exception {\n    full.read(null);\n    assertThat(full.read(null)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthZero() throws Exception {\n    assertThat(full.read(0)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLength() throws Exception {\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void readWithLengthAgain() throws Exception {\n    full.read(4);\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 4, 8));\n  }\n\n  @Test public void readFromSlowStreamWithLength() throws Exception {\n    assertThat(fullSlow.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void readFromSlowStreamWithLengthAgain() throws Exception {\n    fullSlow.read(4);\n    assertThat(fullSlow.read(4)).isEqualTo(copyOfRange(BYTES, 4, 8));\n  }\n\n  @Test public void readWithLengthTooLong() throws Exception {\n    assertThat(full.read(BYTES.length + 1)).isEqualTo(BYTES);\n  }\n\n  @Test public void readWithLengthTooLongAgain() throws Exception {\n    full.read(BYTES.length + 1);\n    assertThat(full.read(BYTES.length + 1)).isNull();\n  }\n\n  @Test public void rewind() throws Exception {\n    full.read(4);\n    full.rewind();\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void rewind_shouldDiscardAnyBufferedBytes() throws Exception {\n    RackInput subject = rackInputFor(\"first line\\r\\n123\\r\\n456\\r\\n\");\n    subject.gets();\n    subject.rewind();\n    assertThat(subject.gets()).isEqualTo(\"first line\\r\\n\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"123\\r\\n\".getBytes());\n  }\n\n  @Test public void intermixingReadMethodsIsSafe() throws Exception {\n    RackInput subject = rackInputFor(\"first line\\r\\n123\\r\\n456\\r\\n\");\n    assertThat(subject.read(1)).isEqualTo(\"f\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"irst line\\r\\n\".getBytes());\n    assertThat(subject.read(null)).isEqualTo(\"123\\r\\n456\\r\\n\".getBytes());\n    subject.rewind();\n    assertThat(subject.gets()).isEqualTo(\"first line\\r\\n\".getBytes());\n    assertThat(subject.read(3)).isEqualTo(\"123\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"\\r\\n\".getBytes());\n    assertThat(subject.read(null)).isEqualTo(\"456\\r\\n\".getBytes());\n  }\n\n  private RackInput rackInputFor(String string) throws Exception {\n    return rackInputFor(string.getBytes());\n  }\n\n  private RackInput rackInputFor(byte[] bytes) throws Exception {\n    return new RackInput(new ByteArrayInputStream(bytes));\n  }\n\n  private RackInput slowRackInputFor(byte[] bytes) throws Exception {\n    return new RackInput(new SlowByteArrayInputStream(bytes));\n  }\n}\n", "focal_file": "/*\n * Copyright (C) 2013 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.squareup.rack;\n\nimport com.google.common.io.ByteStreams;\nimport com.squareup.rack.io.ByteArrayBuffer;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\n/**\n * <p>Adapts an {@link InputStream} to the required interface for {@code rack.input}.</p>\n *\n * <p>Speaks {@code byte[]}, not {@code String}, because {@code rack.input} is required to have\n * binary encoding.</p>\n */\npublic class RackInput implements Closeable {\n  private static final int LINEFEED = 0xA;\n  private static final int MAX_LINE_LENGTH = 1024 * 1024;\n  private static final int READ_AHEAD_SUGGESTION = 1024 * 1024;\n\n  private final InputStream stream;\n  private final ByteArrayBuffer buffer = new ByteArrayBuffer();\n  private int bufferReadHead;\n\n  /**\n   * Creates a {@link RackInput} stream that draws from the given {@link InputStream}.\n   *\n   * @param inputStream the source stream.\n   */\n  public RackInput(InputStream inputStream) {\n    checkNotNull(inputStream);\n    checkArgument(inputStream.markSupported(),\n        \"rack.input must be rewindable, but inputStream doesn't support mark.\");\n\n    stream = inputStream;\n    stream.mark(READ_AHEAD_SUGGESTION);\n  }\n\n  /**\n   * Reads the next line from the stream.\n   *\n   * @return the next line, or null at EOF.\n   * @throws IOException\n   */\n  public byte[] gets() throws IOException {\n    return readToLinefeed();\n  }\n\n  /**\n   * Reads length bytes from the stream. Reads all the way to EOF when length is null.\n   *\n   * @param length the desired number of bytes, or null.\n   * @return the bytes, or null at EOF when length is present.\n   * @throws IOException\n   */\n  public byte[] read(Integer length) throws IOException {\n    if (length == null) {\n      return readToEof();\n    } else {\n      return readTo(length);\n    }\n  }\n\n  /**\n   * Resets the stream, so that it may be read again from the beginning.\n   *\n   * @throws IOException\n   */\n  public void rewind() throws IOException {\n    stream.reset();\n    buffer.reset();\n    bufferReadHead = 0;\n  }\n\n  /**\n   * Closes the stream.\n   *\n   * @throws IOException\n   */\n  @Override public void close() throws IOException {\n    stream.close();\n  }\n\n  private byte[] readToLinefeed() throws IOException {\n    int startFrom = 0;\n    do {\n      int indexOfNewline = indexOfNextNewlineInBuffer(startFrom);\n\n      if (indexOfNewline == -1) {\n        int bytesPresent = bytesAvailableInBuffer();\n\n        if (bytesPresent > MAX_LINE_LENGTH) {\n          throw new RuntimeException(\n              \"Really, you have a line longer than \" + MAX_LINE_LENGTH + \" bytes?\");\n        }\n\n        // next time through, start where we left off.\n        startFrom = bytesPresent;\n\n        int bytesRead = fillBuffer(8 * 1024);\n        if (bytesRead == -1) {\n          int bytesRemaining = bytesAvailableInBuffer();\n          return consumeBytesFromBuffer(bytesRemaining);\n        }\n      } else {\n        int length = indexOfNewline - bufferReadHead + 1;\n        return consumeBytesFromBuffer(length);\n      }\n    } while (true);\n  }\n\n  private byte[] readToEof() throws IOException {\n    if (bufferReadHead > 0) {\n      compactBuffer(true);\n    }\n\n    ByteStreams.copy(stream, buffer);\n\n    int length = buffer.getLength();\n    if (length == 0) {\n      return new byte[0];\n    } else {\n      return consumeBytesFromBuffer(length);\n    }\n  }\n\n  private byte[] readTo(int length) throws IOException {\n    if (length == 0) {\n      return new byte[0];\n    }\n\n    if (bufferReadHead > 0) {\n      compactBuffer(true);\n    }\n\n    int bytesStillNeeded = length - buffer.getLength();\n    if (bytesStillNeeded > 0) {\n      int bytesRead = fillBuffer(bytesStillNeeded);\n      while (bytesRead != -1 && bytesStillNeeded > 0) {\n        bytesStillNeeded -= bytesRead;\n        bytesRead = fillBuffer(bytesStillNeeded);\n      }\n    }\n\n    return consumeBytesFromBuffer(length);\n  }\n\n  private int bytesAvailableInBuffer() {\n    return buffer.getLength() - bufferReadHead;\n  }\n\n  private int indexOfNextNewlineInBuffer(int startFrom) {\n    byte[] bytes = buffer.getBuffer();\n    int bufferLength = buffer.getLength();\n    for (int i = bufferReadHead + startFrom; i < bufferLength; i++) {\n      if (bytes[i] == LINEFEED) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  private int fillBuffer(int length) throws IOException {\n    compactBuffer(false);\n    byte[] readBuf = new byte[length];\n    int bytesRead = stream.read(readBuf);\n    if (bytesRead > 0) {\n      buffer.write(readBuf, 0, bytesRead);\n    }\n    return bytesRead;\n  }\n\n  private byte[] consumeBytesFromBuffer(int length) {\n    int bytesAvailable = bytesAvailableInBuffer();\n    if (length > bytesAvailable) {\n      length = bytesAvailable;\n    }\n\n    if (length == 0) {\n      return null;\n    }\n\n    byte[] bytes = new byte[length];\n    byte[] bufferBytes = buffer.getBuffer();\n    System.arraycopy(bufferBytes, bufferReadHead, bytes, 0, length);\n    bufferReadHead += length;\n    return bytes;\n  }\n\n  private void compactBuffer(boolean force) {\n    byte[] bufferBytes = buffer.getBuffer();\n\n    // normally, only compact if we're at least 1K in, and at least 3/4 of the way in\n    if (force || (bufferReadHead > 1024 && bufferReadHead > (bufferBytes.length * 3 / 4))) {\n      int remainingBytes = bytesAvailableInBuffer();\n      System.arraycopy(bufferBytes, bufferReadHead, bufferBytes, 0, remainingBytes);\n      buffer.setLength(remainingBytes);\n      bufferReadHead = 0;\n    }\n  }\n}\n"}
{"test_method": "@Test public void getsWithCrLf() throws Exception {\n    assertThat(rackInputFor(\"Hello,\\r\\nWorld!\").gets()).isEqualTo(\"Hello,\\r\\n\".getBytes());\n  }", "focal_method": "public byte[] gets() throws IOException {\n    return readToLinefeed();\n  }", "test_file": "package com.squareup.rack;\n\nimport java.io.ByteArrayInputStream;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static java.util.Arrays.copyOfRange;\nimport static org.fest.assertions.api.Assertions.assertThat;\n\npublic class RackInputTest {\n  public static final byte[] EMPTY_BYTES = \"\".getBytes();\n  public static final byte[] BYTES = \"Hello,\\nWorld!\".getBytes();\n\n  private RackInput empty;\n  private RackInput full;\n  private RackInput fullSlow;\n\n  @Before public void setUp() throws Exception {\n    empty = rackInputFor(EMPTY_BYTES);\n    full = rackInputFor(BYTES);\n    fullSlow = slowRackInputFor(BYTES);\n  }\n\n  @Test public void getsAtEof() throws Exception {\n    assertThat(empty.gets()).isNull();\n  }\n\n  @Test public void gets() throws Exception {\n    assertThat(full.gets()).isEqualTo(\"Hello,\\n\".getBytes());\n  }\n\n  @Test public void getsWithCrLf() throws Exception {\n    assertThat(rackInputFor(\"Hello,\\r\\nWorld!\").gets()).isEqualTo(\"Hello,\\r\\n\".getBytes());\n  }\n\n  @Test public void getsAgain() throws Exception {\n    full.gets();\n    assertThat(full.gets()).isEqualTo(\"World!\".getBytes());\n  }\n\n  @Test public void readWithLengthNilAtEof() throws Exception {\n    assertThat(empty.read(null)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthZeroAtEof() throws Exception {\n    assertThat(empty.read(0)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthAtEof() throws Exception {\n    assertThat(empty.read(1)).isNull();\n  }\n\n  @Test public void readWithLengthNil() throws Exception {\n    assertThat(full.read(null)).isEqualTo(BYTES);\n  }\n\n  @Test public void readWithLengthNilAgain() throws Exception {\n    full.read(null);\n    assertThat(full.read(null)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthZero() throws Exception {\n    assertThat(full.read(0)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLength() throws Exception {\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void readWithLengthAgain() throws Exception {\n    full.read(4);\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 4, 8));\n  }\n\n  @Test public void readFromSlowStreamWithLength() throws Exception {\n    assertThat(fullSlow.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void readFromSlowStreamWithLengthAgain() throws Exception {\n    fullSlow.read(4);\n    assertThat(fullSlow.read(4)).isEqualTo(copyOfRange(BYTES, 4, 8));\n  }\n\n  @Test public void readWithLengthTooLong() throws Exception {\n    assertThat(full.read(BYTES.length + 1)).isEqualTo(BYTES);\n  }\n\n  @Test public void readWithLengthTooLongAgain() throws Exception {\n    full.read(BYTES.length + 1);\n    assertThat(full.read(BYTES.length + 1)).isNull();\n  }\n\n  @Test public void rewind() throws Exception {\n    full.read(4);\n    full.rewind();\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void rewind_shouldDiscardAnyBufferedBytes() throws Exception {\n    RackInput subject = rackInputFor(\"first line\\r\\n123\\r\\n456\\r\\n\");\n    subject.gets();\n    subject.rewind();\n    assertThat(subject.gets()).isEqualTo(\"first line\\r\\n\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"123\\r\\n\".getBytes());\n  }\n\n  @Test public void intermixingReadMethodsIsSafe() throws Exception {\n    RackInput subject = rackInputFor(\"first line\\r\\n123\\r\\n456\\r\\n\");\n    assertThat(subject.read(1)).isEqualTo(\"f\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"irst line\\r\\n\".getBytes());\n    assertThat(subject.read(null)).isEqualTo(\"123\\r\\n456\\r\\n\".getBytes());\n    subject.rewind();\n    assertThat(subject.gets()).isEqualTo(\"first line\\r\\n\".getBytes());\n    assertThat(subject.read(3)).isEqualTo(\"123\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"\\r\\n\".getBytes());\n    assertThat(subject.read(null)).isEqualTo(\"456\\r\\n\".getBytes());\n  }\n\n  private RackInput rackInputFor(String string) throws Exception {\n    return rackInputFor(string.getBytes());\n  }\n\n  private RackInput rackInputFor(byte[] bytes) throws Exception {\n    return new RackInput(new ByteArrayInputStream(bytes));\n  }\n\n  private RackInput slowRackInputFor(byte[] bytes) throws Exception {\n    return new RackInput(new SlowByteArrayInputStream(bytes));\n  }\n}\n", "focal_file": "/*\n * Copyright (C) 2013 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.squareup.rack;\n\nimport com.google.common.io.ByteStreams;\nimport com.squareup.rack.io.ByteArrayBuffer;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\n/**\n * <p>Adapts an {@link InputStream} to the required interface for {@code rack.input}.</p>\n *\n * <p>Speaks {@code byte[]}, not {@code String}, because {@code rack.input} is required to have\n * binary encoding.</p>\n */\npublic class RackInput implements Closeable {\n  private static final int LINEFEED = 0xA;\n  private static final int MAX_LINE_LENGTH = 1024 * 1024;\n  private static final int READ_AHEAD_SUGGESTION = 1024 * 1024;\n\n  private final InputStream stream;\n  private final ByteArrayBuffer buffer = new ByteArrayBuffer();\n  private int bufferReadHead;\n\n  /**\n   * Creates a {@link RackInput} stream that draws from the given {@link InputStream}.\n   *\n   * @param inputStream the source stream.\n   */\n  public RackInput(InputStream inputStream) {\n    checkNotNull(inputStream);\n    checkArgument(inputStream.markSupported(),\n        \"rack.input must be rewindable, but inputStream doesn't support mark.\");\n\n    stream = inputStream;\n    stream.mark(READ_AHEAD_SUGGESTION);\n  }\n\n  /**\n   * Reads the next line from the stream.\n   *\n   * @return the next line, or null at EOF.\n   * @throws IOException\n   */\n  public byte[] gets() throws IOException {\n    return readToLinefeed();\n  }\n\n  /**\n   * Reads length bytes from the stream. Reads all the way to EOF when length is null.\n   *\n   * @param length the desired number of bytes, or null.\n   * @return the bytes, or null at EOF when length is present.\n   * @throws IOException\n   */\n  public byte[] read(Integer length) throws IOException {\n    if (length == null) {\n      return readToEof();\n    } else {\n      return readTo(length);\n    }\n  }\n\n  /**\n   * Resets the stream, so that it may be read again from the beginning.\n   *\n   * @throws IOException\n   */\n  public void rewind() throws IOException {\n    stream.reset();\n    buffer.reset();\n    bufferReadHead = 0;\n  }\n\n  /**\n   * Closes the stream.\n   *\n   * @throws IOException\n   */\n  @Override public void close() throws IOException {\n    stream.close();\n  }\n\n  private byte[] readToLinefeed() throws IOException {\n    int startFrom = 0;\n    do {\n      int indexOfNewline = indexOfNextNewlineInBuffer(startFrom);\n\n      if (indexOfNewline == -1) {\n        int bytesPresent = bytesAvailableInBuffer();\n\n        if (bytesPresent > MAX_LINE_LENGTH) {\n          throw new RuntimeException(\n              \"Really, you have a line longer than \" + MAX_LINE_LENGTH + \" bytes?\");\n        }\n\n        // next time through, start where we left off.\n        startFrom = bytesPresent;\n\n        int bytesRead = fillBuffer(8 * 1024);\n        if (bytesRead == -1) {\n          int bytesRemaining = bytesAvailableInBuffer();\n          return consumeBytesFromBuffer(bytesRemaining);\n        }\n      } else {\n        int length = indexOfNewline - bufferReadHead + 1;\n        return consumeBytesFromBuffer(length);\n      }\n    } while (true);\n  }\n\n  private byte[] readToEof() throws IOException {\n    if (bufferReadHead > 0) {\n      compactBuffer(true);\n    }\n\n    ByteStreams.copy(stream, buffer);\n\n    int length = buffer.getLength();\n    if (length == 0) {\n      return new byte[0];\n    } else {\n      return consumeBytesFromBuffer(length);\n    }\n  }\n\n  private byte[] readTo(int length) throws IOException {\n    if (length == 0) {\n      return new byte[0];\n    }\n\n    if (bufferReadHead > 0) {\n      compactBuffer(true);\n    }\n\n    int bytesStillNeeded = length - buffer.getLength();\n    if (bytesStillNeeded > 0) {\n      int bytesRead = fillBuffer(bytesStillNeeded);\n      while (bytesRead != -1 && bytesStillNeeded > 0) {\n        bytesStillNeeded -= bytesRead;\n        bytesRead = fillBuffer(bytesStillNeeded);\n      }\n    }\n\n    return consumeBytesFromBuffer(length);\n  }\n\n  private int bytesAvailableInBuffer() {\n    return buffer.getLength() - bufferReadHead;\n  }\n\n  private int indexOfNextNewlineInBuffer(int startFrom) {\n    byte[] bytes = buffer.getBuffer();\n    int bufferLength = buffer.getLength();\n    for (int i = bufferReadHead + startFrom; i < bufferLength; i++) {\n      if (bytes[i] == LINEFEED) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  private int fillBuffer(int length) throws IOException {\n    compactBuffer(false);\n    byte[] readBuf = new byte[length];\n    int bytesRead = stream.read(readBuf);\n    if (bytesRead > 0) {\n      buffer.write(readBuf, 0, bytesRead);\n    }\n    return bytesRead;\n  }\n\n  private byte[] consumeBytesFromBuffer(int length) {\n    int bytesAvailable = bytesAvailableInBuffer();\n    if (length > bytesAvailable) {\n      length = bytesAvailable;\n    }\n\n    if (length == 0) {\n      return null;\n    }\n\n    byte[] bytes = new byte[length];\n    byte[] bufferBytes = buffer.getBuffer();\n    System.arraycopy(bufferBytes, bufferReadHead, bytes, 0, length);\n    bufferReadHead += length;\n    return bytes;\n  }\n\n  private void compactBuffer(boolean force) {\n    byte[] bufferBytes = buffer.getBuffer();\n\n    // normally, only compact if we're at least 1K in, and at least 3/4 of the way in\n    if (force || (bufferReadHead > 1024 && bufferReadHead > (bufferBytes.length * 3 / 4))) {\n      int remainingBytes = bytesAvailableInBuffer();\n      System.arraycopy(bufferBytes, bufferReadHead, bufferBytes, 0, remainingBytes);\n      buffer.setLength(remainingBytes);\n      bufferReadHead = 0;\n    }\n  }\n}\n"}
{"test_method": "@Test public void callParsesTheResponseStatusFromAString() {\n    IRubyObject callable = Ruby.getGlobalRuntime()\n        .evalScriptlet(\"proc { |env| ['201', {'Content-Type' => 'text/plain'}, env.keys] }\");\n    app = new JRubyRackApplication(callable);\n\n    RackResponse response = app.call(env);\n    assertThat(response.getStatus()).isEqualTo(201);\n  }", "focal_method": "@Override public RackResponse call(RackEnvironment environment) {\n    RubyHash environmentHash = convertToRubyHash(environment.entrySet());\n\n    RubyArray response = callRackApplication(environmentHash);\n\n    return convertToJavaRackResponse(response);\n  }", "test_file": "package com.squareup.rack.jruby;\n\nimport com.google.common.base.Joiner;\nimport com.google.common.collect.ImmutableList;\nimport com.squareup.rack.RackApplication;\nimport com.squareup.rack.RackEnvironment;\nimport com.squareup.rack.RackResponse;\nimport com.squareup.rack.servlet.RackEnvironmentBuilder;\nimport com.squareup.rack.servlet.TestHttpServletRequest;\nimport java.util.Iterator;\nimport org.jruby.Ruby;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static org.fest.assertions.api.Assertions.assertThat;\nimport static org.fest.assertions.data.MapEntry.entry;\n\npublic class JRubyRackApplicationTest {\n  private static final Joiner SPACE = Joiner.on(' ');\n\n  private RackApplication app;\n  private RackEnvironment env;\n\n  @Before public void setUp() {\n    IRubyObject callable = Ruby.getGlobalRuntime()\n        .evalScriptlet(\"proc { |env| [200, {'Content-Type' => 'text/plain'}, env.keys] }\");\n\n    RackEnvironmentBuilder envBuilder = new RackEnvironmentBuilder();\n    TestHttpServletRequest request = TestHttpServletRequest.newBuilder().build();\n    app = new JRubyRackApplication(callable);\n    env = envBuilder.build(request);\n  }\n\n  @Test public void callSetsTheResponseStatus() {\n    RackResponse response = app.call(env);\n    assertThat(response.getStatus()).isEqualTo(200);\n  }\n\n  @Test public void callSetsTheResponseHeaders() {\n    RackResponse response = app.call(env);\n    assertThat(response.getHeaders()).contains(entry(\"Content-Type\", \"text/plain\"));\n  }\n\n  @Test public void callSetsTheResponseBody() {\n    RackResponse response = app.call(env);\n\n    ImmutableList.Builder<String> strings = ImmutableList.builder();\n\n    Iterator<byte[]> bytes = response.getBody();\n    while (bytes.hasNext()) {\n      strings.add(new String(bytes.next()));\n    }\n\n    assertThat(SPACE.join(strings.build())).isEqualTo(SPACE.join(env.keySet()));\n  }\n\n  @Test public void callParsesTheResponseStatusFromAString() {\n    IRubyObject callable = Ruby.getGlobalRuntime()\n        .evalScriptlet(\"proc { |env| ['201', {'Content-Type' => 'text/plain'}, env.keys] }\");\n    app = new JRubyRackApplication(callable);\n\n    RackResponse response = app.call(env);\n    assertThat(response.getStatus()).isEqualTo(201);\n  }\n}\n", "focal_file": "/*\n * Copyright (C) 2013 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.squareup.rack.jruby;\n\nimport com.squareup.rack.RackApplication;\nimport com.squareup.rack.RackEnvironment;\nimport com.squareup.rack.RackInput;\nimport com.squareup.rack.RackResponse;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport org.jruby.Ruby;\nimport org.jruby.RubyArray;\nimport org.jruby.RubyHash;\nimport org.jruby.internal.runtime.ThreadService;\nimport org.jruby.runtime.builtin.IRubyObject;\n\nimport static org.jruby.RubyHash.newHash;\n\n/**\n * Adapts a (RubyObject) Rack application into Java-space.\n */\npublic class JRubyRackApplication implements RackApplication {\n  private final IRubyObject application;\n  private final Ruby runtime;\n  private final ThreadService threadService;\n\n  /**\n   * <p>Creates a {@link RackApplication} that delegates to the given Ruby Rack application.</p>\n   *\n   * <p>To obtain the necessary {@link IRubyObject}, you can create a JRuby\n   * {@link org.jruby.embed.ScriptingContainer} and {@link org.jruby.embed.ScriptingContainer#parse}\n   * and {@link org.jruby.embed.EmbedEvalUnit#run()} your Ruby code. See our examples for concrete\n   * code.</p>\n   *\n   * @param application the Ruby Rack application.\n   */\n  public JRubyRackApplication(IRubyObject application) {\n    this.application = application;\n    this.runtime = application.getRuntime();\n    this.threadService = runtime.getThreadService();\n  }\n\n  /**\n   * Calls the delegate Rack application, translating into and back out of the JRuby interpreter.\n   *\n   * @param environment the Rack environment\n   * @return the Rack response\n   */\n  @Override public RackResponse call(RackEnvironment environment) {\n    RubyHash environmentHash = convertToRubyHash(environment.entrySet());\n\n    RubyArray response = callRackApplication(environmentHash);\n\n    return convertToJavaRackResponse(response);\n  }\n\n  private RubyHash convertToRubyHash(Set<Map.Entry<String, Object>> entries) {\n    RubyHash hash = newHash(runtime);\n\n    for (Map.Entry<String, Object> entry : entries) {\n      String key = entry.getKey();\n      Object value = entry.getValue();\n\n      if (key.equals(\"rack.input\")) {\n        value = new JRubyRackInput(runtime, (RackInput) value);\n      }\n\n      if (key.equals(\"rack.version\")) {\n        value = convertToRubyArray((List<Integer>) value);\n      }\n\n      hash.put(key, value);\n    }\n\n    return hash;\n  }\n\n  private RubyArray convertToRubyArray(List<Integer> list) {\n    RubyArray array = RubyArray.newEmptyArray(runtime);\n    array.addAll(list);\n    return array;\n  }\n\n  private RubyArray callRackApplication(RubyHash rubyHash) {\n    return (RubyArray) application.callMethod(threadService.getCurrentContext(), \"call\", rubyHash);\n  }\n\n  private RackResponse convertToJavaRackResponse(RubyArray response) {\n    int status = Integer.parseInt(response.get(0).toString(), 10);\n    Map headers = (Map) response.get(1);\n    IRubyObject body = (IRubyObject) response.get(2);\n\n    return new RackResponse(status, headers, new JRubyRackBodyIterator(body));\n  }\n}\n"}
{"test_method": "@Test public void readWithLengthAgain() throws Exception {\n    full.read(4);\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 4, 8));\n  }", "focal_method": "public byte[] read(Integer length) throws IOException {\n    if (length == null) {\n      return readToEof();\n    } else {\n      return readTo(length);\n    }\n  }", "test_file": "package com.squareup.rack;\n\nimport java.io.ByteArrayInputStream;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static java.util.Arrays.copyOfRange;\nimport static org.fest.assertions.api.Assertions.assertThat;\n\npublic class RackInputTest {\n  public static final byte[] EMPTY_BYTES = \"\".getBytes();\n  public static final byte[] BYTES = \"Hello,\\nWorld!\".getBytes();\n\n  private RackInput empty;\n  private RackInput full;\n  private RackInput fullSlow;\n\n  @Before public void setUp() throws Exception {\n    empty = rackInputFor(EMPTY_BYTES);\n    full = rackInputFor(BYTES);\n    fullSlow = slowRackInputFor(BYTES);\n  }\n\n  @Test public void getsAtEof() throws Exception {\n    assertThat(empty.gets()).isNull();\n  }\n\n  @Test public void gets() throws Exception {\n    assertThat(full.gets()).isEqualTo(\"Hello,\\n\".getBytes());\n  }\n\n  @Test public void getsWithCrLf() throws Exception {\n    assertThat(rackInputFor(\"Hello,\\r\\nWorld!\").gets()).isEqualTo(\"Hello,\\r\\n\".getBytes());\n  }\n\n  @Test public void getsAgain() throws Exception {\n    full.gets();\n    assertThat(full.gets()).isEqualTo(\"World!\".getBytes());\n  }\n\n  @Test public void readWithLengthNilAtEof() throws Exception {\n    assertThat(empty.read(null)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthZeroAtEof() throws Exception {\n    assertThat(empty.read(0)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthAtEof() throws Exception {\n    assertThat(empty.read(1)).isNull();\n  }\n\n  @Test public void readWithLengthNil() throws Exception {\n    assertThat(full.read(null)).isEqualTo(BYTES);\n  }\n\n  @Test public void readWithLengthNilAgain() throws Exception {\n    full.read(null);\n    assertThat(full.read(null)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthZero() throws Exception {\n    assertThat(full.read(0)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLength() throws Exception {\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void readWithLengthAgain() throws Exception {\n    full.read(4);\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 4, 8));\n  }\n\n  @Test public void readFromSlowStreamWithLength() throws Exception {\n    assertThat(fullSlow.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void readFromSlowStreamWithLengthAgain() throws Exception {\n    fullSlow.read(4);\n    assertThat(fullSlow.read(4)).isEqualTo(copyOfRange(BYTES, 4, 8));\n  }\n\n  @Test public void readWithLengthTooLong() throws Exception {\n    assertThat(full.read(BYTES.length + 1)).isEqualTo(BYTES);\n  }\n\n  @Test public void readWithLengthTooLongAgain() throws Exception {\n    full.read(BYTES.length + 1);\n    assertThat(full.read(BYTES.length + 1)).isNull();\n  }\n\n  @Test public void rewind() throws Exception {\n    full.read(4);\n    full.rewind();\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void rewind_shouldDiscardAnyBufferedBytes() throws Exception {\n    RackInput subject = rackInputFor(\"first line\\r\\n123\\r\\n456\\r\\n\");\n    subject.gets();\n    subject.rewind();\n    assertThat(subject.gets()).isEqualTo(\"first line\\r\\n\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"123\\r\\n\".getBytes());\n  }\n\n  @Test public void intermixingReadMethodsIsSafe() throws Exception {\n    RackInput subject = rackInputFor(\"first line\\r\\n123\\r\\n456\\r\\n\");\n    assertThat(subject.read(1)).isEqualTo(\"f\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"irst line\\r\\n\".getBytes());\n    assertThat(subject.read(null)).isEqualTo(\"123\\r\\n456\\r\\n\".getBytes());\n    subject.rewind();\n    assertThat(subject.gets()).isEqualTo(\"first line\\r\\n\".getBytes());\n    assertThat(subject.read(3)).isEqualTo(\"123\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"\\r\\n\".getBytes());\n    assertThat(subject.read(null)).isEqualTo(\"456\\r\\n\".getBytes());\n  }\n\n  private RackInput rackInputFor(String string) throws Exception {\n    return rackInputFor(string.getBytes());\n  }\n\n  private RackInput rackInputFor(byte[] bytes) throws Exception {\n    return new RackInput(new ByteArrayInputStream(bytes));\n  }\n\n  private RackInput slowRackInputFor(byte[] bytes) throws Exception {\n    return new RackInput(new SlowByteArrayInputStream(bytes));\n  }\n}\n", "focal_file": "/*\n * Copyright (C) 2013 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.squareup.rack;\n\nimport com.google.common.io.ByteStreams;\nimport com.squareup.rack.io.ByteArrayBuffer;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\n/**\n * <p>Adapts an {@link InputStream} to the required interface for {@code rack.input}.</p>\n *\n * <p>Speaks {@code byte[]}, not {@code String}, because {@code rack.input} is required to have\n * binary encoding.</p>\n */\npublic class RackInput implements Closeable {\n  private static final int LINEFEED = 0xA;\n  private static final int MAX_LINE_LENGTH = 1024 * 1024;\n  private static final int READ_AHEAD_SUGGESTION = 1024 * 1024;\n\n  private final InputStream stream;\n  private final ByteArrayBuffer buffer = new ByteArrayBuffer();\n  private int bufferReadHead;\n\n  /**\n   * Creates a {@link RackInput} stream that draws from the given {@link InputStream}.\n   *\n   * @param inputStream the source stream.\n   */\n  public RackInput(InputStream inputStream) {\n    checkNotNull(inputStream);\n    checkArgument(inputStream.markSupported(),\n        \"rack.input must be rewindable, but inputStream doesn't support mark.\");\n\n    stream = inputStream;\n    stream.mark(READ_AHEAD_SUGGESTION);\n  }\n\n  /**\n   * Reads the next line from the stream.\n   *\n   * @return the next line, or null at EOF.\n   * @throws IOException\n   */\n  public byte[] gets() throws IOException {\n    return readToLinefeed();\n  }\n\n  /**\n   * Reads length bytes from the stream. Reads all the way to EOF when length is null.\n   *\n   * @param length the desired number of bytes, or null.\n   * @return the bytes, or null at EOF when length is present.\n   * @throws IOException\n   */\n  public byte[] read(Integer length) throws IOException {\n    if (length == null) {\n      return readToEof();\n    } else {\n      return readTo(length);\n    }\n  }\n\n  /**\n   * Resets the stream, so that it may be read again from the beginning.\n   *\n   * @throws IOException\n   */\n  public void rewind() throws IOException {\n    stream.reset();\n    buffer.reset();\n    bufferReadHead = 0;\n  }\n\n  /**\n   * Closes the stream.\n   *\n   * @throws IOException\n   */\n  @Override public void close() throws IOException {\n    stream.close();\n  }\n\n  private byte[] readToLinefeed() throws IOException {\n    int startFrom = 0;\n    do {\n      int indexOfNewline = indexOfNextNewlineInBuffer(startFrom);\n\n      if (indexOfNewline == -1) {\n        int bytesPresent = bytesAvailableInBuffer();\n\n        if (bytesPresent > MAX_LINE_LENGTH) {\n          throw new RuntimeException(\n              \"Really, you have a line longer than \" + MAX_LINE_LENGTH + \" bytes?\");\n        }\n\n        // next time through, start where we left off.\n        startFrom = bytesPresent;\n\n        int bytesRead = fillBuffer(8 * 1024);\n        if (bytesRead == -1) {\n          int bytesRemaining = bytesAvailableInBuffer();\n          return consumeBytesFromBuffer(bytesRemaining);\n        }\n      } else {\n        int length = indexOfNewline - bufferReadHead + 1;\n        return consumeBytesFromBuffer(length);\n      }\n    } while (true);\n  }\n\n  private byte[] readToEof() throws IOException {\n    if (bufferReadHead > 0) {\n      compactBuffer(true);\n    }\n\n    ByteStreams.copy(stream, buffer);\n\n    int length = buffer.getLength();\n    if (length == 0) {\n      return new byte[0];\n    } else {\n      return consumeBytesFromBuffer(length);\n    }\n  }\n\n  private byte[] readTo(int length) throws IOException {\n    if (length == 0) {\n      return new byte[0];\n    }\n\n    if (bufferReadHead > 0) {\n      compactBuffer(true);\n    }\n\n    int bytesStillNeeded = length - buffer.getLength();\n    if (bytesStillNeeded > 0) {\n      int bytesRead = fillBuffer(bytesStillNeeded);\n      while (bytesRead != -1 && bytesStillNeeded > 0) {\n        bytesStillNeeded -= bytesRead;\n        bytesRead = fillBuffer(bytesStillNeeded);\n      }\n    }\n\n    return consumeBytesFromBuffer(length);\n  }\n\n  private int bytesAvailableInBuffer() {\n    return buffer.getLength() - bufferReadHead;\n  }\n\n  private int indexOfNextNewlineInBuffer(int startFrom) {\n    byte[] bytes = buffer.getBuffer();\n    int bufferLength = buffer.getLength();\n    for (int i = bufferReadHead + startFrom; i < bufferLength; i++) {\n      if (bytes[i] == LINEFEED) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  private int fillBuffer(int length) throws IOException {\n    compactBuffer(false);\n    byte[] readBuf = new byte[length];\n    int bytesRead = stream.read(readBuf);\n    if (bytesRead > 0) {\n      buffer.write(readBuf, 0, bytesRead);\n    }\n    return bytesRead;\n  }\n\n  private byte[] consumeBytesFromBuffer(int length) {\n    int bytesAvailable = bytesAvailableInBuffer();\n    if (length > bytesAvailable) {\n      length = bytesAvailable;\n    }\n\n    if (length == 0) {\n      return null;\n    }\n\n    byte[] bytes = new byte[length];\n    byte[] bufferBytes = buffer.getBuffer();\n    System.arraycopy(bufferBytes, bufferReadHead, bytes, 0, length);\n    bufferReadHead += length;\n    return bytes;\n  }\n\n  private void compactBuffer(boolean force) {\n    byte[] bufferBytes = buffer.getBuffer();\n\n    // normally, only compact if we're at least 1K in, and at least 3/4 of the way in\n    if (force || (bufferReadHead > 1024 && bufferReadHead > (bufferBytes.length * 3 / 4))) {\n      int remainingBytes = bytesAvailableInBuffer();\n      System.arraycopy(bufferBytes, bufferReadHead, bufferBytes, 0, remainingBytes);\n      buffer.setLength(remainingBytes);\n      bufferReadHead = 0;\n    }\n  }\n}\n"}
{"test_method": "@Test public void service() throws ServletException, IOException {\n    when(rackApplication.call(rackEnvironment)).thenReturn(rackResponse);\n\n    subject.service(request, response);\n\n    InOrder inOrder = inOrder(rackResponsePropagator, rackEnvironment);\n    inOrder.verify(rackResponsePropagator).propagate(rackResponse, response);\n    inOrder.verify(rackEnvironment).closeRackInput();\n  }", "focal_method": "@Override protected void service(HttpServletRequest request, HttpServletResponse response)\n      throws ServletException, IOException {\n    RackEnvironment rackEnvironment = rackEnvironmentBuilder.build(request);\n\n    try {\n      RackResponse rackResponse = rackApplication.call(rackEnvironment);\n      rackResponsePropagator.propagate(rackResponse, response);\n    } finally {\n      rackEnvironment.closeRackInput();\n    }\n  }", "test_file": "package com.squareup.rack.servlet;\n\nimport com.squareup.rack.RackApplication;\nimport com.squareup.rack.RackEnvironment;\nimport com.squareup.rack.RackResponse;\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.InOrder;\nimport org.mockito.Mock;\nimport org.mockito.runners.MockitoJUnitRunner;\n\nimport static org.mockito.Mockito.inOrder;\nimport static org.mockito.Mockito.when;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class RackServletTest {\n  private RackServlet subject;\n\n  @Mock private HttpServletRequest request;\n  @Mock private HttpServletResponse response;\n  @Mock private RackApplication rackApplication;\n  @Mock private RackEnvironmentBuilder rackEnvironmentBuilder;\n  @Mock private RackEnvironment rackEnvironment;\n  @Mock private RackResponse rackResponse;\n  @Mock private RackResponsePropagator rackResponsePropagator;\n\n  @Before public void setUp() {\n    subject = new RackServlet(rackEnvironmentBuilder, rackApplication, rackResponsePropagator);\n    when(rackEnvironmentBuilder.build(request)).thenReturn(rackEnvironment);\n  }\n\n  @Test public void service() throws ServletException, IOException {\n    when(rackApplication.call(rackEnvironment)).thenReturn(rackResponse);\n\n    subject.service(request, response);\n\n    InOrder inOrder = inOrder(rackResponsePropagator, rackEnvironment);\n    inOrder.verify(rackResponsePropagator).propagate(rackResponse, response);\n    inOrder.verify(rackEnvironment).closeRackInput();\n  }\n}\n", "focal_file": "/*\n * Copyright (C) 2013 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.squareup.rack.servlet;\n\nimport com.squareup.rack.RackApplication;\nimport com.squareup.rack.RackEnvironment;\nimport com.squareup.rack.RackResponse;\nimport java.io.IOException;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n/**\n * <p>Hosts a {@link RackApplication}.</p>\n *\n * <p>Since RackServlet lacks a zero-argument constructor, you'll need to manually instantiate and\n * install it in your container, rather than declaring it in a {@code web.xml} file. See our\n * examples for concrete code.</p>\n */\npublic class RackServlet extends HttpServlet {\n  private final RackEnvironmentBuilder rackEnvironmentBuilder;\n  private final RackApplication rackApplication;\n  private final RackResponsePropagator rackResponsePropagator;\n\n  /**\n   * Creates a servlet hosting the given {@link RackApplication}.\n   *\n   * @param rackApplication the application to host.\n   */\n  public RackServlet(RackApplication rackApplication) {\n    this(new RackEnvironmentBuilder(), rackApplication, new RackResponsePropagator());\n  }\n\n  /**\n   * Creates a servlet hosting the given {@link RackApplication} and that uses the given\n   * collaborators to translate between the Servlet and Rack environments.\n   *\n   * @param rackEnvironmentBuilder turns {@link HttpServletRequest}s into {@link RackEnvironment}s.\n   * @param rackApplication the application to host.\n   * @param rackResponsePropagator writes {@link RackResponse}s onto {@link HttpServletResponse}s.\n   */\n  public RackServlet(RackEnvironmentBuilder rackEnvironmentBuilder,\n      RackApplication rackApplication,\n      RackResponsePropagator rackResponsePropagator) {\n    this.rackEnvironmentBuilder = rackEnvironmentBuilder;\n    this.rackApplication = rackApplication;\n    this.rackResponsePropagator = rackResponsePropagator;\n  }\n\n  @Override protected void service(HttpServletRequest request, HttpServletResponse response)\n      throws ServletException, IOException {\n    RackEnvironment rackEnvironment = rackEnvironmentBuilder.build(request);\n\n    try {\n      RackResponse rackResponse = rackApplication.call(rackEnvironment);\n      rackResponsePropagator.propagate(rackResponse, response);\n    } finally {\n      rackEnvironment.closeRackInput();\n    }\n  }\n}\n"}
{"test_method": "@Test public void readFromSlowStreamWithLengthAgain() throws Exception {\n    fullSlow.read(4);\n    assertThat(fullSlow.read(4)).isEqualTo(copyOfRange(BYTES, 4, 8));\n  }", "focal_method": "public byte[] read(Integer length) throws IOException {\n    if (length == null) {\n      return readToEof();\n    } else {\n      return readTo(length);\n    }\n  }", "test_file": "package com.squareup.rack;\n\nimport java.io.ByteArrayInputStream;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static java.util.Arrays.copyOfRange;\nimport static org.fest.assertions.api.Assertions.assertThat;\n\npublic class RackInputTest {\n  public static final byte[] EMPTY_BYTES = \"\".getBytes();\n  public static final byte[] BYTES = \"Hello,\\nWorld!\".getBytes();\n\n  private RackInput empty;\n  private RackInput full;\n  private RackInput fullSlow;\n\n  @Before public void setUp() throws Exception {\n    empty = rackInputFor(EMPTY_BYTES);\n    full = rackInputFor(BYTES);\n    fullSlow = slowRackInputFor(BYTES);\n  }\n\n  @Test public void getsAtEof() throws Exception {\n    assertThat(empty.gets()).isNull();\n  }\n\n  @Test public void gets() throws Exception {\n    assertThat(full.gets()).isEqualTo(\"Hello,\\n\".getBytes());\n  }\n\n  @Test public void getsWithCrLf() throws Exception {\n    assertThat(rackInputFor(\"Hello,\\r\\nWorld!\").gets()).isEqualTo(\"Hello,\\r\\n\".getBytes());\n  }\n\n  @Test public void getsAgain() throws Exception {\n    full.gets();\n    assertThat(full.gets()).isEqualTo(\"World!\".getBytes());\n  }\n\n  @Test public void readWithLengthNilAtEof() throws Exception {\n    assertThat(empty.read(null)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthZeroAtEof() throws Exception {\n    assertThat(empty.read(0)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthAtEof() throws Exception {\n    assertThat(empty.read(1)).isNull();\n  }\n\n  @Test public void readWithLengthNil() throws Exception {\n    assertThat(full.read(null)).isEqualTo(BYTES);\n  }\n\n  @Test public void readWithLengthNilAgain() throws Exception {\n    full.read(null);\n    assertThat(full.read(null)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthZero() throws Exception {\n    assertThat(full.read(0)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLength() throws Exception {\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void readWithLengthAgain() throws Exception {\n    full.read(4);\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 4, 8));\n  }\n\n  @Test public void readFromSlowStreamWithLength() throws Exception {\n    assertThat(fullSlow.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void readFromSlowStreamWithLengthAgain() throws Exception {\n    fullSlow.read(4);\n    assertThat(fullSlow.read(4)).isEqualTo(copyOfRange(BYTES, 4, 8));\n  }\n\n  @Test public void readWithLengthTooLong() throws Exception {\n    assertThat(full.read(BYTES.length + 1)).isEqualTo(BYTES);\n  }\n\n  @Test public void readWithLengthTooLongAgain() throws Exception {\n    full.read(BYTES.length + 1);\n    assertThat(full.read(BYTES.length + 1)).isNull();\n  }\n\n  @Test public void rewind() throws Exception {\n    full.read(4);\n    full.rewind();\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void rewind_shouldDiscardAnyBufferedBytes() throws Exception {\n    RackInput subject = rackInputFor(\"first line\\r\\n123\\r\\n456\\r\\n\");\n    subject.gets();\n    subject.rewind();\n    assertThat(subject.gets()).isEqualTo(\"first line\\r\\n\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"123\\r\\n\".getBytes());\n  }\n\n  @Test public void intermixingReadMethodsIsSafe() throws Exception {\n    RackInput subject = rackInputFor(\"first line\\r\\n123\\r\\n456\\r\\n\");\n    assertThat(subject.read(1)).isEqualTo(\"f\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"irst line\\r\\n\".getBytes());\n    assertThat(subject.read(null)).isEqualTo(\"123\\r\\n456\\r\\n\".getBytes());\n    subject.rewind();\n    assertThat(subject.gets()).isEqualTo(\"first line\\r\\n\".getBytes());\n    assertThat(subject.read(3)).isEqualTo(\"123\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"\\r\\n\".getBytes());\n    assertThat(subject.read(null)).isEqualTo(\"456\\r\\n\".getBytes());\n  }\n\n  private RackInput rackInputFor(String string) throws Exception {\n    return rackInputFor(string.getBytes());\n  }\n\n  private RackInput rackInputFor(byte[] bytes) throws Exception {\n    return new RackInput(new ByteArrayInputStream(bytes));\n  }\n\n  private RackInput slowRackInputFor(byte[] bytes) throws Exception {\n    return new RackInput(new SlowByteArrayInputStream(bytes));\n  }\n}\n", "focal_file": "/*\n * Copyright (C) 2013 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.squareup.rack;\n\nimport com.google.common.io.ByteStreams;\nimport com.squareup.rack.io.ByteArrayBuffer;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\n/**\n * <p>Adapts an {@link InputStream} to the required interface for {@code rack.input}.</p>\n *\n * <p>Speaks {@code byte[]}, not {@code String}, because {@code rack.input} is required to have\n * binary encoding.</p>\n */\npublic class RackInput implements Closeable {\n  private static final int LINEFEED = 0xA;\n  private static final int MAX_LINE_LENGTH = 1024 * 1024;\n  private static final int READ_AHEAD_SUGGESTION = 1024 * 1024;\n\n  private final InputStream stream;\n  private final ByteArrayBuffer buffer = new ByteArrayBuffer();\n  private int bufferReadHead;\n\n  /**\n   * Creates a {@link RackInput} stream that draws from the given {@link InputStream}.\n   *\n   * @param inputStream the source stream.\n   */\n  public RackInput(InputStream inputStream) {\n    checkNotNull(inputStream);\n    checkArgument(inputStream.markSupported(),\n        \"rack.input must be rewindable, but inputStream doesn't support mark.\");\n\n    stream = inputStream;\n    stream.mark(READ_AHEAD_SUGGESTION);\n  }\n\n  /**\n   * Reads the next line from the stream.\n   *\n   * @return the next line, or null at EOF.\n   * @throws IOException\n   */\n  public byte[] gets() throws IOException {\n    return readToLinefeed();\n  }\n\n  /**\n   * Reads length bytes from the stream. Reads all the way to EOF when length is null.\n   *\n   * @param length the desired number of bytes, or null.\n   * @return the bytes, or null at EOF when length is present.\n   * @throws IOException\n   */\n  public byte[] read(Integer length) throws IOException {\n    if (length == null) {\n      return readToEof();\n    } else {\n      return readTo(length);\n    }\n  }\n\n  /**\n   * Resets the stream, so that it may be read again from the beginning.\n   *\n   * @throws IOException\n   */\n  public void rewind() throws IOException {\n    stream.reset();\n    buffer.reset();\n    bufferReadHead = 0;\n  }\n\n  /**\n   * Closes the stream.\n   *\n   * @throws IOException\n   */\n  @Override public void close() throws IOException {\n    stream.close();\n  }\n\n  private byte[] readToLinefeed() throws IOException {\n    int startFrom = 0;\n    do {\n      int indexOfNewline = indexOfNextNewlineInBuffer(startFrom);\n\n      if (indexOfNewline == -1) {\n        int bytesPresent = bytesAvailableInBuffer();\n\n        if (bytesPresent > MAX_LINE_LENGTH) {\n          throw new RuntimeException(\n              \"Really, you have a line longer than \" + MAX_LINE_LENGTH + \" bytes?\");\n        }\n\n        // next time through, start where we left off.\n        startFrom = bytesPresent;\n\n        int bytesRead = fillBuffer(8 * 1024);\n        if (bytesRead == -1) {\n          int bytesRemaining = bytesAvailableInBuffer();\n          return consumeBytesFromBuffer(bytesRemaining);\n        }\n      } else {\n        int length = indexOfNewline - bufferReadHead + 1;\n        return consumeBytesFromBuffer(length);\n      }\n    } while (true);\n  }\n\n  private byte[] readToEof() throws IOException {\n    if (bufferReadHead > 0) {\n      compactBuffer(true);\n    }\n\n    ByteStreams.copy(stream, buffer);\n\n    int length = buffer.getLength();\n    if (length == 0) {\n      return new byte[0];\n    } else {\n      return consumeBytesFromBuffer(length);\n    }\n  }\n\n  private byte[] readTo(int length) throws IOException {\n    if (length == 0) {\n      return new byte[0];\n    }\n\n    if (bufferReadHead > 0) {\n      compactBuffer(true);\n    }\n\n    int bytesStillNeeded = length - buffer.getLength();\n    if (bytesStillNeeded > 0) {\n      int bytesRead = fillBuffer(bytesStillNeeded);\n      while (bytesRead != -1 && bytesStillNeeded > 0) {\n        bytesStillNeeded -= bytesRead;\n        bytesRead = fillBuffer(bytesStillNeeded);\n      }\n    }\n\n    return consumeBytesFromBuffer(length);\n  }\n\n  private int bytesAvailableInBuffer() {\n    return buffer.getLength() - bufferReadHead;\n  }\n\n  private int indexOfNextNewlineInBuffer(int startFrom) {\n    byte[] bytes = buffer.getBuffer();\n    int bufferLength = buffer.getLength();\n    for (int i = bufferReadHead + startFrom; i < bufferLength; i++) {\n      if (bytes[i] == LINEFEED) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  private int fillBuffer(int length) throws IOException {\n    compactBuffer(false);\n    byte[] readBuf = new byte[length];\n    int bytesRead = stream.read(readBuf);\n    if (bytesRead > 0) {\n      buffer.write(readBuf, 0, bytesRead);\n    }\n    return bytesRead;\n  }\n\n  private byte[] consumeBytesFromBuffer(int length) {\n    int bytesAvailable = bytesAvailableInBuffer();\n    if (length > bytesAvailable) {\n      length = bytesAvailable;\n    }\n\n    if (length == 0) {\n      return null;\n    }\n\n    byte[] bytes = new byte[length];\n    byte[] bufferBytes = buffer.getBuffer();\n    System.arraycopy(bufferBytes, bufferReadHead, bytes, 0, length);\n    bufferReadHead += length;\n    return bytes;\n  }\n\n  private void compactBuffer(boolean force) {\n    byte[] bufferBytes = buffer.getBuffer();\n\n    // normally, only compact if we're at least 1K in, and at least 3/4 of the way in\n    if (force || (bufferReadHead > 1024 && bufferReadHead > (bufferBytes.length * 3 / 4))) {\n      int remainingBytes = bytesAvailableInBuffer();\n      System.arraycopy(bufferBytes, bufferReadHead, bufferBytes, 0, remainingBytes);\n      buffer.setLength(remainingBytes);\n      bufferReadHead = 0;\n    }\n  }\n}\n"}
{"test_method": "@Test public void readWithLengthTooLongAgain() throws Exception {\n    full.read(BYTES.length + 1);\n    assertThat(full.read(BYTES.length + 1)).isNull();\n  }", "focal_method": "public byte[] read(Integer length) throws IOException {\n    if (length == null) {\n      return readToEof();\n    } else {\n      return readTo(length);\n    }\n  }", "test_file": "package com.squareup.rack;\n\nimport java.io.ByteArrayInputStream;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static java.util.Arrays.copyOfRange;\nimport static org.fest.assertions.api.Assertions.assertThat;\n\npublic class RackInputTest {\n  public static final byte[] EMPTY_BYTES = \"\".getBytes();\n  public static final byte[] BYTES = \"Hello,\\nWorld!\".getBytes();\n\n  private RackInput empty;\n  private RackInput full;\n  private RackInput fullSlow;\n\n  @Before public void setUp() throws Exception {\n    empty = rackInputFor(EMPTY_BYTES);\n    full = rackInputFor(BYTES);\n    fullSlow = slowRackInputFor(BYTES);\n  }\n\n  @Test public void getsAtEof() throws Exception {\n    assertThat(empty.gets()).isNull();\n  }\n\n  @Test public void gets() throws Exception {\n    assertThat(full.gets()).isEqualTo(\"Hello,\\n\".getBytes());\n  }\n\n  @Test public void getsWithCrLf() throws Exception {\n    assertThat(rackInputFor(\"Hello,\\r\\nWorld!\").gets()).isEqualTo(\"Hello,\\r\\n\".getBytes());\n  }\n\n  @Test public void getsAgain() throws Exception {\n    full.gets();\n    assertThat(full.gets()).isEqualTo(\"World!\".getBytes());\n  }\n\n  @Test public void readWithLengthNilAtEof() throws Exception {\n    assertThat(empty.read(null)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthZeroAtEof() throws Exception {\n    assertThat(empty.read(0)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthAtEof() throws Exception {\n    assertThat(empty.read(1)).isNull();\n  }\n\n  @Test public void readWithLengthNil() throws Exception {\n    assertThat(full.read(null)).isEqualTo(BYTES);\n  }\n\n  @Test public void readWithLengthNilAgain() throws Exception {\n    full.read(null);\n    assertThat(full.read(null)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthZero() throws Exception {\n    assertThat(full.read(0)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLength() throws Exception {\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void readWithLengthAgain() throws Exception {\n    full.read(4);\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 4, 8));\n  }\n\n  @Test public void readFromSlowStreamWithLength() throws Exception {\n    assertThat(fullSlow.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void readFromSlowStreamWithLengthAgain() throws Exception {\n    fullSlow.read(4);\n    assertThat(fullSlow.read(4)).isEqualTo(copyOfRange(BYTES, 4, 8));\n  }\n\n  @Test public void readWithLengthTooLong() throws Exception {\n    assertThat(full.read(BYTES.length + 1)).isEqualTo(BYTES);\n  }\n\n  @Test public void readWithLengthTooLongAgain() throws Exception {\n    full.read(BYTES.length + 1);\n    assertThat(full.read(BYTES.length + 1)).isNull();\n  }\n\n  @Test public void rewind() throws Exception {\n    full.read(4);\n    full.rewind();\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void rewind_shouldDiscardAnyBufferedBytes() throws Exception {\n    RackInput subject = rackInputFor(\"first line\\r\\n123\\r\\n456\\r\\n\");\n    subject.gets();\n    subject.rewind();\n    assertThat(subject.gets()).isEqualTo(\"first line\\r\\n\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"123\\r\\n\".getBytes());\n  }\n\n  @Test public void intermixingReadMethodsIsSafe() throws Exception {\n    RackInput subject = rackInputFor(\"first line\\r\\n123\\r\\n456\\r\\n\");\n    assertThat(subject.read(1)).isEqualTo(\"f\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"irst line\\r\\n\".getBytes());\n    assertThat(subject.read(null)).isEqualTo(\"123\\r\\n456\\r\\n\".getBytes());\n    subject.rewind();\n    assertThat(subject.gets()).isEqualTo(\"first line\\r\\n\".getBytes());\n    assertThat(subject.read(3)).isEqualTo(\"123\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"\\r\\n\".getBytes());\n    assertThat(subject.read(null)).isEqualTo(\"456\\r\\n\".getBytes());\n  }\n\n  private RackInput rackInputFor(String string) throws Exception {\n    return rackInputFor(string.getBytes());\n  }\n\n  private RackInput rackInputFor(byte[] bytes) throws Exception {\n    return new RackInput(new ByteArrayInputStream(bytes));\n  }\n\n  private RackInput slowRackInputFor(byte[] bytes) throws Exception {\n    return new RackInput(new SlowByteArrayInputStream(bytes));\n  }\n}\n", "focal_file": "/*\n * Copyright (C) 2013 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.squareup.rack;\n\nimport com.google.common.io.ByteStreams;\nimport com.squareup.rack.io.ByteArrayBuffer;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\n/**\n * <p>Adapts an {@link InputStream} to the required interface for {@code rack.input}.</p>\n *\n * <p>Speaks {@code byte[]}, not {@code String}, because {@code rack.input} is required to have\n * binary encoding.</p>\n */\npublic class RackInput implements Closeable {\n  private static final int LINEFEED = 0xA;\n  private static final int MAX_LINE_LENGTH = 1024 * 1024;\n  private static final int READ_AHEAD_SUGGESTION = 1024 * 1024;\n\n  private final InputStream stream;\n  private final ByteArrayBuffer buffer = new ByteArrayBuffer();\n  private int bufferReadHead;\n\n  /**\n   * Creates a {@link RackInput} stream that draws from the given {@link InputStream}.\n   *\n   * @param inputStream the source stream.\n   */\n  public RackInput(InputStream inputStream) {\n    checkNotNull(inputStream);\n    checkArgument(inputStream.markSupported(),\n        \"rack.input must be rewindable, but inputStream doesn't support mark.\");\n\n    stream = inputStream;\n    stream.mark(READ_AHEAD_SUGGESTION);\n  }\n\n  /**\n   * Reads the next line from the stream.\n   *\n   * @return the next line, or null at EOF.\n   * @throws IOException\n   */\n  public byte[] gets() throws IOException {\n    return readToLinefeed();\n  }\n\n  /**\n   * Reads length bytes from the stream. Reads all the way to EOF when length is null.\n   *\n   * @param length the desired number of bytes, or null.\n   * @return the bytes, or null at EOF when length is present.\n   * @throws IOException\n   */\n  public byte[] read(Integer length) throws IOException {\n    if (length == null) {\n      return readToEof();\n    } else {\n      return readTo(length);\n    }\n  }\n\n  /**\n   * Resets the stream, so that it may be read again from the beginning.\n   *\n   * @throws IOException\n   */\n  public void rewind() throws IOException {\n    stream.reset();\n    buffer.reset();\n    bufferReadHead = 0;\n  }\n\n  /**\n   * Closes the stream.\n   *\n   * @throws IOException\n   */\n  @Override public void close() throws IOException {\n    stream.close();\n  }\n\n  private byte[] readToLinefeed() throws IOException {\n    int startFrom = 0;\n    do {\n      int indexOfNewline = indexOfNextNewlineInBuffer(startFrom);\n\n      if (indexOfNewline == -1) {\n        int bytesPresent = bytesAvailableInBuffer();\n\n        if (bytesPresent > MAX_LINE_LENGTH) {\n          throw new RuntimeException(\n              \"Really, you have a line longer than \" + MAX_LINE_LENGTH + \" bytes?\");\n        }\n\n        // next time through, start where we left off.\n        startFrom = bytesPresent;\n\n        int bytesRead = fillBuffer(8 * 1024);\n        if (bytesRead == -1) {\n          int bytesRemaining = bytesAvailableInBuffer();\n          return consumeBytesFromBuffer(bytesRemaining);\n        }\n      } else {\n        int length = indexOfNewline - bufferReadHead + 1;\n        return consumeBytesFromBuffer(length);\n      }\n    } while (true);\n  }\n\n  private byte[] readToEof() throws IOException {\n    if (bufferReadHead > 0) {\n      compactBuffer(true);\n    }\n\n    ByteStreams.copy(stream, buffer);\n\n    int length = buffer.getLength();\n    if (length == 0) {\n      return new byte[0];\n    } else {\n      return consumeBytesFromBuffer(length);\n    }\n  }\n\n  private byte[] readTo(int length) throws IOException {\n    if (length == 0) {\n      return new byte[0];\n    }\n\n    if (bufferReadHead > 0) {\n      compactBuffer(true);\n    }\n\n    int bytesStillNeeded = length - buffer.getLength();\n    if (bytesStillNeeded > 0) {\n      int bytesRead = fillBuffer(bytesStillNeeded);\n      while (bytesRead != -1 && bytesStillNeeded > 0) {\n        bytesStillNeeded -= bytesRead;\n        bytesRead = fillBuffer(bytesStillNeeded);\n      }\n    }\n\n    return consumeBytesFromBuffer(length);\n  }\n\n  private int bytesAvailableInBuffer() {\n    return buffer.getLength() - bufferReadHead;\n  }\n\n  private int indexOfNextNewlineInBuffer(int startFrom) {\n    byte[] bytes = buffer.getBuffer();\n    int bufferLength = buffer.getLength();\n    for (int i = bufferReadHead + startFrom; i < bufferLength; i++) {\n      if (bytes[i] == LINEFEED) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  private int fillBuffer(int length) throws IOException {\n    compactBuffer(false);\n    byte[] readBuf = new byte[length];\n    int bytesRead = stream.read(readBuf);\n    if (bytesRead > 0) {\n      buffer.write(readBuf, 0, bytesRead);\n    }\n    return bytesRead;\n  }\n\n  private byte[] consumeBytesFromBuffer(int length) {\n    int bytesAvailable = bytesAvailableInBuffer();\n    if (length > bytesAvailable) {\n      length = bytesAvailable;\n    }\n\n    if (length == 0) {\n      return null;\n    }\n\n    byte[] bytes = new byte[length];\n    byte[] bufferBytes = buffer.getBuffer();\n    System.arraycopy(bufferBytes, bufferReadHead, bytes, 0, length);\n    bufferReadHead += length;\n    return bytes;\n  }\n\n  private void compactBuffer(boolean force) {\n    byte[] bufferBytes = buffer.getBuffer();\n\n    // normally, only compact if we're at least 1K in, and at least 3/4 of the way in\n    if (force || (bufferReadHead > 1024 && bufferReadHead > (bufferBytes.length * 3 / 4))) {\n      int remainingBytes = bytesAvailableInBuffer();\n      System.arraycopy(bufferBytes, bufferReadHead, bufferBytes, 0, remainingBytes);\n      buffer.setLength(remainingBytes);\n      bufferReadHead = 0;\n    }\n  }\n}\n"}
{"test_method": "@Test public void warn() {\n    subject.warn(MESSAGE);\n    verify(delegate).warn(MESSAGE);\n  }", "focal_method": "public void warn(String message) {\n    logger.warn(message);\n  }", "test_file": "package com.squareup.rack;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.runners.MockitoJUnitRunner;\nimport org.slf4j.Logger;\n\nimport static com.squareup.rack.RackLogger.FATAL;\nimport static org.mockito.Mockito.verify;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class RackLoggerTest {\n  private static final String MESSAGE = \"message\";\n\n  private RackLogger subject;\n  @Mock private Logger delegate;\n\n  @Before public void setUp() {\n    subject = new RackLogger(delegate);\n  }\n\n  @Test(expected = NullPointerException.class)\n  public void constructorRequiresALogger() {\n    new RackLogger(null);\n  }\n\n  @Test public void info() {\n    subject.info(MESSAGE);\n    verify(delegate).info(MESSAGE);\n  }\n\n  @Test public void debug() {\n    subject.debug(MESSAGE);\n    verify(delegate).debug(MESSAGE);\n  }\n\n  @Test public void warn() {\n    subject.warn(MESSAGE);\n    verify(delegate).warn(MESSAGE);\n  }\n\n  @Test public void error() {\n    subject.error(MESSAGE);\n    verify(delegate).error(MESSAGE);\n  }\n\n  @Test public void fatal() {\n    subject.fatal(MESSAGE);\n    verify(delegate).error(FATAL, MESSAGE);\n  }\n}\n", "focal_file": "/*\n * Copyright (C) 2013 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.squareup.rack;\n\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.MarkerFactory;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\n/**\n * Adapts a {@link Logger} to the required interface for {@code rack.logger}.\n */\npublic class RackLogger {\n  public static final Marker FATAL = MarkerFactory.getMarker(\"FATAL\");\n\n  private final Logger logger;\n\n  /**\n   * Creates a {@link RackLogger} that forwards messages to the given {@link Logger}.\n   *\n   * @param logger\n   */\n  public RackLogger(Logger logger) {\n    this.logger = checkNotNull(logger);\n  }\n\n  public void info(String message) {\n    logger.info(message);\n  }\n\n  public void debug(String message) {\n    logger.debug(message);\n  }\n\n  public void warn(String message) {\n    logger.warn(message);\n  }\n\n  public void error(String message) {\n    logger.error(message);\n  }\n\n  public void fatal(String message) {\n    // See http://www.slf4j.org/faq.html#fatal\n    logger.error(FATAL, message);\n  }\n}\n"}
{"test_method": "@Test public void readWithLengthAtEof() throws Exception {\n    assertThat(empty.read(1)).isNull();\n  }", "focal_method": "public byte[] read(Integer length) throws IOException {\n    if (length == null) {\n      return readToEof();\n    } else {\n      return readTo(length);\n    }\n  }", "test_file": "package com.squareup.rack;\n\nimport java.io.ByteArrayInputStream;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static java.util.Arrays.copyOfRange;\nimport static org.fest.assertions.api.Assertions.assertThat;\n\npublic class RackInputTest {\n  public static final byte[] EMPTY_BYTES = \"\".getBytes();\n  public static final byte[] BYTES = \"Hello,\\nWorld!\".getBytes();\n\n  private RackInput empty;\n  private RackInput full;\n  private RackInput fullSlow;\n\n  @Before public void setUp() throws Exception {\n    empty = rackInputFor(EMPTY_BYTES);\n    full = rackInputFor(BYTES);\n    fullSlow = slowRackInputFor(BYTES);\n  }\n\n  @Test public void getsAtEof() throws Exception {\n    assertThat(empty.gets()).isNull();\n  }\n\n  @Test public void gets() throws Exception {\n    assertThat(full.gets()).isEqualTo(\"Hello,\\n\".getBytes());\n  }\n\n  @Test public void getsWithCrLf() throws Exception {\n    assertThat(rackInputFor(\"Hello,\\r\\nWorld!\").gets()).isEqualTo(\"Hello,\\r\\n\".getBytes());\n  }\n\n  @Test public void getsAgain() throws Exception {\n    full.gets();\n    assertThat(full.gets()).isEqualTo(\"World!\".getBytes());\n  }\n\n  @Test public void readWithLengthNilAtEof() throws Exception {\n    assertThat(empty.read(null)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthZeroAtEof() throws Exception {\n    assertThat(empty.read(0)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthAtEof() throws Exception {\n    assertThat(empty.read(1)).isNull();\n  }\n\n  @Test public void readWithLengthNil() throws Exception {\n    assertThat(full.read(null)).isEqualTo(BYTES);\n  }\n\n  @Test public void readWithLengthNilAgain() throws Exception {\n    full.read(null);\n    assertThat(full.read(null)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthZero() throws Exception {\n    assertThat(full.read(0)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLength() throws Exception {\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void readWithLengthAgain() throws Exception {\n    full.read(4);\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 4, 8));\n  }\n\n  @Test public void readFromSlowStreamWithLength() throws Exception {\n    assertThat(fullSlow.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void readFromSlowStreamWithLengthAgain() throws Exception {\n    fullSlow.read(4);\n    assertThat(fullSlow.read(4)).isEqualTo(copyOfRange(BYTES, 4, 8));\n  }\n\n  @Test public void readWithLengthTooLong() throws Exception {\n    assertThat(full.read(BYTES.length + 1)).isEqualTo(BYTES);\n  }\n\n  @Test public void readWithLengthTooLongAgain() throws Exception {\n    full.read(BYTES.length + 1);\n    assertThat(full.read(BYTES.length + 1)).isNull();\n  }\n\n  @Test public void rewind() throws Exception {\n    full.read(4);\n    full.rewind();\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void rewind_shouldDiscardAnyBufferedBytes() throws Exception {\n    RackInput subject = rackInputFor(\"first line\\r\\n123\\r\\n456\\r\\n\");\n    subject.gets();\n    subject.rewind();\n    assertThat(subject.gets()).isEqualTo(\"first line\\r\\n\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"123\\r\\n\".getBytes());\n  }\n\n  @Test public void intermixingReadMethodsIsSafe() throws Exception {\n    RackInput subject = rackInputFor(\"first line\\r\\n123\\r\\n456\\r\\n\");\n    assertThat(subject.read(1)).isEqualTo(\"f\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"irst line\\r\\n\".getBytes());\n    assertThat(subject.read(null)).isEqualTo(\"123\\r\\n456\\r\\n\".getBytes());\n    subject.rewind();\n    assertThat(subject.gets()).isEqualTo(\"first line\\r\\n\".getBytes());\n    assertThat(subject.read(3)).isEqualTo(\"123\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"\\r\\n\".getBytes());\n    assertThat(subject.read(null)).isEqualTo(\"456\\r\\n\".getBytes());\n  }\n\n  private RackInput rackInputFor(String string) throws Exception {\n    return rackInputFor(string.getBytes());\n  }\n\n  private RackInput rackInputFor(byte[] bytes) throws Exception {\n    return new RackInput(new ByteArrayInputStream(bytes));\n  }\n\n  private RackInput slowRackInputFor(byte[] bytes) throws Exception {\n    return new RackInput(new SlowByteArrayInputStream(bytes));\n  }\n}\n", "focal_file": "/*\n * Copyright (C) 2013 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.squareup.rack;\n\nimport com.google.common.io.ByteStreams;\nimport com.squareup.rack.io.ByteArrayBuffer;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\n/**\n * <p>Adapts an {@link InputStream} to the required interface for {@code rack.input}.</p>\n *\n * <p>Speaks {@code byte[]}, not {@code String}, because {@code rack.input} is required to have\n * binary encoding.</p>\n */\npublic class RackInput implements Closeable {\n  private static final int LINEFEED = 0xA;\n  private static final int MAX_LINE_LENGTH = 1024 * 1024;\n  private static final int READ_AHEAD_SUGGESTION = 1024 * 1024;\n\n  private final InputStream stream;\n  private final ByteArrayBuffer buffer = new ByteArrayBuffer();\n  private int bufferReadHead;\n\n  /**\n   * Creates a {@link RackInput} stream that draws from the given {@link InputStream}.\n   *\n   * @param inputStream the source stream.\n   */\n  public RackInput(InputStream inputStream) {\n    checkNotNull(inputStream);\n    checkArgument(inputStream.markSupported(),\n        \"rack.input must be rewindable, but inputStream doesn't support mark.\");\n\n    stream = inputStream;\n    stream.mark(READ_AHEAD_SUGGESTION);\n  }\n\n  /**\n   * Reads the next line from the stream.\n   *\n   * @return the next line, or null at EOF.\n   * @throws IOException\n   */\n  public byte[] gets() throws IOException {\n    return readToLinefeed();\n  }\n\n  /**\n   * Reads length bytes from the stream. Reads all the way to EOF when length is null.\n   *\n   * @param length the desired number of bytes, or null.\n   * @return the bytes, or null at EOF when length is present.\n   * @throws IOException\n   */\n  public byte[] read(Integer length) throws IOException {\n    if (length == null) {\n      return readToEof();\n    } else {\n      return readTo(length);\n    }\n  }\n\n  /**\n   * Resets the stream, so that it may be read again from the beginning.\n   *\n   * @throws IOException\n   */\n  public void rewind() throws IOException {\n    stream.reset();\n    buffer.reset();\n    bufferReadHead = 0;\n  }\n\n  /**\n   * Closes the stream.\n   *\n   * @throws IOException\n   */\n  @Override public void close() throws IOException {\n    stream.close();\n  }\n\n  private byte[] readToLinefeed() throws IOException {\n    int startFrom = 0;\n    do {\n      int indexOfNewline = indexOfNextNewlineInBuffer(startFrom);\n\n      if (indexOfNewline == -1) {\n        int bytesPresent = bytesAvailableInBuffer();\n\n        if (bytesPresent > MAX_LINE_LENGTH) {\n          throw new RuntimeException(\n              \"Really, you have a line longer than \" + MAX_LINE_LENGTH + \" bytes?\");\n        }\n\n        // next time through, start where we left off.\n        startFrom = bytesPresent;\n\n        int bytesRead = fillBuffer(8 * 1024);\n        if (bytesRead == -1) {\n          int bytesRemaining = bytesAvailableInBuffer();\n          return consumeBytesFromBuffer(bytesRemaining);\n        }\n      } else {\n        int length = indexOfNewline - bufferReadHead + 1;\n        return consumeBytesFromBuffer(length);\n      }\n    } while (true);\n  }\n\n  private byte[] readToEof() throws IOException {\n    if (bufferReadHead > 0) {\n      compactBuffer(true);\n    }\n\n    ByteStreams.copy(stream, buffer);\n\n    int length = buffer.getLength();\n    if (length == 0) {\n      return new byte[0];\n    } else {\n      return consumeBytesFromBuffer(length);\n    }\n  }\n\n  private byte[] readTo(int length) throws IOException {\n    if (length == 0) {\n      return new byte[0];\n    }\n\n    if (bufferReadHead > 0) {\n      compactBuffer(true);\n    }\n\n    int bytesStillNeeded = length - buffer.getLength();\n    if (bytesStillNeeded > 0) {\n      int bytesRead = fillBuffer(bytesStillNeeded);\n      while (bytesRead != -1 && bytesStillNeeded > 0) {\n        bytesStillNeeded -= bytesRead;\n        bytesRead = fillBuffer(bytesStillNeeded);\n      }\n    }\n\n    return consumeBytesFromBuffer(length);\n  }\n\n  private int bytesAvailableInBuffer() {\n    return buffer.getLength() - bufferReadHead;\n  }\n\n  private int indexOfNextNewlineInBuffer(int startFrom) {\n    byte[] bytes = buffer.getBuffer();\n    int bufferLength = buffer.getLength();\n    for (int i = bufferReadHead + startFrom; i < bufferLength; i++) {\n      if (bytes[i] == LINEFEED) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  private int fillBuffer(int length) throws IOException {\n    compactBuffer(false);\n    byte[] readBuf = new byte[length];\n    int bytesRead = stream.read(readBuf);\n    if (bytesRead > 0) {\n      buffer.write(readBuf, 0, bytesRead);\n    }\n    return bytesRead;\n  }\n\n  private byte[] consumeBytesFromBuffer(int length) {\n    int bytesAvailable = bytesAvailableInBuffer();\n    if (length > bytesAvailable) {\n      length = bytesAvailable;\n    }\n\n    if (length == 0) {\n      return null;\n    }\n\n    byte[] bytes = new byte[length];\n    byte[] bufferBytes = buffer.getBuffer();\n    System.arraycopy(bufferBytes, bufferReadHead, bytes, 0, length);\n    bufferReadHead += length;\n    return bytes;\n  }\n\n  private void compactBuffer(boolean force) {\n    byte[] bufferBytes = buffer.getBuffer();\n\n    // normally, only compact if we're at least 1K in, and at least 3/4 of the way in\n    if (force || (bufferReadHead > 1024 && bufferReadHead > (bufferBytes.length * 3 / 4))) {\n      int remainingBytes = bytesAvailableInBuffer();\n      System.arraycopy(bufferBytes, bufferReadHead, bufferBytes, 0, remainingBytes);\n      buffer.setLength(remainingBytes);\n      bufferReadHead = 0;\n    }\n  }\n}\n"}
{"test_method": "@Test public void propagateHeaders() {\n    rackResponse.header(\"Content-Type\", \"text/plain\");\n    subject.propagate(rackResponse.build(), response);\n    verify(response).addHeader(\"Content-Type\", \"text/plain\");\n  }", "focal_method": "private void propagateHeaders(RackResponse rackResponse, HttpServletResponse response) {\n    for (Map.Entry<String, String> header : rackResponse.getHeaders().entrySet()) {\n      if (shouldPropagateHeaderToClient(header)) {\n        for (String val : header.getValue().split(\"\\n\")) {\n          response.addHeader(header.getKey(), val);\n        }\n      }\n    }\n\n    try {\n      response.flushBuffer();\n    } catch (IOException e) {\n      Throwables.propagate(e);\n    }\n  }", "test_file": "package com.squareup.rack.servlet;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.squareup.rack.RackResponse;\nimport java.io.IOException;\nimport javax.servlet.ServletOutputStream;\nimport javax.servlet.http.HttpServletResponse;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.InOrder;\nimport org.mockito.Mock;\nimport org.mockito.runners.MockitoJUnitRunner;\n\nimport static org.mockito.Matchers.anyString;\nimport static org.mockito.Matchers.eq;\nimport static org.mockito.Mockito.inOrder;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class RackResponsePropagatorTest {\n  private RackResponsePropagator subject;\n  private RackResponseBuilder rackResponse;\n\n  @Mock private HttpServletResponse response;\n  @Mock private ServletOutputStream outputStream;\n\n  @Before public void setUp() throws IOException {\n    subject = new RackResponsePropagator();\n    rackResponse = new RackResponseBuilder();\n    when(response.getOutputStream()).thenReturn(outputStream);\n  }\n\n  @Test public void propagateStatus() {\n    rackResponse.status(404);\n    subject.propagate(rackResponse.build(), response);\n    verify(response).setStatus(404);\n  }\n\n  @Test public void propagateHeaders() {\n    rackResponse.header(\"Content-Type\", \"text/plain\");\n    subject.propagate(rackResponse.build(), response);\n    verify(response).addHeader(\"Content-Type\", \"text/plain\");\n  }\n\n  @Test public void propagateHeadersSkipsHeadsRackHeaders() {\n    rackResponse.header(\"rack.internal\", \"42\");\n    subject.propagate(rackResponse.build(), response);\n    verify(response, never()).addHeader(eq(\"rack.internal\"), anyString());\n  }\n\n  @Test public void propagateHeadersMultipleValues() {\n    rackResponse.header(\"Set-Cookie\", \"foo=bar\\nbar=foo\");\n    subject.propagate(rackResponse.build(), response);\n    verify(response).addHeader(\"Set-Cookie\", \"foo=bar\");\n    verify(response).addHeader(\"Set-Cookie\", \"bar=foo\");\n  }\n\n  @Test public void propagateBody() throws IOException {\n    rackResponse.body(\"Here \".getBytes(), \"are \".getBytes(), \"the \".getBytes(), \"parts.\".getBytes());\n\n    subject.propagate(rackResponse.build(), response);\n\n    InOrder inOrder = inOrder(outputStream);\n    inOrder.verify(outputStream).write(\"Here \".getBytes());\n    inOrder.verify(outputStream).write(\"are \".getBytes());\n    inOrder.verify(outputStream).write(\"the \".getBytes());\n    inOrder.verify(outputStream).write(\"parts.\".getBytes());\n    inOrder.verify(outputStream).flush();\n  }\n\n  private static class RackResponseBuilder {\n    private int status;\n    private final ImmutableMap.Builder<String, String> headers;\n    private final ImmutableList.Builder<byte[]> body;\n\n    public RackResponseBuilder() {\n      this.status = 200;\n      this.headers = ImmutableMap.builder();\n      this.body = ImmutableList.builder();\n    }\n\n    public RackResponseBuilder status(int status) {\n      this.status = status;\n      return this;\n    }\n\n    public RackResponseBuilder header(String key, String value) {\n      this.headers.put(key, value);\n      return this;\n    }\n\n    public RackResponseBuilder body(byte[]... parts) {\n      body.add(parts);\n      return this;\n    }\n\n    public RackResponse build() {\n      return new RackResponse(status, headers.build(), body.build().iterator());\n    }\n  }\n}\n", "focal_file": "/*\n * Copyright (C) 2013 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.squareup.rack.servlet;\n\nimport com.google.common.base.Throwables;\nimport com.squareup.rack.RackResponse;\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.Map;\nimport javax.servlet.ServletOutputStream;\nimport javax.servlet.http.HttpServletResponse;\n\n/**\n * Writes a {@link RackResponse} onto an {@link HttpServletResponse}.\n */\npublic class RackResponsePropagator {\n  private static final String RACK_INTERNAL_HEADER_PREFIX = \"rack.\";\n\n  public void propagate(RackResponse rackResponse, HttpServletResponse response) {\n    propagateStatus(rackResponse, response);\n    propagateHeaders(rackResponse, response);\n    propagateBody(rackResponse, response);\n  }\n\n  private void propagateStatus(RackResponse rackResponse, HttpServletResponse response) {\n    response.setStatus(rackResponse.getStatus());\n  }\n\n  private void propagateHeaders(RackResponse rackResponse, HttpServletResponse response) {\n    for (Map.Entry<String, String> header : rackResponse.getHeaders().entrySet()) {\n      if (shouldPropagateHeaderToClient(header)) {\n        for (String val : header.getValue().split(\"\\n\")) {\n          response.addHeader(header.getKey(), val);\n        }\n      }\n    }\n\n    try {\n      response.flushBuffer();\n    } catch (IOException e) {\n      Throwables.propagate(e);\n    }\n  }\n\n  private boolean shouldPropagateHeaderToClient(Map.Entry<String, String> header) {\n    return !header.getKey().startsWith(RACK_INTERNAL_HEADER_PREFIX);\n  }\n\n  private void propagateBody(RackResponse rackResponse, HttpServletResponse response) {\n    ServletOutputStream outputStream = null;\n\n    try {\n      outputStream = response.getOutputStream();\n    } catch (IOException e) {\n      Throwables.propagate(e);\n    }\n\n    Iterator<byte[]> body = rackResponse.getBody();\n\n    while (body.hasNext()) {\n      try {\n        outputStream.write(body.next());\n      } catch (IOException e) {\n        Throwables.propagate(e);\n      }\n    }\n\n    try {\n      outputStream.flush();\n    } catch (IOException e) {\n      Throwables.propagate(e);\n    }\n  }\n}\n"}
{"test_method": "@Test public void getsAgain() throws Exception {\n    full.gets();\n    assertThat(full.gets()).isEqualTo(\"World!\".getBytes());\n  }", "focal_method": "public byte[] gets() throws IOException {\n    return readToLinefeed();\n  }", "test_file": "package com.squareup.rack;\n\nimport java.io.ByteArrayInputStream;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static java.util.Arrays.copyOfRange;\nimport static org.fest.assertions.api.Assertions.assertThat;\n\npublic class RackInputTest {\n  public static final byte[] EMPTY_BYTES = \"\".getBytes();\n  public static final byte[] BYTES = \"Hello,\\nWorld!\".getBytes();\n\n  private RackInput empty;\n  private RackInput full;\n  private RackInput fullSlow;\n\n  @Before public void setUp() throws Exception {\n    empty = rackInputFor(EMPTY_BYTES);\n    full = rackInputFor(BYTES);\n    fullSlow = slowRackInputFor(BYTES);\n  }\n\n  @Test public void getsAtEof() throws Exception {\n    assertThat(empty.gets()).isNull();\n  }\n\n  @Test public void gets() throws Exception {\n    assertThat(full.gets()).isEqualTo(\"Hello,\\n\".getBytes());\n  }\n\n  @Test public void getsWithCrLf() throws Exception {\n    assertThat(rackInputFor(\"Hello,\\r\\nWorld!\").gets()).isEqualTo(\"Hello,\\r\\n\".getBytes());\n  }\n\n  @Test public void getsAgain() throws Exception {\n    full.gets();\n    assertThat(full.gets()).isEqualTo(\"World!\".getBytes());\n  }\n\n  @Test public void readWithLengthNilAtEof() throws Exception {\n    assertThat(empty.read(null)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthZeroAtEof() throws Exception {\n    assertThat(empty.read(0)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthAtEof() throws Exception {\n    assertThat(empty.read(1)).isNull();\n  }\n\n  @Test public void readWithLengthNil() throws Exception {\n    assertThat(full.read(null)).isEqualTo(BYTES);\n  }\n\n  @Test public void readWithLengthNilAgain() throws Exception {\n    full.read(null);\n    assertThat(full.read(null)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthZero() throws Exception {\n    assertThat(full.read(0)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLength() throws Exception {\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void readWithLengthAgain() throws Exception {\n    full.read(4);\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 4, 8));\n  }\n\n  @Test public void readFromSlowStreamWithLength() throws Exception {\n    assertThat(fullSlow.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void readFromSlowStreamWithLengthAgain() throws Exception {\n    fullSlow.read(4);\n    assertThat(fullSlow.read(4)).isEqualTo(copyOfRange(BYTES, 4, 8));\n  }\n\n  @Test public void readWithLengthTooLong() throws Exception {\n    assertThat(full.read(BYTES.length + 1)).isEqualTo(BYTES);\n  }\n\n  @Test public void readWithLengthTooLongAgain() throws Exception {\n    full.read(BYTES.length + 1);\n    assertThat(full.read(BYTES.length + 1)).isNull();\n  }\n\n  @Test public void rewind() throws Exception {\n    full.read(4);\n    full.rewind();\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void rewind_shouldDiscardAnyBufferedBytes() throws Exception {\n    RackInput subject = rackInputFor(\"first line\\r\\n123\\r\\n456\\r\\n\");\n    subject.gets();\n    subject.rewind();\n    assertThat(subject.gets()).isEqualTo(\"first line\\r\\n\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"123\\r\\n\".getBytes());\n  }\n\n  @Test public void intermixingReadMethodsIsSafe() throws Exception {\n    RackInput subject = rackInputFor(\"first line\\r\\n123\\r\\n456\\r\\n\");\n    assertThat(subject.read(1)).isEqualTo(\"f\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"irst line\\r\\n\".getBytes());\n    assertThat(subject.read(null)).isEqualTo(\"123\\r\\n456\\r\\n\".getBytes());\n    subject.rewind();\n    assertThat(subject.gets()).isEqualTo(\"first line\\r\\n\".getBytes());\n    assertThat(subject.read(3)).isEqualTo(\"123\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"\\r\\n\".getBytes());\n    assertThat(subject.read(null)).isEqualTo(\"456\\r\\n\".getBytes());\n  }\n\n  private RackInput rackInputFor(String string) throws Exception {\n    return rackInputFor(string.getBytes());\n  }\n\n  private RackInput rackInputFor(byte[] bytes) throws Exception {\n    return new RackInput(new ByteArrayInputStream(bytes));\n  }\n\n  private RackInput slowRackInputFor(byte[] bytes) throws Exception {\n    return new RackInput(new SlowByteArrayInputStream(bytes));\n  }\n}\n", "focal_file": "/*\n * Copyright (C) 2013 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.squareup.rack;\n\nimport com.google.common.io.ByteStreams;\nimport com.squareup.rack.io.ByteArrayBuffer;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\n/**\n * <p>Adapts an {@link InputStream} to the required interface for {@code rack.input}.</p>\n *\n * <p>Speaks {@code byte[]}, not {@code String}, because {@code rack.input} is required to have\n * binary encoding.</p>\n */\npublic class RackInput implements Closeable {\n  private static final int LINEFEED = 0xA;\n  private static final int MAX_LINE_LENGTH = 1024 * 1024;\n  private static final int READ_AHEAD_SUGGESTION = 1024 * 1024;\n\n  private final InputStream stream;\n  private final ByteArrayBuffer buffer = new ByteArrayBuffer();\n  private int bufferReadHead;\n\n  /**\n   * Creates a {@link RackInput} stream that draws from the given {@link InputStream}.\n   *\n   * @param inputStream the source stream.\n   */\n  public RackInput(InputStream inputStream) {\n    checkNotNull(inputStream);\n    checkArgument(inputStream.markSupported(),\n        \"rack.input must be rewindable, but inputStream doesn't support mark.\");\n\n    stream = inputStream;\n    stream.mark(READ_AHEAD_SUGGESTION);\n  }\n\n  /**\n   * Reads the next line from the stream.\n   *\n   * @return the next line, or null at EOF.\n   * @throws IOException\n   */\n  public byte[] gets() throws IOException {\n    return readToLinefeed();\n  }\n\n  /**\n   * Reads length bytes from the stream. Reads all the way to EOF when length is null.\n   *\n   * @param length the desired number of bytes, or null.\n   * @return the bytes, or null at EOF when length is present.\n   * @throws IOException\n   */\n  public byte[] read(Integer length) throws IOException {\n    if (length == null) {\n      return readToEof();\n    } else {\n      return readTo(length);\n    }\n  }\n\n  /**\n   * Resets the stream, so that it may be read again from the beginning.\n   *\n   * @throws IOException\n   */\n  public void rewind() throws IOException {\n    stream.reset();\n    buffer.reset();\n    bufferReadHead = 0;\n  }\n\n  /**\n   * Closes the stream.\n   *\n   * @throws IOException\n   */\n  @Override public void close() throws IOException {\n    stream.close();\n  }\n\n  private byte[] readToLinefeed() throws IOException {\n    int startFrom = 0;\n    do {\n      int indexOfNewline = indexOfNextNewlineInBuffer(startFrom);\n\n      if (indexOfNewline == -1) {\n        int bytesPresent = bytesAvailableInBuffer();\n\n        if (bytesPresent > MAX_LINE_LENGTH) {\n          throw new RuntimeException(\n              \"Really, you have a line longer than \" + MAX_LINE_LENGTH + \" bytes?\");\n        }\n\n        // next time through, start where we left off.\n        startFrom = bytesPresent;\n\n        int bytesRead = fillBuffer(8 * 1024);\n        if (bytesRead == -1) {\n          int bytesRemaining = bytesAvailableInBuffer();\n          return consumeBytesFromBuffer(bytesRemaining);\n        }\n      } else {\n        int length = indexOfNewline - bufferReadHead + 1;\n        return consumeBytesFromBuffer(length);\n      }\n    } while (true);\n  }\n\n  private byte[] readToEof() throws IOException {\n    if (bufferReadHead > 0) {\n      compactBuffer(true);\n    }\n\n    ByteStreams.copy(stream, buffer);\n\n    int length = buffer.getLength();\n    if (length == 0) {\n      return new byte[0];\n    } else {\n      return consumeBytesFromBuffer(length);\n    }\n  }\n\n  private byte[] readTo(int length) throws IOException {\n    if (length == 0) {\n      return new byte[0];\n    }\n\n    if (bufferReadHead > 0) {\n      compactBuffer(true);\n    }\n\n    int bytesStillNeeded = length - buffer.getLength();\n    if (bytesStillNeeded > 0) {\n      int bytesRead = fillBuffer(bytesStillNeeded);\n      while (bytesRead != -1 && bytesStillNeeded > 0) {\n        bytesStillNeeded -= bytesRead;\n        bytesRead = fillBuffer(bytesStillNeeded);\n      }\n    }\n\n    return consumeBytesFromBuffer(length);\n  }\n\n  private int bytesAvailableInBuffer() {\n    return buffer.getLength() - bufferReadHead;\n  }\n\n  private int indexOfNextNewlineInBuffer(int startFrom) {\n    byte[] bytes = buffer.getBuffer();\n    int bufferLength = buffer.getLength();\n    for (int i = bufferReadHead + startFrom; i < bufferLength; i++) {\n      if (bytes[i] == LINEFEED) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  private int fillBuffer(int length) throws IOException {\n    compactBuffer(false);\n    byte[] readBuf = new byte[length];\n    int bytesRead = stream.read(readBuf);\n    if (bytesRead > 0) {\n      buffer.write(readBuf, 0, bytesRead);\n    }\n    return bytesRead;\n  }\n\n  private byte[] consumeBytesFromBuffer(int length) {\n    int bytesAvailable = bytesAvailableInBuffer();\n    if (length > bytesAvailable) {\n      length = bytesAvailable;\n    }\n\n    if (length == 0) {\n      return null;\n    }\n\n    byte[] bytes = new byte[length];\n    byte[] bufferBytes = buffer.getBuffer();\n    System.arraycopy(bufferBytes, bufferReadHead, bytes, 0, length);\n    bufferReadHead += length;\n    return bytes;\n  }\n\n  private void compactBuffer(boolean force) {\n    byte[] bufferBytes = buffer.getBuffer();\n\n    // normally, only compact if we're at least 1K in, and at least 3/4 of the way in\n    if (force || (bufferReadHead > 1024 && bufferReadHead > (bufferBytes.length * 3 / 4))) {\n      int remainingBytes = bytesAvailableInBuffer();\n      System.arraycopy(bufferBytes, bufferReadHead, bufferBytes, 0, remainingBytes);\n      buffer.setLength(remainingBytes);\n      bufferReadHead = 0;\n    }\n  }\n}\n"}
{"test_method": "@Test public void readWithLengthZeroAtEof() throws Exception {\n    assertThat(empty.read(0)).isEqualTo(EMPTY_BYTES);\n  }", "focal_method": "public byte[] read(Integer length) throws IOException {\n    if (length == null) {\n      return readToEof();\n    } else {\n      return readTo(length);\n    }\n  }", "test_file": "package com.squareup.rack;\n\nimport java.io.ByteArrayInputStream;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static java.util.Arrays.copyOfRange;\nimport static org.fest.assertions.api.Assertions.assertThat;\n\npublic class RackInputTest {\n  public static final byte[] EMPTY_BYTES = \"\".getBytes();\n  public static final byte[] BYTES = \"Hello,\\nWorld!\".getBytes();\n\n  private RackInput empty;\n  private RackInput full;\n  private RackInput fullSlow;\n\n  @Before public void setUp() throws Exception {\n    empty = rackInputFor(EMPTY_BYTES);\n    full = rackInputFor(BYTES);\n    fullSlow = slowRackInputFor(BYTES);\n  }\n\n  @Test public void getsAtEof() throws Exception {\n    assertThat(empty.gets()).isNull();\n  }\n\n  @Test public void gets() throws Exception {\n    assertThat(full.gets()).isEqualTo(\"Hello,\\n\".getBytes());\n  }\n\n  @Test public void getsWithCrLf() throws Exception {\n    assertThat(rackInputFor(\"Hello,\\r\\nWorld!\").gets()).isEqualTo(\"Hello,\\r\\n\".getBytes());\n  }\n\n  @Test public void getsAgain() throws Exception {\n    full.gets();\n    assertThat(full.gets()).isEqualTo(\"World!\".getBytes());\n  }\n\n  @Test public void readWithLengthNilAtEof() throws Exception {\n    assertThat(empty.read(null)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthZeroAtEof() throws Exception {\n    assertThat(empty.read(0)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthAtEof() throws Exception {\n    assertThat(empty.read(1)).isNull();\n  }\n\n  @Test public void readWithLengthNil() throws Exception {\n    assertThat(full.read(null)).isEqualTo(BYTES);\n  }\n\n  @Test public void readWithLengthNilAgain() throws Exception {\n    full.read(null);\n    assertThat(full.read(null)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthZero() throws Exception {\n    assertThat(full.read(0)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLength() throws Exception {\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void readWithLengthAgain() throws Exception {\n    full.read(4);\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 4, 8));\n  }\n\n  @Test public void readFromSlowStreamWithLength() throws Exception {\n    assertThat(fullSlow.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void readFromSlowStreamWithLengthAgain() throws Exception {\n    fullSlow.read(4);\n    assertThat(fullSlow.read(4)).isEqualTo(copyOfRange(BYTES, 4, 8));\n  }\n\n  @Test public void readWithLengthTooLong() throws Exception {\n    assertThat(full.read(BYTES.length + 1)).isEqualTo(BYTES);\n  }\n\n  @Test public void readWithLengthTooLongAgain() throws Exception {\n    full.read(BYTES.length + 1);\n    assertThat(full.read(BYTES.length + 1)).isNull();\n  }\n\n  @Test public void rewind() throws Exception {\n    full.read(4);\n    full.rewind();\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void rewind_shouldDiscardAnyBufferedBytes() throws Exception {\n    RackInput subject = rackInputFor(\"first line\\r\\n123\\r\\n456\\r\\n\");\n    subject.gets();\n    subject.rewind();\n    assertThat(subject.gets()).isEqualTo(\"first line\\r\\n\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"123\\r\\n\".getBytes());\n  }\n\n  @Test public void intermixingReadMethodsIsSafe() throws Exception {\n    RackInput subject = rackInputFor(\"first line\\r\\n123\\r\\n456\\r\\n\");\n    assertThat(subject.read(1)).isEqualTo(\"f\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"irst line\\r\\n\".getBytes());\n    assertThat(subject.read(null)).isEqualTo(\"123\\r\\n456\\r\\n\".getBytes());\n    subject.rewind();\n    assertThat(subject.gets()).isEqualTo(\"first line\\r\\n\".getBytes());\n    assertThat(subject.read(3)).isEqualTo(\"123\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"\\r\\n\".getBytes());\n    assertThat(subject.read(null)).isEqualTo(\"456\\r\\n\".getBytes());\n  }\n\n  private RackInput rackInputFor(String string) throws Exception {\n    return rackInputFor(string.getBytes());\n  }\n\n  private RackInput rackInputFor(byte[] bytes) throws Exception {\n    return new RackInput(new ByteArrayInputStream(bytes));\n  }\n\n  private RackInput slowRackInputFor(byte[] bytes) throws Exception {\n    return new RackInput(new SlowByteArrayInputStream(bytes));\n  }\n}\n", "focal_file": "/*\n * Copyright (C) 2013 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.squareup.rack;\n\nimport com.google.common.io.ByteStreams;\nimport com.squareup.rack.io.ByteArrayBuffer;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\n/**\n * <p>Adapts an {@link InputStream} to the required interface for {@code rack.input}.</p>\n *\n * <p>Speaks {@code byte[]}, not {@code String}, because {@code rack.input} is required to have\n * binary encoding.</p>\n */\npublic class RackInput implements Closeable {\n  private static final int LINEFEED = 0xA;\n  private static final int MAX_LINE_LENGTH = 1024 * 1024;\n  private static final int READ_AHEAD_SUGGESTION = 1024 * 1024;\n\n  private final InputStream stream;\n  private final ByteArrayBuffer buffer = new ByteArrayBuffer();\n  private int bufferReadHead;\n\n  /**\n   * Creates a {@link RackInput} stream that draws from the given {@link InputStream}.\n   *\n   * @param inputStream the source stream.\n   */\n  public RackInput(InputStream inputStream) {\n    checkNotNull(inputStream);\n    checkArgument(inputStream.markSupported(),\n        \"rack.input must be rewindable, but inputStream doesn't support mark.\");\n\n    stream = inputStream;\n    stream.mark(READ_AHEAD_SUGGESTION);\n  }\n\n  /**\n   * Reads the next line from the stream.\n   *\n   * @return the next line, or null at EOF.\n   * @throws IOException\n   */\n  public byte[] gets() throws IOException {\n    return readToLinefeed();\n  }\n\n  /**\n   * Reads length bytes from the stream. Reads all the way to EOF when length is null.\n   *\n   * @param length the desired number of bytes, or null.\n   * @return the bytes, or null at EOF when length is present.\n   * @throws IOException\n   */\n  public byte[] read(Integer length) throws IOException {\n    if (length == null) {\n      return readToEof();\n    } else {\n      return readTo(length);\n    }\n  }\n\n  /**\n   * Resets the stream, so that it may be read again from the beginning.\n   *\n   * @throws IOException\n   */\n  public void rewind() throws IOException {\n    stream.reset();\n    buffer.reset();\n    bufferReadHead = 0;\n  }\n\n  /**\n   * Closes the stream.\n   *\n   * @throws IOException\n   */\n  @Override public void close() throws IOException {\n    stream.close();\n  }\n\n  private byte[] readToLinefeed() throws IOException {\n    int startFrom = 0;\n    do {\n      int indexOfNewline = indexOfNextNewlineInBuffer(startFrom);\n\n      if (indexOfNewline == -1) {\n        int bytesPresent = bytesAvailableInBuffer();\n\n        if (bytesPresent > MAX_LINE_LENGTH) {\n          throw new RuntimeException(\n              \"Really, you have a line longer than \" + MAX_LINE_LENGTH + \" bytes?\");\n        }\n\n        // next time through, start where we left off.\n        startFrom = bytesPresent;\n\n        int bytesRead = fillBuffer(8 * 1024);\n        if (bytesRead == -1) {\n          int bytesRemaining = bytesAvailableInBuffer();\n          return consumeBytesFromBuffer(bytesRemaining);\n        }\n      } else {\n        int length = indexOfNewline - bufferReadHead + 1;\n        return consumeBytesFromBuffer(length);\n      }\n    } while (true);\n  }\n\n  private byte[] readToEof() throws IOException {\n    if (bufferReadHead > 0) {\n      compactBuffer(true);\n    }\n\n    ByteStreams.copy(stream, buffer);\n\n    int length = buffer.getLength();\n    if (length == 0) {\n      return new byte[0];\n    } else {\n      return consumeBytesFromBuffer(length);\n    }\n  }\n\n  private byte[] readTo(int length) throws IOException {\n    if (length == 0) {\n      return new byte[0];\n    }\n\n    if (bufferReadHead > 0) {\n      compactBuffer(true);\n    }\n\n    int bytesStillNeeded = length - buffer.getLength();\n    if (bytesStillNeeded > 0) {\n      int bytesRead = fillBuffer(bytesStillNeeded);\n      while (bytesRead != -1 && bytesStillNeeded > 0) {\n        bytesStillNeeded -= bytesRead;\n        bytesRead = fillBuffer(bytesStillNeeded);\n      }\n    }\n\n    return consumeBytesFromBuffer(length);\n  }\n\n  private int bytesAvailableInBuffer() {\n    return buffer.getLength() - bufferReadHead;\n  }\n\n  private int indexOfNextNewlineInBuffer(int startFrom) {\n    byte[] bytes = buffer.getBuffer();\n    int bufferLength = buffer.getLength();\n    for (int i = bufferReadHead + startFrom; i < bufferLength; i++) {\n      if (bytes[i] == LINEFEED) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  private int fillBuffer(int length) throws IOException {\n    compactBuffer(false);\n    byte[] readBuf = new byte[length];\n    int bytesRead = stream.read(readBuf);\n    if (bytesRead > 0) {\n      buffer.write(readBuf, 0, bytesRead);\n    }\n    return bytesRead;\n  }\n\n  private byte[] consumeBytesFromBuffer(int length) {\n    int bytesAvailable = bytesAvailableInBuffer();\n    if (length > bytesAvailable) {\n      length = bytesAvailable;\n    }\n\n    if (length == 0) {\n      return null;\n    }\n\n    byte[] bytes = new byte[length];\n    byte[] bufferBytes = buffer.getBuffer();\n    System.arraycopy(bufferBytes, bufferReadHead, bytes, 0, length);\n    bufferReadHead += length;\n    return bytes;\n  }\n\n  private void compactBuffer(boolean force) {\n    byte[] bufferBytes = buffer.getBuffer();\n\n    // normally, only compact if we're at least 1K in, and at least 3/4 of the way in\n    if (force || (bufferReadHead > 1024 && bufferReadHead > (bufferBytes.length * 3 / 4))) {\n      int remainingBytes = bytesAvailableInBuffer();\n      System.arraycopy(bufferBytes, bufferReadHead, bufferBytes, 0, remainingBytes);\n      buffer.setLength(remainingBytes);\n      bufferReadHead = 0;\n    }\n  }\n}\n"}
{"test_method": "@Test public void info() {\n    subject.info(MESSAGE);\n    verify(delegate).info(MESSAGE);\n  }", "focal_method": "public void info(String message) {\n    logger.info(message);\n  }", "test_file": "package com.squareup.rack;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.runners.MockitoJUnitRunner;\nimport org.slf4j.Logger;\n\nimport static com.squareup.rack.RackLogger.FATAL;\nimport static org.mockito.Mockito.verify;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class RackLoggerTest {\n  private static final String MESSAGE = \"message\";\n\n  private RackLogger subject;\n  @Mock private Logger delegate;\n\n  @Before public void setUp() {\n    subject = new RackLogger(delegate);\n  }\n\n  @Test(expected = NullPointerException.class)\n  public void constructorRequiresALogger() {\n    new RackLogger(null);\n  }\n\n  @Test public void info() {\n    subject.info(MESSAGE);\n    verify(delegate).info(MESSAGE);\n  }\n\n  @Test public void debug() {\n    subject.debug(MESSAGE);\n    verify(delegate).debug(MESSAGE);\n  }\n\n  @Test public void warn() {\n    subject.warn(MESSAGE);\n    verify(delegate).warn(MESSAGE);\n  }\n\n  @Test public void error() {\n    subject.error(MESSAGE);\n    verify(delegate).error(MESSAGE);\n  }\n\n  @Test public void fatal() {\n    subject.fatal(MESSAGE);\n    verify(delegate).error(FATAL, MESSAGE);\n  }\n}\n", "focal_file": "/*\n * Copyright (C) 2013 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.squareup.rack;\n\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.MarkerFactory;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\n/**\n * Adapts a {@link Logger} to the required interface for {@code rack.logger}.\n */\npublic class RackLogger {\n  public static final Marker FATAL = MarkerFactory.getMarker(\"FATAL\");\n\n  private final Logger logger;\n\n  /**\n   * Creates a {@link RackLogger} that forwards messages to the given {@link Logger}.\n   *\n   * @param logger\n   */\n  public RackLogger(Logger logger) {\n    this.logger = checkNotNull(logger);\n  }\n\n  public void info(String message) {\n    logger.info(message);\n  }\n\n  public void debug(String message) {\n    logger.debug(message);\n  }\n\n  public void warn(String message) {\n    logger.warn(message);\n  }\n\n  public void error(String message) {\n    logger.error(message);\n  }\n\n  public void fatal(String message) {\n    // See http://www.slf4j.org/faq.html#fatal\n    logger.error(FATAL, message);\n  }\n}\n"}
{"test_method": "@Test public void callSetsTheResponseHeaders() {\n    RackResponse response = app.call(env);\n    assertThat(response.getHeaders()).contains(entry(\"Content-Type\", \"text/plain\"));\n  }", "focal_method": "@Override public RackResponse call(RackEnvironment environment) {\n    RubyHash environmentHash = convertToRubyHash(environment.entrySet());\n\n    RubyArray response = callRackApplication(environmentHash);\n\n    return convertToJavaRackResponse(response);\n  }", "test_file": "package com.squareup.rack.jruby;\n\nimport com.google.common.base.Joiner;\nimport com.google.common.collect.ImmutableList;\nimport com.squareup.rack.RackApplication;\nimport com.squareup.rack.RackEnvironment;\nimport com.squareup.rack.RackResponse;\nimport com.squareup.rack.servlet.RackEnvironmentBuilder;\nimport com.squareup.rack.servlet.TestHttpServletRequest;\nimport java.util.Iterator;\nimport org.jruby.Ruby;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static org.fest.assertions.api.Assertions.assertThat;\nimport static org.fest.assertions.data.MapEntry.entry;\n\npublic class JRubyRackApplicationTest {\n  private static final Joiner SPACE = Joiner.on(' ');\n\n  private RackApplication app;\n  private RackEnvironment env;\n\n  @Before public void setUp() {\n    IRubyObject callable = Ruby.getGlobalRuntime()\n        .evalScriptlet(\"proc { |env| [200, {'Content-Type' => 'text/plain'}, env.keys] }\");\n\n    RackEnvironmentBuilder envBuilder = new RackEnvironmentBuilder();\n    TestHttpServletRequest request = TestHttpServletRequest.newBuilder().build();\n    app = new JRubyRackApplication(callable);\n    env = envBuilder.build(request);\n  }\n\n  @Test public void callSetsTheResponseStatus() {\n    RackResponse response = app.call(env);\n    assertThat(response.getStatus()).isEqualTo(200);\n  }\n\n  @Test public void callSetsTheResponseHeaders() {\n    RackResponse response = app.call(env);\n    assertThat(response.getHeaders()).contains(entry(\"Content-Type\", \"text/plain\"));\n  }\n\n  @Test public void callSetsTheResponseBody() {\n    RackResponse response = app.call(env);\n\n    ImmutableList.Builder<String> strings = ImmutableList.builder();\n\n    Iterator<byte[]> bytes = response.getBody();\n    while (bytes.hasNext()) {\n      strings.add(new String(bytes.next()));\n    }\n\n    assertThat(SPACE.join(strings.build())).isEqualTo(SPACE.join(env.keySet()));\n  }\n\n  @Test public void callParsesTheResponseStatusFromAString() {\n    IRubyObject callable = Ruby.getGlobalRuntime()\n        .evalScriptlet(\"proc { |env| ['201', {'Content-Type' => 'text/plain'}, env.keys] }\");\n    app = new JRubyRackApplication(callable);\n\n    RackResponse response = app.call(env);\n    assertThat(response.getStatus()).isEqualTo(201);\n  }\n}\n", "focal_file": "/*\n * Copyright (C) 2013 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.squareup.rack.jruby;\n\nimport com.squareup.rack.RackApplication;\nimport com.squareup.rack.RackEnvironment;\nimport com.squareup.rack.RackInput;\nimport com.squareup.rack.RackResponse;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport org.jruby.Ruby;\nimport org.jruby.RubyArray;\nimport org.jruby.RubyHash;\nimport org.jruby.internal.runtime.ThreadService;\nimport org.jruby.runtime.builtin.IRubyObject;\n\nimport static org.jruby.RubyHash.newHash;\n\n/**\n * Adapts a (RubyObject) Rack application into Java-space.\n */\npublic class JRubyRackApplication implements RackApplication {\n  private final IRubyObject application;\n  private final Ruby runtime;\n  private final ThreadService threadService;\n\n  /**\n   * <p>Creates a {@link RackApplication} that delegates to the given Ruby Rack application.</p>\n   *\n   * <p>To obtain the necessary {@link IRubyObject}, you can create a JRuby\n   * {@link org.jruby.embed.ScriptingContainer} and {@link org.jruby.embed.ScriptingContainer#parse}\n   * and {@link org.jruby.embed.EmbedEvalUnit#run()} your Ruby code. See our examples for concrete\n   * code.</p>\n   *\n   * @param application the Ruby Rack application.\n   */\n  public JRubyRackApplication(IRubyObject application) {\n    this.application = application;\n    this.runtime = application.getRuntime();\n    this.threadService = runtime.getThreadService();\n  }\n\n  /**\n   * Calls the delegate Rack application, translating into and back out of the JRuby interpreter.\n   *\n   * @param environment the Rack environment\n   * @return the Rack response\n   */\n  @Override public RackResponse call(RackEnvironment environment) {\n    RubyHash environmentHash = convertToRubyHash(environment.entrySet());\n\n    RubyArray response = callRackApplication(environmentHash);\n\n    return convertToJavaRackResponse(response);\n  }\n\n  private RubyHash convertToRubyHash(Set<Map.Entry<String, Object>> entries) {\n    RubyHash hash = newHash(runtime);\n\n    for (Map.Entry<String, Object> entry : entries) {\n      String key = entry.getKey();\n      Object value = entry.getValue();\n\n      if (key.equals(\"rack.input\")) {\n        value = new JRubyRackInput(runtime, (RackInput) value);\n      }\n\n      if (key.equals(\"rack.version\")) {\n        value = convertToRubyArray((List<Integer>) value);\n      }\n\n      hash.put(key, value);\n    }\n\n    return hash;\n  }\n\n  private RubyArray convertToRubyArray(List<Integer> list) {\n    RubyArray array = RubyArray.newEmptyArray(runtime);\n    array.addAll(list);\n    return array;\n  }\n\n  private RubyArray callRackApplication(RubyHash rubyHash) {\n    return (RubyArray) application.callMethod(threadService.getCurrentContext(), \"call\", rubyHash);\n  }\n\n  private RackResponse convertToJavaRackResponse(RubyArray response) {\n    int status = Integer.parseInt(response.get(0).toString(), 10);\n    Map headers = (Map) response.get(1);\n    IRubyObject body = (IRubyObject) response.get(2);\n\n    return new RackResponse(status, headers, new JRubyRackBodyIterator(body));\n  }\n}\n"}
{"test_method": "@Test public void shouldWrapJavaIOExceptions() throws Exception {\n    Ruby ruby = Ruby.newInstance();\n    RackInput rackInput = mock(RackInput.class);\n    when(rackInput.read(null)).thenThrow(new IOException(\"fake\"));\n\n    JRubyRackInput subject = new JRubyRackInput(ruby, rackInput);\n    GlobalVariables globalVariables = ruby.getGlobalVariables();\n    globalVariables.set(\"$rack_input\", subject);\n\n    IRubyObject result =\n        ruby.evalScriptlet(\n            \"begin; $rack_input.read; rescue IOError => e; \\\"rescued #{e.message}\\\"; end\");\n    assertThat(result.asJavaString()).isEqualTo(\"rescued fake\");\n  }", "focal_method": "@JRubyMethod(optional = 1) public IRubyObject read(ThreadContext context, IRubyObject[] args) {\n    Integer length = null;\n\n    if (args.length > 0) {\n      long arg = args[0].convertToInteger(\"to_i\").getLongValue();\n      length = (int) Math.min(arg, Integer.MAX_VALUE);\n    }\n\n    try {\n      return toRubyString(rackInput.read(length));\n    } catch (IOException e) {\n      throw getRuntime().newIOErrorFromException(e);\n    }\n  }", "test_file": "package com.squareup.rack.jruby;\n\nimport com.squareup.rack.RackInput;\nimport java.io.IOException;\nimport org.jruby.Ruby;\nimport org.jruby.internal.runtime.GlobalVariables;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport org.junit.Test;\n\nimport static org.fest.assertions.api.Assertions.assertThat;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\n\npublic class JRubyRackInputTest {\n  @Test public void shouldWrapJavaIOExceptions() throws Exception {\n    Ruby ruby = Ruby.newInstance();\n    RackInput rackInput = mock(RackInput.class);\n    when(rackInput.read(null)).thenThrow(new IOException(\"fake\"));\n\n    JRubyRackInput subject = new JRubyRackInput(ruby, rackInput);\n    GlobalVariables globalVariables = ruby.getGlobalVariables();\n    globalVariables.set(\"$rack_input\", subject);\n\n    IRubyObject result =\n        ruby.evalScriptlet(\n            \"begin; $rack_input.read; rescue IOError => e; \\\"rescued #{e.message}\\\"; end\");\n    assertThat(result.asJavaString()).isEqualTo(\"rescued fake\");\n  }\n}\n", "focal_file": "/*\n * Copyright (C) 2013 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.squareup.rack.jruby;\n\nimport com.squareup.rack.RackInput;\nimport java.io.IOException;\nimport org.jcodings.Encoding;\nimport org.jruby.Ruby;\nimport org.jruby.RubyClass;\nimport org.jruby.RubyModule;\nimport org.jruby.RubyObject;\nimport org.jruby.RubyString;\nimport org.jruby.anno.JRubyMethod;\nimport org.jruby.runtime.Block;\nimport org.jruby.runtime.ObjectAllocator;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport org.jruby.util.ByteList;\n\n/**\n * <p>Adapts a {@link com.squareup.rack.RackInput} into Ruby-space.</p>\n *\n * <p>Is primarily responsible for translating Java byte arrays into Ruby Strings with\n * {@code ASCII-8BIT} encoding.</p>\n */\npublic class JRubyRackInput extends RubyObject {\n  private RackInput rackInput;\n  private Encoding ascii8bitEncoding;\n\n  private static final ObjectAllocator ALLOCATOR = new ObjectAllocator() {\n    public IRubyObject allocate(Ruby runtime, RubyClass klass) {\n      return new JRubyRackInput(runtime, klass);\n    }\n  };\n\n  private static RubyClass getRackInputClass(Ruby runtime) {\n    RubyModule module = runtime.getOrCreateModule(\"RackServlet\");\n    RubyClass klass = module.getClass(\"RackInput\");\n    if (klass == null) {\n      klass = module.defineClassUnder(\"RackInput\", runtime.getObject(), ALLOCATOR);\n      klass.defineAnnotatedMethods(JRubyRackInput.class);\n    }\n    return klass;\n  }\n\n  JRubyRackInput(Ruby runtime, RubyClass klass) {\n    super(runtime, klass);\n  }\n\n  /**\n   * Creates a Ruby IO object that delegates to the given {@link RackInput}.\n   *\n   * @param runtime the Ruby runtime that will host this instance.\n   * @param rackInput the backing data source.\n   */\n  public JRubyRackInput(Ruby runtime, RackInput rackInput) {\n    super(runtime, getRackInputClass(runtime));\n    this.rackInput = rackInput;\n    this.ascii8bitEncoding = runtime.getEncodingService().getAscii8bitEncoding();\n  }\n\n  @JRubyMethod public IRubyObject gets() {\n    try {\n      return toRubyString(rackInput.gets());\n    } catch (IOException e) {\n      throw getRuntime().newIOErrorFromException(e);\n    }\n  }\n\n  @JRubyMethod public IRubyObject each(ThreadContext context, Block block) {\n    IRubyObject nil = getRuntime().getNil();\n    IRubyObject line;\n    while ((line = gets()) != nil) {\n      block.yield(context, line);\n    }\n    return nil;\n  }\n\n  @JRubyMethod(optional = 1) public IRubyObject read(ThreadContext context, IRubyObject[] args) {\n    Integer length = null;\n\n    if (args.length > 0) {\n      long arg = args[0].convertToInteger(\"to_i\").getLongValue();\n      length = (int) Math.min(arg, Integer.MAX_VALUE);\n    }\n\n    try {\n      return toRubyString(rackInput.read(length));\n    } catch (IOException e) {\n      throw getRuntime().newIOErrorFromException(e);\n    }\n  }\n\n  @JRubyMethod public IRubyObject rewind() {\n    try {\n      rackInput.rewind();\n    } catch (IOException e) {\n      throw getRuntime().newIOErrorFromException(e);\n    }\n    return getRuntime().getNil();\n  }\n\n  private IRubyObject toRubyString(byte[] bytes) {\n    if (bytes == null) {\n      return getRuntime().getNil();\n    } else {\n      return RubyString.newString(getRuntime(), new ByteList(bytes, ascii8bitEncoding));\n    }\n  }\n}\n"}
{"test_method": "@Test public void callSetsTheResponseStatus() {\n    RackResponse response = app.call(env);\n    assertThat(response.getStatus()).isEqualTo(200);\n  }", "focal_method": "@Override public RackResponse call(RackEnvironment environment) {\n    RubyHash environmentHash = convertToRubyHash(environment.entrySet());\n\n    RubyArray response = callRackApplication(environmentHash);\n\n    return convertToJavaRackResponse(response);\n  }", "test_file": "package com.squareup.rack.jruby;\n\nimport com.google.common.base.Joiner;\nimport com.google.common.collect.ImmutableList;\nimport com.squareup.rack.RackApplication;\nimport com.squareup.rack.RackEnvironment;\nimport com.squareup.rack.RackResponse;\nimport com.squareup.rack.servlet.RackEnvironmentBuilder;\nimport com.squareup.rack.servlet.TestHttpServletRequest;\nimport java.util.Iterator;\nimport org.jruby.Ruby;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static org.fest.assertions.api.Assertions.assertThat;\nimport static org.fest.assertions.data.MapEntry.entry;\n\npublic class JRubyRackApplicationTest {\n  private static final Joiner SPACE = Joiner.on(' ');\n\n  private RackApplication app;\n  private RackEnvironment env;\n\n  @Before public void setUp() {\n    IRubyObject callable = Ruby.getGlobalRuntime()\n        .evalScriptlet(\"proc { |env| [200, {'Content-Type' => 'text/plain'}, env.keys] }\");\n\n    RackEnvironmentBuilder envBuilder = new RackEnvironmentBuilder();\n    TestHttpServletRequest request = TestHttpServletRequest.newBuilder().build();\n    app = new JRubyRackApplication(callable);\n    env = envBuilder.build(request);\n  }\n\n  @Test public void callSetsTheResponseStatus() {\n    RackResponse response = app.call(env);\n    assertThat(response.getStatus()).isEqualTo(200);\n  }\n\n  @Test public void callSetsTheResponseHeaders() {\n    RackResponse response = app.call(env);\n    assertThat(response.getHeaders()).contains(entry(\"Content-Type\", \"text/plain\"));\n  }\n\n  @Test public void callSetsTheResponseBody() {\n    RackResponse response = app.call(env);\n\n    ImmutableList.Builder<String> strings = ImmutableList.builder();\n\n    Iterator<byte[]> bytes = response.getBody();\n    while (bytes.hasNext()) {\n      strings.add(new String(bytes.next()));\n    }\n\n    assertThat(SPACE.join(strings.build())).isEqualTo(SPACE.join(env.keySet()));\n  }\n\n  @Test public void callParsesTheResponseStatusFromAString() {\n    IRubyObject callable = Ruby.getGlobalRuntime()\n        .evalScriptlet(\"proc { |env| ['201', {'Content-Type' => 'text/plain'}, env.keys] }\");\n    app = new JRubyRackApplication(callable);\n\n    RackResponse response = app.call(env);\n    assertThat(response.getStatus()).isEqualTo(201);\n  }\n}\n", "focal_file": "/*\n * Copyright (C) 2013 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.squareup.rack.jruby;\n\nimport com.squareup.rack.RackApplication;\nimport com.squareup.rack.RackEnvironment;\nimport com.squareup.rack.RackInput;\nimport com.squareup.rack.RackResponse;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport org.jruby.Ruby;\nimport org.jruby.RubyArray;\nimport org.jruby.RubyHash;\nimport org.jruby.internal.runtime.ThreadService;\nimport org.jruby.runtime.builtin.IRubyObject;\n\nimport static org.jruby.RubyHash.newHash;\n\n/**\n * Adapts a (RubyObject) Rack application into Java-space.\n */\npublic class JRubyRackApplication implements RackApplication {\n  private final IRubyObject application;\n  private final Ruby runtime;\n  private final ThreadService threadService;\n\n  /**\n   * <p>Creates a {@link RackApplication} that delegates to the given Ruby Rack application.</p>\n   *\n   * <p>To obtain the necessary {@link IRubyObject}, you can create a JRuby\n   * {@link org.jruby.embed.ScriptingContainer} and {@link org.jruby.embed.ScriptingContainer#parse}\n   * and {@link org.jruby.embed.EmbedEvalUnit#run()} your Ruby code. See our examples for concrete\n   * code.</p>\n   *\n   * @param application the Ruby Rack application.\n   */\n  public JRubyRackApplication(IRubyObject application) {\n    this.application = application;\n    this.runtime = application.getRuntime();\n    this.threadService = runtime.getThreadService();\n  }\n\n  /**\n   * Calls the delegate Rack application, translating into and back out of the JRuby interpreter.\n   *\n   * @param environment the Rack environment\n   * @return the Rack response\n   */\n  @Override public RackResponse call(RackEnvironment environment) {\n    RubyHash environmentHash = convertToRubyHash(environment.entrySet());\n\n    RubyArray response = callRackApplication(environmentHash);\n\n    return convertToJavaRackResponse(response);\n  }\n\n  private RubyHash convertToRubyHash(Set<Map.Entry<String, Object>> entries) {\n    RubyHash hash = newHash(runtime);\n\n    for (Map.Entry<String, Object> entry : entries) {\n      String key = entry.getKey();\n      Object value = entry.getValue();\n\n      if (key.equals(\"rack.input\")) {\n        value = new JRubyRackInput(runtime, (RackInput) value);\n      }\n\n      if (key.equals(\"rack.version\")) {\n        value = convertToRubyArray((List<Integer>) value);\n      }\n\n      hash.put(key, value);\n    }\n\n    return hash;\n  }\n\n  private RubyArray convertToRubyArray(List<Integer> list) {\n    RubyArray array = RubyArray.newEmptyArray(runtime);\n    array.addAll(list);\n    return array;\n  }\n\n  private RubyArray callRackApplication(RubyHash rubyHash) {\n    return (RubyArray) application.callMethod(threadService.getCurrentContext(), \"call\", rubyHash);\n  }\n\n  private RackResponse convertToJavaRackResponse(RubyArray response) {\n    int status = Integer.parseInt(response.get(0).toString(), 10);\n    Map headers = (Map) response.get(1);\n    IRubyObject body = (IRubyObject) response.get(2);\n\n    return new RackResponse(status, headers, new JRubyRackBodyIterator(body));\n  }\n}\n"}
{"test_method": "@Test public void rackInput() throws IOException {\n    request.method(\"POST\").body(\"foo=42&bar=0\");\n    assertThat(environment()).containsKey(\"rack.input\");\n    assertThat(environment().get(\"rack.input\")).isInstanceOf(RackInput.class);\n  }", "focal_method": "private RackInput rackInput(HttpServletRequest request) {\n    try {\n      return new RackInput(new TempfileBufferedInputStream(request.getInputStream()));\n    } catch (IOException e) {\n      throw propagate(e);\n    }\n  }", "test_file": "package com.squareup.rack.servlet;\n\nimport com.google.common.collect.ImmutableList;\nimport com.squareup.rack.RackErrors;\nimport com.squareup.rack.RackInput;\nimport com.squareup.rack.RackLogger;\nimport java.io.IOException;\nimport java.util.Map;\nimport javax.servlet.http.HttpServletRequest;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.runners.MockitoJUnitRunner;\n\nimport static org.fest.assertions.api.Assertions.assertThat;\nimport static org.fest.assertions.data.MapEntry.entry;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class RackEnvironmentBuilderTest {\n  private TestHttpServletRequest.Builder request;\n  private HttpServletRequest httpServletRequest;\n\n  @Before public void setUp() {\n    this.request = TestHttpServletRequest.newBuilder();\n  }\n\n  @Test public void requestMethod() {\n    request.method(\"PUT\");\n    assertThat(environment()).contains(entry(\"REQUEST_METHOD\", \"PUT\"));\n  }\n\n  @Test public void scriptNameAndPathInfoWheRequestingTheRoot() {\n    request.uri(\"http://example.com/\");\n    assertThat(environment()).contains(entry(\"SCRIPT_NAME\", \"\"));\n    assertThat(environment()).contains(entry(\"PATH_INFO\", \"/\"));\n  }\n\n  @Test public void scriptNameAndPathInfoWhenRequestingAPath() {\n    request.uri(\"http://example.com/path/to/resource\");\n    assertThat(environment()).contains(entry(\"SCRIPT_NAME\", \"\"));\n    assertThat(environment()).contains(entry(\"PATH_INFO\", \"/path/to/resource\"));\n  }\n\n  @Test public void scriptNameAndPathInfoWhenMountedAndRequestingTheRoot() {\n    request.uri(\"http://example.com/path/to\").whenMountedAt(\"/path/to/*\");\n    assertThat(environment()).contains(entry(\"SCRIPT_NAME\", \"/path/to\"));\n    assertThat(environment()).contains(entry(\"PATH_INFO\", \"\"));\n  }\n\n  @Test public void scriptNameAndPathInfoWhenMountedAndRequestingAPath() {\n    request.uri(\"http://example.com/path/to/resource\").whenMountedAt(\"/path/to/*\");\n    assertThat(environment()).contains(entry(\"SCRIPT_NAME\", \"/path/to\"));\n    assertThat(environment()).contains(entry(\"PATH_INFO\", \"/resource\"));\n  }\n\n  @Test public void queryString() {\n    request.uri(\"http://example.com/\");\n    assertThat(environment()).contains(entry(\"QUERY_STRING\", \"\"));\n  }\n\n  @Test public void queryStringGiven() {\n    request.uri(\"http://example.com/?foo=bar\");\n    assertThat(environment()).contains(entry(\"QUERY_STRING\", \"foo=bar\"));\n  }\n\n  @Test public void serverName() {\n    request.uri(\"http://example.com/\");\n    assertThat(environment()).contains(entry(\"SERVER_NAME\", \"example.com\"));\n  }\n\n  @Test public void serverPortHttp() {\n    request.uri(\"http://example.com/\");\n    assertThat(environment()).contains(entry(\"SERVER_PORT\", \"80\"));\n  }\n\n  @Test public void serverPortHttps() {\n    request.uri(\"https://example.com/\");\n    assertThat(environment()).contains(entry(\"SERVER_PORT\", \"443\"));\n  }\n\n  @Test public void serverPortGiven() {\n    request.uri(\"http://example.com:1234/\");\n    assertThat(environment()).contains(entry(\"SERVER_PORT\", \"1234\"));\n  }\n\n  @Test public void httpHeaders() {\n    request.header(\"If-None-Match\", \"737060cd8c284d8af7ad3082f209582d\");\n    assertThat(environment()).contains(\n        entry(\"HTTP_IF_NONE_MATCH\", \"737060cd8c284d8af7ad3082f209582d\"));\n  }\n\n  @Test public void httpHeadersWithMultipleValues() {\n    request.header(\"Accept\", \"text/plain\").header(\"Accept\", \"text/html\");\n    assertThat(environment()).contains(entry(\"HTTP_ACCEPT\", \"text/plain,text/html\"));\n  }\n\n  @Test public void httpHeadersContentLength() {\n    request.header(\"Content-Length\", \"42\");\n    assertThat(environment()).contains(entry(\"CONTENT_LENGTH\", \"42\"));\n    assertThat(environment()).doesNotContainKey(\"HTTP_CONTENT_LENGTH\");\n  }\n\n  @Test public void httpHeadersContentType() {\n    request.header(\"Content-Type\", \"application/json\");\n    assertThat(environment()).contains(entry(\"CONTENT_TYPE\", \"application/json\"));\n    assertThat(environment()).doesNotContainKey(\"HTTP_CONTENT_TYPE\");\n  }\n\n  @Test public void httpHeadersXForwardedForMultiple() {\n    request.header(\"X-Forwarded-For\", \"192.168.0.1\");\n    request.header(\"X-Forwarded-For\", \"10.0.1.1\");\n    assertThat(environment()).contains(entry(\"HTTP_X_FORWARDED_FOR\", \"192.168.0.1,10.0.1.1\"));\n  }\n\n  @Test public void httpHeadersXForwardedForMultiplePunctuationDifferences() {\n    // There seems to be mixed consensus on the internet as to what to do in this case. Underscores\n    // are perfectly valid in HTTP header names, but many webservers discard such headers so as to\n    // avoid collision with CGI environment variables. (See nginx's underscores_in_headers setting.)\n    // We choose to honor them, folding their values in with their dashed brethren.\n    request.header(\"X-Forwarded-For\", \"192.168.0.1\");\n    request.header(\"X-Forwarded_For\", \"10.0.1.1\");\n    assertThat(environment()).contains(entry(\"HTTP_X_FORWARDED_FOR\", \"192.168.0.1,10.0.1.1\"));\n  }\n\n  @Test public void rackVersion() {\n    assertThat(environment()).contains(entry(\"rack.version\", ImmutableList.of(1, 2)));\n  }\n\n  @Test public void rackUrlSchemeHttp() {\n    request.uri(\"http://example.com/\");\n    assertThat(environment()).contains(entry(\"rack.url_scheme\", \"http\"));\n  }\n\n  @Test public void rackUrlSchemeHttps() {\n    request.uri(\"https://example.com/\");\n    assertThat(environment()).contains(entry(\"rack.url_scheme\", \"https\"));\n  }\n\n  @Test public void rackUrlSchemeHttpYelling() {\n    request.uri(\"HTTP://EXAMPLE.COM/\");\n    assertThat(environment()).contains(entry(\"rack.url_scheme\", \"http\"));\n  }\n\n  @Test public void rackInput() throws IOException {\n    request.method(\"POST\").body(\"foo=42&bar=0\");\n    assertThat(environment()).containsKey(\"rack.input\");\n    assertThat(environment().get(\"rack.input\")).isInstanceOf(RackInput.class);\n  }\n\n  @Test public void rackErrors() {\n    assertThat(environment()).containsKey(\"rack.errors\");\n    assertThat(environment().get(\"rack.errors\")).isInstanceOf(RackErrors.class);\n  }\n\n  @Test public void rackLogger() {\n    assertThat(environment()).containsKey(\"rack.logger\");\n    assertThat(environment().get(\"rack.logger\")).isInstanceOf(RackLogger.class);\n  }\n\n  @Test public void rackMultithread() {\n    assertThat(environment()).contains(entry(\"rack.multithread\", true));\n  }\n\n  @Test public void rackMultiprocess() {\n    assertThat(environment()).contains(entry(\"rack.multiprocess\", true));\n  }\n\n  @Test public void rackRunOnce() {\n    assertThat(environment()).contains(entry(\"rack.run_once\", false));\n  }\n\n  @Test public void rackIsHijack() {\n    assertThat(environment()).contains(entry(\"rack.hijack?\", false));\n  }\n\n  @Test public void rackHijack() {\n    assertThat(environment()).doesNotContainKey(\"rack.hijack\");\n  }\n\n  @Test public void rackHijackIo() {\n    assertThat(environment()).doesNotContainKey(\"rack.hijack_io\");\n  }\n\n  @Test public void rackHttpServletRequest() {\n    assertThat(environment()).containsKey(\"minecart.http_servlet_request\");\n    assertThat(environment().get(\"minecart.http_servlet_request\")).isSameAs(httpServletRequest);\n  }\n\n  @Test public void rackAttributes() {\n    Object testObject = new Object();\n    request.attribute(\"ExampleAttribute\", testObject);\n    assertThat(environment()).containsKey(\"ExampleAttribute\");\n    assertThat(environment().get(\"ExampleAttribute\")).isSameAs(testObject);\n  }\n\n  private Map<String, Object> environment() {\n    RackEnvironmentBuilder environmentBuilder = new RackEnvironmentBuilder();\n    httpServletRequest = request.build();\n    return environmentBuilder.build(httpServletRequest);\n  }\n}\n", "focal_file": "/*\n * Copyright (C) 2013 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.squareup.rack.servlet;\n\nimport com.google.common.base.CharMatcher;\nimport com.google.common.base.Joiner;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableListMultimap;\nimport com.google.common.collect.ImmutableMap;\nimport com.squareup.rack.RackEnvironment;\nimport com.squareup.rack.RackErrors;\nimport com.squareup.rack.RackInput;\nimport com.squareup.rack.RackLogger;\nimport com.squareup.rack.io.TempfileBufferedInputStream;\nimport java.io.IOException;\nimport java.util.Collection;\nimport java.util.Enumeration;\nimport java.util.List;\nimport java.util.Map;\nimport javax.servlet.http.HttpServletRequest;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static com.google.common.base.Strings.nullToEmpty;\nimport static com.google.common.base.Throwables.propagate;\nimport static com.squareup.rack.RackEnvironment.CONTENT_LENGTH;\nimport static com.squareup.rack.RackEnvironment.CONTENT_TYPE;\nimport static com.squareup.rack.RackEnvironment.HTTP_HEADER_PREFIX;\nimport static com.squareup.rack.RackEnvironment.MINECART_HTTP_SERVLET_REQUEST;\nimport static com.squareup.rack.RackEnvironment.PATH_INFO;\nimport static com.squareup.rack.RackEnvironment.QUERY_STRING;\nimport static com.squareup.rack.RackEnvironment.RACK_ERRORS;\nimport static com.squareup.rack.RackEnvironment.RACK_HIJACK;\nimport static com.squareup.rack.RackEnvironment.RACK_INPUT;\nimport static com.squareup.rack.RackEnvironment.RACK_LOGGER;\nimport static com.squareup.rack.RackEnvironment.RACK_MULTIPROCESS;\nimport static com.squareup.rack.RackEnvironment.RACK_MULTITHREAD;\nimport static com.squareup.rack.RackEnvironment.RACK_RUN_ONCE;\nimport static com.squareup.rack.RackEnvironment.RACK_URL_SCHEME;\nimport static com.squareup.rack.RackEnvironment.RACK_VERSION;\nimport static com.squareup.rack.RackEnvironment.REQUEST_METHOD;\nimport static com.squareup.rack.RackEnvironment.SCRIPT_NAME;\nimport static com.squareup.rack.RackEnvironment.SERVER_NAME;\nimport static com.squareup.rack.RackEnvironment.SERVER_PORT;\nimport static java.util.Collections.list;\n\n/**\n * <p>Transforms an {@link HttpServletRequest} into a {@link RackEnvironment}.</p>\n *\n * <p>Conforms to version 1.2 of the Rack specification</p>.\n *\n * @see <a href=\"http://rack.rubyforge.org/doc/SPEC.html\">The Rack Specification</a>\n * @see <a href=\"https://tools.ietf.org/html/rfc3875#section-4.1.18\">RFC 3875, section 4.1.18</a>\n * @see <a href=\"http://blog.phusion.nl/2013/01/23/the-new-rack-socket-hijacking-api/\">The Rack\n * socket hijacking API</a>\n */\npublic class RackEnvironmentBuilder {\n  // We conform to version 1.2 of the Rack specification.\n  // Note that this number is completely different than the gem version of rack (lowercase):\n  // for example, the rack-1.5.2 gem ships with handlers that conform to version 1.2 of the Rack\n  // specification.\n  private static final List<Integer> VERSION_1_2 = ImmutableList.of(1, 2);\n\n  private static final Logger RACK_ERRORS_LOGGER = LoggerFactory.getLogger(RackErrors.class);\n  private static final Logger RACK_LOGGER_LOGGER = LoggerFactory.getLogger(RackLogger.class);\n\n  private static final Joiner COMMA = Joiner.on(',');\n  private static final CharMatcher DASH = CharMatcher.is('-');\n\n  public RackEnvironment build(HttpServletRequest request) {\n    ImmutableMap.Builder<String, Object> content = ImmutableMap.builder();\n\n    content.put(REQUEST_METHOD, request.getMethod());\n    content.put(SCRIPT_NAME, request.getServletPath());\n    content.put(PATH_INFO, nullToEmpty(request.getPathInfo()));\n    content.put(QUERY_STRING, nullToEmpty(request.getQueryString()));\n    content.put(SERVER_NAME, request.getServerName());\n    content.put(SERVER_PORT, String.valueOf(request.getServerPort()));\n    content.put(RACK_VERSION, VERSION_1_2);\n    content.put(RACK_URL_SCHEME, request.getScheme().toLowerCase());\n    content.put(RACK_INPUT, rackInput(request));\n    content.put(RACK_ERRORS, new RackErrors(RACK_ERRORS_LOGGER));\n    content.put(RACK_LOGGER, new RackLogger(RACK_LOGGER_LOGGER));\n    content.put(RACK_MULTITHREAD, true);\n    content.put(RACK_MULTIPROCESS, true);\n    content.put(RACK_RUN_ONCE, false);\n    content.put(RACK_HIJACK, false);\n\n    // Extra things we add that aren't in the Rack specification:\n    content.put(MINECART_HTTP_SERVLET_REQUEST, request);\n\n    // HTTP headers; Multimap acrobatics ensure we normalize capitalization and\n    // punctuation differences early\n    Enumeration<String> headerNames = request.getHeaderNames();\n\n    ImmutableListMultimap.Builder<String, Object> headers = ImmutableListMultimap.builder();\n\n    while (headerNames.hasMoreElements()) {\n      String name = headerNames.nextElement();\n      headers.putAll(rackHttpHeaderKey(name), list(request.getHeaders(name)));\n    }\n\n    for (Map.Entry<String, Collection<Object>> header : headers.build().asMap().entrySet()) {\n      content.put(header.getKey(), COMMA.join(header.getValue()));\n    }\n\n    // Request attributes\n    // This will include attributes like javax.servlet.request.X509Certificate\n    Enumeration<String> attributeNames = request.getAttributeNames();\n\n    while (attributeNames.hasMoreElements()) {\n      String name = attributeNames.nextElement();\n      content.put(name, request.getAttribute(name));\n    }\n\n    return new RackEnvironment(content.build());\n  }\n\n  private RackInput rackInput(HttpServletRequest request) {\n    try {\n      return new RackInput(new TempfileBufferedInputStream(request.getInputStream()));\n    } catch (IOException e) {\n      throw propagate(e);\n    }\n  }\n\n  private String rackHttpHeaderKey(String headerName) {\n    String transformed = DASH.replaceFrom(headerName.toUpperCase(), \"_\");\n\n    if (transformed.equals(CONTENT_LENGTH) || transformed.equals(CONTENT_TYPE)) {\n      return transformed;\n    } else {\n      return HTTP_HEADER_PREFIX + transformed;\n    }\n  }\n}\n"}
{"test_method": "@Test public void propagateStatus() {\n    rackResponse.status(404);\n    subject.propagate(rackResponse.build(), response);\n    verify(response).setStatus(404);\n  }", "focal_method": "public void propagate(RackResponse rackResponse, HttpServletResponse response) {\n    propagateStatus(rackResponse, response);\n    propagateHeaders(rackResponse, response);\n    propagateBody(rackResponse, response);\n  }", "test_file": "package com.squareup.rack.servlet;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.squareup.rack.RackResponse;\nimport java.io.IOException;\nimport javax.servlet.ServletOutputStream;\nimport javax.servlet.http.HttpServletResponse;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.InOrder;\nimport org.mockito.Mock;\nimport org.mockito.runners.MockitoJUnitRunner;\n\nimport static org.mockito.Matchers.anyString;\nimport static org.mockito.Matchers.eq;\nimport static org.mockito.Mockito.inOrder;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class RackResponsePropagatorTest {\n  private RackResponsePropagator subject;\n  private RackResponseBuilder rackResponse;\n\n  @Mock private HttpServletResponse response;\n  @Mock private ServletOutputStream outputStream;\n\n  @Before public void setUp() throws IOException {\n    subject = new RackResponsePropagator();\n    rackResponse = new RackResponseBuilder();\n    when(response.getOutputStream()).thenReturn(outputStream);\n  }\n\n  @Test public void propagateStatus() {\n    rackResponse.status(404);\n    subject.propagate(rackResponse.build(), response);\n    verify(response).setStatus(404);\n  }\n\n  @Test public void propagateHeaders() {\n    rackResponse.header(\"Content-Type\", \"text/plain\");\n    subject.propagate(rackResponse.build(), response);\n    verify(response).addHeader(\"Content-Type\", \"text/plain\");\n  }\n\n  @Test public void propagateHeadersSkipsHeadsRackHeaders() {\n    rackResponse.header(\"rack.internal\", \"42\");\n    subject.propagate(rackResponse.build(), response);\n    verify(response, never()).addHeader(eq(\"rack.internal\"), anyString());\n  }\n\n  @Test public void propagateHeadersMultipleValues() {\n    rackResponse.header(\"Set-Cookie\", \"foo=bar\\nbar=foo\");\n    subject.propagate(rackResponse.build(), response);\n    verify(response).addHeader(\"Set-Cookie\", \"foo=bar\");\n    verify(response).addHeader(\"Set-Cookie\", \"bar=foo\");\n  }\n\n  @Test public void propagateBody() throws IOException {\n    rackResponse.body(\"Here \".getBytes(), \"are \".getBytes(), \"the \".getBytes(), \"parts.\".getBytes());\n\n    subject.propagate(rackResponse.build(), response);\n\n    InOrder inOrder = inOrder(outputStream);\n    inOrder.verify(outputStream).write(\"Here \".getBytes());\n    inOrder.verify(outputStream).write(\"are \".getBytes());\n    inOrder.verify(outputStream).write(\"the \".getBytes());\n    inOrder.verify(outputStream).write(\"parts.\".getBytes());\n    inOrder.verify(outputStream).flush();\n  }\n\n  private static class RackResponseBuilder {\n    private int status;\n    private final ImmutableMap.Builder<String, String> headers;\n    private final ImmutableList.Builder<byte[]> body;\n\n    public RackResponseBuilder() {\n      this.status = 200;\n      this.headers = ImmutableMap.builder();\n      this.body = ImmutableList.builder();\n    }\n\n    public RackResponseBuilder status(int status) {\n      this.status = status;\n      return this;\n    }\n\n    public RackResponseBuilder header(String key, String value) {\n      this.headers.put(key, value);\n      return this;\n    }\n\n    public RackResponseBuilder body(byte[]... parts) {\n      body.add(parts);\n      return this;\n    }\n\n    public RackResponse build() {\n      return new RackResponse(status, headers.build(), body.build().iterator());\n    }\n  }\n}\n", "focal_file": "/*\n * Copyright (C) 2013 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.squareup.rack.servlet;\n\nimport com.google.common.base.Throwables;\nimport com.squareup.rack.RackResponse;\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.Map;\nimport javax.servlet.ServletOutputStream;\nimport javax.servlet.http.HttpServletResponse;\n\n/**\n * Writes a {@link RackResponse} onto an {@link HttpServletResponse}.\n */\npublic class RackResponsePropagator {\n  private static final String RACK_INTERNAL_HEADER_PREFIX = \"rack.\";\n\n  public void propagate(RackResponse rackResponse, HttpServletResponse response) {\n    propagateStatus(rackResponse, response);\n    propagateHeaders(rackResponse, response);\n    propagateBody(rackResponse, response);\n  }\n\n  private void propagateStatus(RackResponse rackResponse, HttpServletResponse response) {\n    response.setStatus(rackResponse.getStatus());\n  }\n\n  private void propagateHeaders(RackResponse rackResponse, HttpServletResponse response) {\n    for (Map.Entry<String, String> header : rackResponse.getHeaders().entrySet()) {\n      if (shouldPropagateHeaderToClient(header)) {\n        for (String val : header.getValue().split(\"\\n\")) {\n          response.addHeader(header.getKey(), val);\n        }\n      }\n    }\n\n    try {\n      response.flushBuffer();\n    } catch (IOException e) {\n      Throwables.propagate(e);\n    }\n  }\n\n  private boolean shouldPropagateHeaderToClient(Map.Entry<String, String> header) {\n    return !header.getKey().startsWith(RACK_INTERNAL_HEADER_PREFIX);\n  }\n\n  private void propagateBody(RackResponse rackResponse, HttpServletResponse response) {\n    ServletOutputStream outputStream = null;\n\n    try {\n      outputStream = response.getOutputStream();\n    } catch (IOException e) {\n      Throwables.propagate(e);\n    }\n\n    Iterator<byte[]> body = rackResponse.getBody();\n\n    while (body.hasNext()) {\n      try {\n        outputStream.write(body.next());\n      } catch (IOException e) {\n        Throwables.propagate(e);\n      }\n    }\n\n    try {\n      outputStream.flush();\n    } catch (IOException e) {\n      Throwables.propagate(e);\n    }\n  }\n}\n"}
{"test_method": "@Test public void callSetsTheResponseBody() {\n    RackResponse response = app.call(env);\n\n    ImmutableList.Builder<String> strings = ImmutableList.builder();\n\n    Iterator<byte[]> bytes = response.getBody();\n    while (bytes.hasNext()) {\n      strings.add(new String(bytes.next()));\n    }\n\n    assertThat(SPACE.join(strings.build())).isEqualTo(SPACE.join(env.keySet()));\n  }", "focal_method": "@Override public RackResponse call(RackEnvironment environment) {\n    RubyHash environmentHash = convertToRubyHash(environment.entrySet());\n\n    RubyArray response = callRackApplication(environmentHash);\n\n    return convertToJavaRackResponse(response);\n  }", "test_file": "package com.squareup.rack.jruby;\n\nimport com.google.common.base.Joiner;\nimport com.google.common.collect.ImmutableList;\nimport com.squareup.rack.RackApplication;\nimport com.squareup.rack.RackEnvironment;\nimport com.squareup.rack.RackResponse;\nimport com.squareup.rack.servlet.RackEnvironmentBuilder;\nimport com.squareup.rack.servlet.TestHttpServletRequest;\nimport java.util.Iterator;\nimport org.jruby.Ruby;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static org.fest.assertions.api.Assertions.assertThat;\nimport static org.fest.assertions.data.MapEntry.entry;\n\npublic class JRubyRackApplicationTest {\n  private static final Joiner SPACE = Joiner.on(' ');\n\n  private RackApplication app;\n  private RackEnvironment env;\n\n  @Before public void setUp() {\n    IRubyObject callable = Ruby.getGlobalRuntime()\n        .evalScriptlet(\"proc { |env| [200, {'Content-Type' => 'text/plain'}, env.keys] }\");\n\n    RackEnvironmentBuilder envBuilder = new RackEnvironmentBuilder();\n    TestHttpServletRequest request = TestHttpServletRequest.newBuilder().build();\n    app = new JRubyRackApplication(callable);\n    env = envBuilder.build(request);\n  }\n\n  @Test public void callSetsTheResponseStatus() {\n    RackResponse response = app.call(env);\n    assertThat(response.getStatus()).isEqualTo(200);\n  }\n\n  @Test public void callSetsTheResponseHeaders() {\n    RackResponse response = app.call(env);\n    assertThat(response.getHeaders()).contains(entry(\"Content-Type\", \"text/plain\"));\n  }\n\n  @Test public void callSetsTheResponseBody() {\n    RackResponse response = app.call(env);\n\n    ImmutableList.Builder<String> strings = ImmutableList.builder();\n\n    Iterator<byte[]> bytes = response.getBody();\n    while (bytes.hasNext()) {\n      strings.add(new String(bytes.next()));\n    }\n\n    assertThat(SPACE.join(strings.build())).isEqualTo(SPACE.join(env.keySet()));\n  }\n\n  @Test public void callParsesTheResponseStatusFromAString() {\n    IRubyObject callable = Ruby.getGlobalRuntime()\n        .evalScriptlet(\"proc { |env| ['201', {'Content-Type' => 'text/plain'}, env.keys] }\");\n    app = new JRubyRackApplication(callable);\n\n    RackResponse response = app.call(env);\n    assertThat(response.getStatus()).isEqualTo(201);\n  }\n}\n", "focal_file": "/*\n * Copyright (C) 2013 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.squareup.rack.jruby;\n\nimport com.squareup.rack.RackApplication;\nimport com.squareup.rack.RackEnvironment;\nimport com.squareup.rack.RackInput;\nimport com.squareup.rack.RackResponse;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport org.jruby.Ruby;\nimport org.jruby.RubyArray;\nimport org.jruby.RubyHash;\nimport org.jruby.internal.runtime.ThreadService;\nimport org.jruby.runtime.builtin.IRubyObject;\n\nimport static org.jruby.RubyHash.newHash;\n\n/**\n * Adapts a (RubyObject) Rack application into Java-space.\n */\npublic class JRubyRackApplication implements RackApplication {\n  private final IRubyObject application;\n  private final Ruby runtime;\n  private final ThreadService threadService;\n\n  /**\n   * <p>Creates a {@link RackApplication} that delegates to the given Ruby Rack application.</p>\n   *\n   * <p>To obtain the necessary {@link IRubyObject}, you can create a JRuby\n   * {@link org.jruby.embed.ScriptingContainer} and {@link org.jruby.embed.ScriptingContainer#parse}\n   * and {@link org.jruby.embed.EmbedEvalUnit#run()} your Ruby code. See our examples for concrete\n   * code.</p>\n   *\n   * @param application the Ruby Rack application.\n   */\n  public JRubyRackApplication(IRubyObject application) {\n    this.application = application;\n    this.runtime = application.getRuntime();\n    this.threadService = runtime.getThreadService();\n  }\n\n  /**\n   * Calls the delegate Rack application, translating into and back out of the JRuby interpreter.\n   *\n   * @param environment the Rack environment\n   * @return the Rack response\n   */\n  @Override public RackResponse call(RackEnvironment environment) {\n    RubyHash environmentHash = convertToRubyHash(environment.entrySet());\n\n    RubyArray response = callRackApplication(environmentHash);\n\n    return convertToJavaRackResponse(response);\n  }\n\n  private RubyHash convertToRubyHash(Set<Map.Entry<String, Object>> entries) {\n    RubyHash hash = newHash(runtime);\n\n    for (Map.Entry<String, Object> entry : entries) {\n      String key = entry.getKey();\n      Object value = entry.getValue();\n\n      if (key.equals(\"rack.input\")) {\n        value = new JRubyRackInput(runtime, (RackInput) value);\n      }\n\n      if (key.equals(\"rack.version\")) {\n        value = convertToRubyArray((List<Integer>) value);\n      }\n\n      hash.put(key, value);\n    }\n\n    return hash;\n  }\n\n  private RubyArray convertToRubyArray(List<Integer> list) {\n    RubyArray array = RubyArray.newEmptyArray(runtime);\n    array.addAll(list);\n    return array;\n  }\n\n  private RubyArray callRackApplication(RubyHash rubyHash) {\n    return (RubyArray) application.callMethod(threadService.getCurrentContext(), \"call\", rubyHash);\n  }\n\n  private RackResponse convertToJavaRackResponse(RubyArray response) {\n    int status = Integer.parseInt(response.get(0).toString(), 10);\n    Map headers = (Map) response.get(1);\n    IRubyObject body = (IRubyObject) response.get(2);\n\n    return new RackResponse(status, headers, new JRubyRackBodyIterator(body));\n  }\n}\n"}
{"test_method": "@Test public void readWithLengthZero() throws Exception {\n    assertThat(full.read(0)).isEqualTo(EMPTY_BYTES);\n  }", "focal_method": "public byte[] read(Integer length) throws IOException {\n    if (length == null) {\n      return readToEof();\n    } else {\n      return readTo(length);\n    }\n  }", "test_file": "package com.squareup.rack;\n\nimport java.io.ByteArrayInputStream;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static java.util.Arrays.copyOfRange;\nimport static org.fest.assertions.api.Assertions.assertThat;\n\npublic class RackInputTest {\n  public static final byte[] EMPTY_BYTES = \"\".getBytes();\n  public static final byte[] BYTES = \"Hello,\\nWorld!\".getBytes();\n\n  private RackInput empty;\n  private RackInput full;\n  private RackInput fullSlow;\n\n  @Before public void setUp() throws Exception {\n    empty = rackInputFor(EMPTY_BYTES);\n    full = rackInputFor(BYTES);\n    fullSlow = slowRackInputFor(BYTES);\n  }\n\n  @Test public void getsAtEof() throws Exception {\n    assertThat(empty.gets()).isNull();\n  }\n\n  @Test public void gets() throws Exception {\n    assertThat(full.gets()).isEqualTo(\"Hello,\\n\".getBytes());\n  }\n\n  @Test public void getsWithCrLf() throws Exception {\n    assertThat(rackInputFor(\"Hello,\\r\\nWorld!\").gets()).isEqualTo(\"Hello,\\r\\n\".getBytes());\n  }\n\n  @Test public void getsAgain() throws Exception {\n    full.gets();\n    assertThat(full.gets()).isEqualTo(\"World!\".getBytes());\n  }\n\n  @Test public void readWithLengthNilAtEof() throws Exception {\n    assertThat(empty.read(null)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthZeroAtEof() throws Exception {\n    assertThat(empty.read(0)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthAtEof() throws Exception {\n    assertThat(empty.read(1)).isNull();\n  }\n\n  @Test public void readWithLengthNil() throws Exception {\n    assertThat(full.read(null)).isEqualTo(BYTES);\n  }\n\n  @Test public void readWithLengthNilAgain() throws Exception {\n    full.read(null);\n    assertThat(full.read(null)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthZero() throws Exception {\n    assertThat(full.read(0)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLength() throws Exception {\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void readWithLengthAgain() throws Exception {\n    full.read(4);\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 4, 8));\n  }\n\n  @Test public void readFromSlowStreamWithLength() throws Exception {\n    assertThat(fullSlow.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void readFromSlowStreamWithLengthAgain() throws Exception {\n    fullSlow.read(4);\n    assertThat(fullSlow.read(4)).isEqualTo(copyOfRange(BYTES, 4, 8));\n  }\n\n  @Test public void readWithLengthTooLong() throws Exception {\n    assertThat(full.read(BYTES.length + 1)).isEqualTo(BYTES);\n  }\n\n  @Test public void readWithLengthTooLongAgain() throws Exception {\n    full.read(BYTES.length + 1);\n    assertThat(full.read(BYTES.length + 1)).isNull();\n  }\n\n  @Test public void rewind() throws Exception {\n    full.read(4);\n    full.rewind();\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void rewind_shouldDiscardAnyBufferedBytes() throws Exception {\n    RackInput subject = rackInputFor(\"first line\\r\\n123\\r\\n456\\r\\n\");\n    subject.gets();\n    subject.rewind();\n    assertThat(subject.gets()).isEqualTo(\"first line\\r\\n\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"123\\r\\n\".getBytes());\n  }\n\n  @Test public void intermixingReadMethodsIsSafe() throws Exception {\n    RackInput subject = rackInputFor(\"first line\\r\\n123\\r\\n456\\r\\n\");\n    assertThat(subject.read(1)).isEqualTo(\"f\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"irst line\\r\\n\".getBytes());\n    assertThat(subject.read(null)).isEqualTo(\"123\\r\\n456\\r\\n\".getBytes());\n    subject.rewind();\n    assertThat(subject.gets()).isEqualTo(\"first line\\r\\n\".getBytes());\n    assertThat(subject.read(3)).isEqualTo(\"123\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"\\r\\n\".getBytes());\n    assertThat(subject.read(null)).isEqualTo(\"456\\r\\n\".getBytes());\n  }\n\n  private RackInput rackInputFor(String string) throws Exception {\n    return rackInputFor(string.getBytes());\n  }\n\n  private RackInput rackInputFor(byte[] bytes) throws Exception {\n    return new RackInput(new ByteArrayInputStream(bytes));\n  }\n\n  private RackInput slowRackInputFor(byte[] bytes) throws Exception {\n    return new RackInput(new SlowByteArrayInputStream(bytes));\n  }\n}\n", "focal_file": "/*\n * Copyright (C) 2013 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.squareup.rack;\n\nimport com.google.common.io.ByteStreams;\nimport com.squareup.rack.io.ByteArrayBuffer;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\n/**\n * <p>Adapts an {@link InputStream} to the required interface for {@code rack.input}.</p>\n *\n * <p>Speaks {@code byte[]}, not {@code String}, because {@code rack.input} is required to have\n * binary encoding.</p>\n */\npublic class RackInput implements Closeable {\n  private static final int LINEFEED = 0xA;\n  private static final int MAX_LINE_LENGTH = 1024 * 1024;\n  private static final int READ_AHEAD_SUGGESTION = 1024 * 1024;\n\n  private final InputStream stream;\n  private final ByteArrayBuffer buffer = new ByteArrayBuffer();\n  private int bufferReadHead;\n\n  /**\n   * Creates a {@link RackInput} stream that draws from the given {@link InputStream}.\n   *\n   * @param inputStream the source stream.\n   */\n  public RackInput(InputStream inputStream) {\n    checkNotNull(inputStream);\n    checkArgument(inputStream.markSupported(),\n        \"rack.input must be rewindable, but inputStream doesn't support mark.\");\n\n    stream = inputStream;\n    stream.mark(READ_AHEAD_SUGGESTION);\n  }\n\n  /**\n   * Reads the next line from the stream.\n   *\n   * @return the next line, or null at EOF.\n   * @throws IOException\n   */\n  public byte[] gets() throws IOException {\n    return readToLinefeed();\n  }\n\n  /**\n   * Reads length bytes from the stream. Reads all the way to EOF when length is null.\n   *\n   * @param length the desired number of bytes, or null.\n   * @return the bytes, or null at EOF when length is present.\n   * @throws IOException\n   */\n  public byte[] read(Integer length) throws IOException {\n    if (length == null) {\n      return readToEof();\n    } else {\n      return readTo(length);\n    }\n  }\n\n  /**\n   * Resets the stream, so that it may be read again from the beginning.\n   *\n   * @throws IOException\n   */\n  public void rewind() throws IOException {\n    stream.reset();\n    buffer.reset();\n    bufferReadHead = 0;\n  }\n\n  /**\n   * Closes the stream.\n   *\n   * @throws IOException\n   */\n  @Override public void close() throws IOException {\n    stream.close();\n  }\n\n  private byte[] readToLinefeed() throws IOException {\n    int startFrom = 0;\n    do {\n      int indexOfNewline = indexOfNextNewlineInBuffer(startFrom);\n\n      if (indexOfNewline == -1) {\n        int bytesPresent = bytesAvailableInBuffer();\n\n        if (bytesPresent > MAX_LINE_LENGTH) {\n          throw new RuntimeException(\n              \"Really, you have a line longer than \" + MAX_LINE_LENGTH + \" bytes?\");\n        }\n\n        // next time through, start where we left off.\n        startFrom = bytesPresent;\n\n        int bytesRead = fillBuffer(8 * 1024);\n        if (bytesRead == -1) {\n          int bytesRemaining = bytesAvailableInBuffer();\n          return consumeBytesFromBuffer(bytesRemaining);\n        }\n      } else {\n        int length = indexOfNewline - bufferReadHead + 1;\n        return consumeBytesFromBuffer(length);\n      }\n    } while (true);\n  }\n\n  private byte[] readToEof() throws IOException {\n    if (bufferReadHead > 0) {\n      compactBuffer(true);\n    }\n\n    ByteStreams.copy(stream, buffer);\n\n    int length = buffer.getLength();\n    if (length == 0) {\n      return new byte[0];\n    } else {\n      return consumeBytesFromBuffer(length);\n    }\n  }\n\n  private byte[] readTo(int length) throws IOException {\n    if (length == 0) {\n      return new byte[0];\n    }\n\n    if (bufferReadHead > 0) {\n      compactBuffer(true);\n    }\n\n    int bytesStillNeeded = length - buffer.getLength();\n    if (bytesStillNeeded > 0) {\n      int bytesRead = fillBuffer(bytesStillNeeded);\n      while (bytesRead != -1 && bytesStillNeeded > 0) {\n        bytesStillNeeded -= bytesRead;\n        bytesRead = fillBuffer(bytesStillNeeded);\n      }\n    }\n\n    return consumeBytesFromBuffer(length);\n  }\n\n  private int bytesAvailableInBuffer() {\n    return buffer.getLength() - bufferReadHead;\n  }\n\n  private int indexOfNextNewlineInBuffer(int startFrom) {\n    byte[] bytes = buffer.getBuffer();\n    int bufferLength = buffer.getLength();\n    for (int i = bufferReadHead + startFrom; i < bufferLength; i++) {\n      if (bytes[i] == LINEFEED) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  private int fillBuffer(int length) throws IOException {\n    compactBuffer(false);\n    byte[] readBuf = new byte[length];\n    int bytesRead = stream.read(readBuf);\n    if (bytesRead > 0) {\n      buffer.write(readBuf, 0, bytesRead);\n    }\n    return bytesRead;\n  }\n\n  private byte[] consumeBytesFromBuffer(int length) {\n    int bytesAvailable = bytesAvailableInBuffer();\n    if (length > bytesAvailable) {\n      length = bytesAvailable;\n    }\n\n    if (length == 0) {\n      return null;\n    }\n\n    byte[] bytes = new byte[length];\n    byte[] bufferBytes = buffer.getBuffer();\n    System.arraycopy(bufferBytes, bufferReadHead, bytes, 0, length);\n    bufferReadHead += length;\n    return bytes;\n  }\n\n  private void compactBuffer(boolean force) {\n    byte[] bufferBytes = buffer.getBuffer();\n\n    // normally, only compact if we're at least 1K in, and at least 3/4 of the way in\n    if (force || (bufferReadHead > 1024 && bufferReadHead > (bufferBytes.length * 3 / 4))) {\n      int remainingBytes = bytesAvailableInBuffer();\n      System.arraycopy(bufferBytes, bufferReadHead, bufferBytes, 0, remainingBytes);\n      buffer.setLength(remainingBytes);\n      bufferReadHead = 0;\n    }\n  }\n}\n"}
{"test_method": "@Test public void readWithLengthNilAtEof() throws Exception {\n    assertThat(empty.read(null)).isEqualTo(EMPTY_BYTES);\n  }", "focal_method": "public byte[] read(Integer length) throws IOException {\n    if (length == null) {\n      return readToEof();\n    } else {\n      return readTo(length);\n    }\n  }", "test_file": "package com.squareup.rack;\n\nimport java.io.ByteArrayInputStream;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static java.util.Arrays.copyOfRange;\nimport static org.fest.assertions.api.Assertions.assertThat;\n\npublic class RackInputTest {\n  public static final byte[] EMPTY_BYTES = \"\".getBytes();\n  public static final byte[] BYTES = \"Hello,\\nWorld!\".getBytes();\n\n  private RackInput empty;\n  private RackInput full;\n  private RackInput fullSlow;\n\n  @Before public void setUp() throws Exception {\n    empty = rackInputFor(EMPTY_BYTES);\n    full = rackInputFor(BYTES);\n    fullSlow = slowRackInputFor(BYTES);\n  }\n\n  @Test public void getsAtEof() throws Exception {\n    assertThat(empty.gets()).isNull();\n  }\n\n  @Test public void gets() throws Exception {\n    assertThat(full.gets()).isEqualTo(\"Hello,\\n\".getBytes());\n  }\n\n  @Test public void getsWithCrLf() throws Exception {\n    assertThat(rackInputFor(\"Hello,\\r\\nWorld!\").gets()).isEqualTo(\"Hello,\\r\\n\".getBytes());\n  }\n\n  @Test public void getsAgain() throws Exception {\n    full.gets();\n    assertThat(full.gets()).isEqualTo(\"World!\".getBytes());\n  }\n\n  @Test public void readWithLengthNilAtEof() throws Exception {\n    assertThat(empty.read(null)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthZeroAtEof() throws Exception {\n    assertThat(empty.read(0)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthAtEof() throws Exception {\n    assertThat(empty.read(1)).isNull();\n  }\n\n  @Test public void readWithLengthNil() throws Exception {\n    assertThat(full.read(null)).isEqualTo(BYTES);\n  }\n\n  @Test public void readWithLengthNilAgain() throws Exception {\n    full.read(null);\n    assertThat(full.read(null)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLengthZero() throws Exception {\n    assertThat(full.read(0)).isEqualTo(EMPTY_BYTES);\n  }\n\n  @Test public void readWithLength() throws Exception {\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void readWithLengthAgain() throws Exception {\n    full.read(4);\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 4, 8));\n  }\n\n  @Test public void readFromSlowStreamWithLength() throws Exception {\n    assertThat(fullSlow.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void readFromSlowStreamWithLengthAgain() throws Exception {\n    fullSlow.read(4);\n    assertThat(fullSlow.read(4)).isEqualTo(copyOfRange(BYTES, 4, 8));\n  }\n\n  @Test public void readWithLengthTooLong() throws Exception {\n    assertThat(full.read(BYTES.length + 1)).isEqualTo(BYTES);\n  }\n\n  @Test public void readWithLengthTooLongAgain() throws Exception {\n    full.read(BYTES.length + 1);\n    assertThat(full.read(BYTES.length + 1)).isNull();\n  }\n\n  @Test public void rewind() throws Exception {\n    full.read(4);\n    full.rewind();\n    assertThat(full.read(4)).isEqualTo(copyOfRange(BYTES, 0, 4));\n  }\n\n  @Test public void rewind_shouldDiscardAnyBufferedBytes() throws Exception {\n    RackInput subject = rackInputFor(\"first line\\r\\n123\\r\\n456\\r\\n\");\n    subject.gets();\n    subject.rewind();\n    assertThat(subject.gets()).isEqualTo(\"first line\\r\\n\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"123\\r\\n\".getBytes());\n  }\n\n  @Test public void intermixingReadMethodsIsSafe() throws Exception {\n    RackInput subject = rackInputFor(\"first line\\r\\n123\\r\\n456\\r\\n\");\n    assertThat(subject.read(1)).isEqualTo(\"f\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"irst line\\r\\n\".getBytes());\n    assertThat(subject.read(null)).isEqualTo(\"123\\r\\n456\\r\\n\".getBytes());\n    subject.rewind();\n    assertThat(subject.gets()).isEqualTo(\"first line\\r\\n\".getBytes());\n    assertThat(subject.read(3)).isEqualTo(\"123\".getBytes());\n    assertThat(subject.gets()).isEqualTo(\"\\r\\n\".getBytes());\n    assertThat(subject.read(null)).isEqualTo(\"456\\r\\n\".getBytes());\n  }\n\n  private RackInput rackInputFor(String string) throws Exception {\n    return rackInputFor(string.getBytes());\n  }\n\n  private RackInput rackInputFor(byte[] bytes) throws Exception {\n    return new RackInput(new ByteArrayInputStream(bytes));\n  }\n\n  private RackInput slowRackInputFor(byte[] bytes) throws Exception {\n    return new RackInput(new SlowByteArrayInputStream(bytes));\n  }\n}\n", "focal_file": "/*\n * Copyright (C) 2013 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.squareup.rack;\n\nimport com.google.common.io.ByteStreams;\nimport com.squareup.rack.io.ByteArrayBuffer;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\n/**\n * <p>Adapts an {@link InputStream} to the required interface for {@code rack.input}.</p>\n *\n * <p>Speaks {@code byte[]}, not {@code String}, because {@code rack.input} is required to have\n * binary encoding.</p>\n */\npublic class RackInput implements Closeable {\n  private static final int LINEFEED = 0xA;\n  private static final int MAX_LINE_LENGTH = 1024 * 1024;\n  private static final int READ_AHEAD_SUGGESTION = 1024 * 1024;\n\n  private final InputStream stream;\n  private final ByteArrayBuffer buffer = new ByteArrayBuffer();\n  private int bufferReadHead;\n\n  /**\n   * Creates a {@link RackInput} stream that draws from the given {@link InputStream}.\n   *\n   * @param inputStream the source stream.\n   */\n  public RackInput(InputStream inputStream) {\n    checkNotNull(inputStream);\n    checkArgument(inputStream.markSupported(),\n        \"rack.input must be rewindable, but inputStream doesn't support mark.\");\n\n    stream = inputStream;\n    stream.mark(READ_AHEAD_SUGGESTION);\n  }\n\n  /**\n   * Reads the next line from the stream.\n   *\n   * @return the next line, or null at EOF.\n   * @throws IOException\n   */\n  public byte[] gets() throws IOException {\n    return readToLinefeed();\n  }\n\n  /**\n   * Reads length bytes from the stream. Reads all the way to EOF when length is null.\n   *\n   * @param length the desired number of bytes, or null.\n   * @return the bytes, or null at EOF when length is present.\n   * @throws IOException\n   */\n  public byte[] read(Integer length) throws IOException {\n    if (length == null) {\n      return readToEof();\n    } else {\n      return readTo(length);\n    }\n  }\n\n  /**\n   * Resets the stream, so that it may be read again from the beginning.\n   *\n   * @throws IOException\n   */\n  public void rewind() throws IOException {\n    stream.reset();\n    buffer.reset();\n    bufferReadHead = 0;\n  }\n\n  /**\n   * Closes the stream.\n   *\n   * @throws IOException\n   */\n  @Override public void close() throws IOException {\n    stream.close();\n  }\n\n  private byte[] readToLinefeed() throws IOException {\n    int startFrom = 0;\n    do {\n      int indexOfNewline = indexOfNextNewlineInBuffer(startFrom);\n\n      if (indexOfNewline == -1) {\n        int bytesPresent = bytesAvailableInBuffer();\n\n        if (bytesPresent > MAX_LINE_LENGTH) {\n          throw new RuntimeException(\n              \"Really, you have a line longer than \" + MAX_LINE_LENGTH + \" bytes?\");\n        }\n\n        // next time through, start where we left off.\n        startFrom = bytesPresent;\n\n        int bytesRead = fillBuffer(8 * 1024);\n        if (bytesRead == -1) {\n          int bytesRemaining = bytesAvailableInBuffer();\n          return consumeBytesFromBuffer(bytesRemaining);\n        }\n      } else {\n        int length = indexOfNewline - bufferReadHead + 1;\n        return consumeBytesFromBuffer(length);\n      }\n    } while (true);\n  }\n\n  private byte[] readToEof() throws IOException {\n    if (bufferReadHead > 0) {\n      compactBuffer(true);\n    }\n\n    ByteStreams.copy(stream, buffer);\n\n    int length = buffer.getLength();\n    if (length == 0) {\n      return new byte[0];\n    } else {\n      return consumeBytesFromBuffer(length);\n    }\n  }\n\n  private byte[] readTo(int length) throws IOException {\n    if (length == 0) {\n      return new byte[0];\n    }\n\n    if (bufferReadHead > 0) {\n      compactBuffer(true);\n    }\n\n    int bytesStillNeeded = length - buffer.getLength();\n    if (bytesStillNeeded > 0) {\n      int bytesRead = fillBuffer(bytesStillNeeded);\n      while (bytesRead != -1 && bytesStillNeeded > 0) {\n        bytesStillNeeded -= bytesRead;\n        bytesRead = fillBuffer(bytesStillNeeded);\n      }\n    }\n\n    return consumeBytesFromBuffer(length);\n  }\n\n  private int bytesAvailableInBuffer() {\n    return buffer.getLength() - bufferReadHead;\n  }\n\n  private int indexOfNextNewlineInBuffer(int startFrom) {\n    byte[] bytes = buffer.getBuffer();\n    int bufferLength = buffer.getLength();\n    for (int i = bufferReadHead + startFrom; i < bufferLength; i++) {\n      if (bytes[i] == LINEFEED) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  private int fillBuffer(int length) throws IOException {\n    compactBuffer(false);\n    byte[] readBuf = new byte[length];\n    int bytesRead = stream.read(readBuf);\n    if (bytesRead > 0) {\n      buffer.write(readBuf, 0, bytesRead);\n    }\n    return bytesRead;\n  }\n\n  private byte[] consumeBytesFromBuffer(int length) {\n    int bytesAvailable = bytesAvailableInBuffer();\n    if (length > bytesAvailable) {\n      length = bytesAvailable;\n    }\n\n    if (length == 0) {\n      return null;\n    }\n\n    byte[] bytes = new byte[length];\n    byte[] bufferBytes = buffer.getBuffer();\n    System.arraycopy(bufferBytes, bufferReadHead, bytes, 0, length);\n    bufferReadHead += length;\n    return bytes;\n  }\n\n  private void compactBuffer(boolean force) {\n    byte[] bufferBytes = buffer.getBuffer();\n\n    // normally, only compact if we're at least 1K in, and at least 3/4 of the way in\n    if (force || (bufferReadHead > 1024 && bufferReadHead > (bufferBytes.length * 3 / 4))) {\n      int remainingBytes = bytesAvailableInBuffer();\n      System.arraycopy(bufferBytes, bufferReadHead, bufferBytes, 0, remainingBytes);\n      buffer.setLength(remainingBytes);\n      bufferReadHead = 0;\n    }\n  }\n}\n"}
{"test_method": "@Test public void propagateBody() throws IOException {\n    rackResponse.body(\"Here \".getBytes(), \"are \".getBytes(), \"the \".getBytes(), \"parts.\".getBytes());\n\n    subject.propagate(rackResponse.build(), response);\n\n    InOrder inOrder = inOrder(outputStream);\n    inOrder.verify(outputStream).write(\"Here \".getBytes());\n    inOrder.verify(outputStream).write(\"are \".getBytes());\n    inOrder.verify(outputStream).write(\"the \".getBytes());\n    inOrder.verify(outputStream).write(\"parts.\".getBytes());\n    inOrder.verify(outputStream).flush();\n  }", "focal_method": "private void propagateBody(RackResponse rackResponse, HttpServletResponse response) {\n    ServletOutputStream outputStream = null;\n\n    try {\n      outputStream = response.getOutputStream();\n    } catch (IOException e) {\n      Throwables.propagate(e);\n    }\n\n    Iterator<byte[]> body = rackResponse.getBody();\n\n    while (body.hasNext()) {\n      try {\n        outputStream.write(body.next());\n      } catch (IOException e) {\n        Throwables.propagate(e);\n      }\n    }\n\n    try {\n      outputStream.flush();\n    } catch (IOException e) {\n      Throwables.propagate(e);\n    }\n  }", "test_file": "package com.squareup.rack.servlet;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.squareup.rack.RackResponse;\nimport java.io.IOException;\nimport javax.servlet.ServletOutputStream;\nimport javax.servlet.http.HttpServletResponse;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.InOrder;\nimport org.mockito.Mock;\nimport org.mockito.runners.MockitoJUnitRunner;\n\nimport static org.mockito.Matchers.anyString;\nimport static org.mockito.Matchers.eq;\nimport static org.mockito.Mockito.inOrder;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class RackResponsePropagatorTest {\n  private RackResponsePropagator subject;\n  private RackResponseBuilder rackResponse;\n\n  @Mock private HttpServletResponse response;\n  @Mock private ServletOutputStream outputStream;\n\n  @Before public void setUp() throws IOException {\n    subject = new RackResponsePropagator();\n    rackResponse = new RackResponseBuilder();\n    when(response.getOutputStream()).thenReturn(outputStream);\n  }\n\n  @Test public void propagateStatus() {\n    rackResponse.status(404);\n    subject.propagate(rackResponse.build(), response);\n    verify(response).setStatus(404);\n  }\n\n  @Test public void propagateHeaders() {\n    rackResponse.header(\"Content-Type\", \"text/plain\");\n    subject.propagate(rackResponse.build(), response);\n    verify(response).addHeader(\"Content-Type\", \"text/plain\");\n  }\n\n  @Test public void propagateHeadersSkipsHeadsRackHeaders() {\n    rackResponse.header(\"rack.internal\", \"42\");\n    subject.propagate(rackResponse.build(), response);\n    verify(response, never()).addHeader(eq(\"rack.internal\"), anyString());\n  }\n\n  @Test public void propagateHeadersMultipleValues() {\n    rackResponse.header(\"Set-Cookie\", \"foo=bar\\nbar=foo\");\n    subject.propagate(rackResponse.build(), response);\n    verify(response).addHeader(\"Set-Cookie\", \"foo=bar\");\n    verify(response).addHeader(\"Set-Cookie\", \"bar=foo\");\n  }\n\n  @Test public void propagateBody() throws IOException {\n    rackResponse.body(\"Here \".getBytes(), \"are \".getBytes(), \"the \".getBytes(), \"parts.\".getBytes());\n\n    subject.propagate(rackResponse.build(), response);\n\n    InOrder inOrder = inOrder(outputStream);\n    inOrder.verify(outputStream).write(\"Here \".getBytes());\n    inOrder.verify(outputStream).write(\"are \".getBytes());\n    inOrder.verify(outputStream).write(\"the \".getBytes());\n    inOrder.verify(outputStream).write(\"parts.\".getBytes());\n    inOrder.verify(outputStream).flush();\n  }\n\n  private static class RackResponseBuilder {\n    private int status;\n    private final ImmutableMap.Builder<String, String> headers;\n    private final ImmutableList.Builder<byte[]> body;\n\n    public RackResponseBuilder() {\n      this.status = 200;\n      this.headers = ImmutableMap.builder();\n      this.body = ImmutableList.builder();\n    }\n\n    public RackResponseBuilder status(int status) {\n      this.status = status;\n      return this;\n    }\n\n    public RackResponseBuilder header(String key, String value) {\n      this.headers.put(key, value);\n      return this;\n    }\n\n    public RackResponseBuilder body(byte[]... parts) {\n      body.add(parts);\n      return this;\n    }\n\n    public RackResponse build() {\n      return new RackResponse(status, headers.build(), body.build().iterator());\n    }\n  }\n}\n", "focal_file": "/*\n * Copyright (C) 2013 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.squareup.rack.servlet;\n\nimport com.google.common.base.Throwables;\nimport com.squareup.rack.RackResponse;\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.Map;\nimport javax.servlet.ServletOutputStream;\nimport javax.servlet.http.HttpServletResponse;\n\n/**\n * Writes a {@link RackResponse} onto an {@link HttpServletResponse}.\n */\npublic class RackResponsePropagator {\n  private static final String RACK_INTERNAL_HEADER_PREFIX = \"rack.\";\n\n  public void propagate(RackResponse rackResponse, HttpServletResponse response) {\n    propagateStatus(rackResponse, response);\n    propagateHeaders(rackResponse, response);\n    propagateBody(rackResponse, response);\n  }\n\n  private void propagateStatus(RackResponse rackResponse, HttpServletResponse response) {\n    response.setStatus(rackResponse.getStatus());\n  }\n\n  private void propagateHeaders(RackResponse rackResponse, HttpServletResponse response) {\n    for (Map.Entry<String, String> header : rackResponse.getHeaders().entrySet()) {\n      if (shouldPropagateHeaderToClient(header)) {\n        for (String val : header.getValue().split(\"\\n\")) {\n          response.addHeader(header.getKey(), val);\n        }\n      }\n    }\n\n    try {\n      response.flushBuffer();\n    } catch (IOException e) {\n      Throwables.propagate(e);\n    }\n  }\n\n  private boolean shouldPropagateHeaderToClient(Map.Entry<String, String> header) {\n    return !header.getKey().startsWith(RACK_INTERNAL_HEADER_PREFIX);\n  }\n\n  private void propagateBody(RackResponse rackResponse, HttpServletResponse response) {\n    ServletOutputStream outputStream = null;\n\n    try {\n      outputStream = response.getOutputStream();\n    } catch (IOException e) {\n      Throwables.propagate(e);\n    }\n\n    Iterator<byte[]> body = rackResponse.getBody();\n\n    while (body.hasNext()) {\n      try {\n        outputStream.write(body.next());\n      } catch (IOException e) {\n        Throwables.propagate(e);\n      }\n    }\n\n    try {\n      outputStream.flush();\n    } catch (IOException e) {\n      Throwables.propagate(e);\n    }\n  }\n}\n"}
{"test_method": "@Test public void propagateHeadersSkipsHeadsRackHeaders() {\n    rackResponse.header(\"rack.internal\", \"42\");\n    subject.propagate(rackResponse.build(), response);\n    verify(response, never()).addHeader(eq(\"rack.internal\"), anyString());\n  }", "focal_method": "public void propagate(RackResponse rackResponse, HttpServletResponse response) {\n    propagateStatus(rackResponse, response);\n    propagateHeaders(rackResponse, response);\n    propagateBody(rackResponse, response);\n  }", "test_file": "package com.squareup.rack.servlet;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.squareup.rack.RackResponse;\nimport java.io.IOException;\nimport javax.servlet.ServletOutputStream;\nimport javax.servlet.http.HttpServletResponse;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.InOrder;\nimport org.mockito.Mock;\nimport org.mockito.runners.MockitoJUnitRunner;\n\nimport static org.mockito.Matchers.anyString;\nimport static org.mockito.Matchers.eq;\nimport static org.mockito.Mockito.inOrder;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class RackResponsePropagatorTest {\n  private RackResponsePropagator subject;\n  private RackResponseBuilder rackResponse;\n\n  @Mock private HttpServletResponse response;\n  @Mock private ServletOutputStream outputStream;\n\n  @Before public void setUp() throws IOException {\n    subject = new RackResponsePropagator();\n    rackResponse = new RackResponseBuilder();\n    when(response.getOutputStream()).thenReturn(outputStream);\n  }\n\n  @Test public void propagateStatus() {\n    rackResponse.status(404);\n    subject.propagate(rackResponse.build(), response);\n    verify(response).setStatus(404);\n  }\n\n  @Test public void propagateHeaders() {\n    rackResponse.header(\"Content-Type\", \"text/plain\");\n    subject.propagate(rackResponse.build(), response);\n    verify(response).addHeader(\"Content-Type\", \"text/plain\");\n  }\n\n  @Test public void propagateHeadersSkipsHeadsRackHeaders() {\n    rackResponse.header(\"rack.internal\", \"42\");\n    subject.propagate(rackResponse.build(), response);\n    verify(response, never()).addHeader(eq(\"rack.internal\"), anyString());\n  }\n\n  @Test public void propagateHeadersMultipleValues() {\n    rackResponse.header(\"Set-Cookie\", \"foo=bar\\nbar=foo\");\n    subject.propagate(rackResponse.build(), response);\n    verify(response).addHeader(\"Set-Cookie\", \"foo=bar\");\n    verify(response).addHeader(\"Set-Cookie\", \"bar=foo\");\n  }\n\n  @Test public void propagateBody() throws IOException {\n    rackResponse.body(\"Here \".getBytes(), \"are \".getBytes(), \"the \".getBytes(), \"parts.\".getBytes());\n\n    subject.propagate(rackResponse.build(), response);\n\n    InOrder inOrder = inOrder(outputStream);\n    inOrder.verify(outputStream).write(\"Here \".getBytes());\n    inOrder.verify(outputStream).write(\"are \".getBytes());\n    inOrder.verify(outputStream).write(\"the \".getBytes());\n    inOrder.verify(outputStream).write(\"parts.\".getBytes());\n    inOrder.verify(outputStream).flush();\n  }\n\n  private static class RackResponseBuilder {\n    private int status;\n    private final ImmutableMap.Builder<String, String> headers;\n    private final ImmutableList.Builder<byte[]> body;\n\n    public RackResponseBuilder() {\n      this.status = 200;\n      this.headers = ImmutableMap.builder();\n      this.body = ImmutableList.builder();\n    }\n\n    public RackResponseBuilder status(int status) {\n      this.status = status;\n      return this;\n    }\n\n    public RackResponseBuilder header(String key, String value) {\n      this.headers.put(key, value);\n      return this;\n    }\n\n    public RackResponseBuilder body(byte[]... parts) {\n      body.add(parts);\n      return this;\n    }\n\n    public RackResponse build() {\n      return new RackResponse(status, headers.build(), body.build().iterator());\n    }\n  }\n}\n", "focal_file": "/*\n * Copyright (C) 2013 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.squareup.rack.servlet;\n\nimport com.google.common.base.Throwables;\nimport com.squareup.rack.RackResponse;\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.Map;\nimport javax.servlet.ServletOutputStream;\nimport javax.servlet.http.HttpServletResponse;\n\n/**\n * Writes a {@link RackResponse} onto an {@link HttpServletResponse}.\n */\npublic class RackResponsePropagator {\n  private static final String RACK_INTERNAL_HEADER_PREFIX = \"rack.\";\n\n  public void propagate(RackResponse rackResponse, HttpServletResponse response) {\n    propagateStatus(rackResponse, response);\n    propagateHeaders(rackResponse, response);\n    propagateBody(rackResponse, response);\n  }\n\n  private void propagateStatus(RackResponse rackResponse, HttpServletResponse response) {\n    response.setStatus(rackResponse.getStatus());\n  }\n\n  private void propagateHeaders(RackResponse rackResponse, HttpServletResponse response) {\n    for (Map.Entry<String, String> header : rackResponse.getHeaders().entrySet()) {\n      if (shouldPropagateHeaderToClient(header)) {\n        for (String val : header.getValue().split(\"\\n\")) {\n          response.addHeader(header.getKey(), val);\n        }\n      }\n    }\n\n    try {\n      response.flushBuffer();\n    } catch (IOException e) {\n      Throwables.propagate(e);\n    }\n  }\n\n  private boolean shouldPropagateHeaderToClient(Map.Entry<String, String> header) {\n    return !header.getKey().startsWith(RACK_INTERNAL_HEADER_PREFIX);\n  }\n\n  private void propagateBody(RackResponse rackResponse, HttpServletResponse response) {\n    ServletOutputStream outputStream = null;\n\n    try {\n      outputStream = response.getOutputStream();\n    } catch (IOException e) {\n      Throwables.propagate(e);\n    }\n\n    Iterator<byte[]> body = rackResponse.getBody();\n\n    while (body.hasNext()) {\n      try {\n        outputStream.write(body.next());\n      } catch (IOException e) {\n        Throwables.propagate(e);\n      }\n    }\n\n    try {\n      outputStream.flush();\n    } catch (IOException e) {\n      Throwables.propagate(e);\n    }\n  }\n}\n"}
{"test_method": "@Test public void error() {\n    subject.error(MESSAGE);\n    verify(delegate).error(MESSAGE);\n  }", "focal_method": "public void error(String message) {\n    logger.error(message);\n  }", "test_file": "package com.squareup.rack;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.runners.MockitoJUnitRunner;\nimport org.slf4j.Logger;\n\nimport static com.squareup.rack.RackLogger.FATAL;\nimport static org.mockito.Mockito.verify;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class RackLoggerTest {\n  private static final String MESSAGE = \"message\";\n\n  private RackLogger subject;\n  @Mock private Logger delegate;\n\n  @Before public void setUp() {\n    subject = new RackLogger(delegate);\n  }\n\n  @Test(expected = NullPointerException.class)\n  public void constructorRequiresALogger() {\n    new RackLogger(null);\n  }\n\n  @Test public void info() {\n    subject.info(MESSAGE);\n    verify(delegate).info(MESSAGE);\n  }\n\n  @Test public void debug() {\n    subject.debug(MESSAGE);\n    verify(delegate).debug(MESSAGE);\n  }\n\n  @Test public void warn() {\n    subject.warn(MESSAGE);\n    verify(delegate).warn(MESSAGE);\n  }\n\n  @Test public void error() {\n    subject.error(MESSAGE);\n    verify(delegate).error(MESSAGE);\n  }\n\n  @Test public void fatal() {\n    subject.fatal(MESSAGE);\n    verify(delegate).error(FATAL, MESSAGE);\n  }\n}\n", "focal_file": "/*\n * Copyright (C) 2013 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.squareup.rack;\n\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.MarkerFactory;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\n/**\n * Adapts a {@link Logger} to the required interface for {@code rack.logger}.\n */\npublic class RackLogger {\n  public static final Marker FATAL = MarkerFactory.getMarker(\"FATAL\");\n\n  private final Logger logger;\n\n  /**\n   * Creates a {@link RackLogger} that forwards messages to the given {@link Logger}.\n   *\n   * @param logger\n   */\n  public RackLogger(Logger logger) {\n    this.logger = checkNotNull(logger);\n  }\n\n  public void info(String message) {\n    logger.info(message);\n  }\n\n  public void debug(String message) {\n    logger.debug(message);\n  }\n\n  public void warn(String message) {\n    logger.warn(message);\n  }\n\n  public void error(String message) {\n    logger.error(message);\n  }\n\n  public void fatal(String message) {\n    // See http://www.slf4j.org/faq.html#fatal\n    logger.error(FATAL, message);\n  }\n}\n"}
{"test_method": "@Test\n    public void loggingAccordingToLevel() {\n        // Fixture\n        LoggerChannel loggerTrace = mock(LoggerChannel.class);\n        LoggerChannel loggerInfo = mock(LoggerChannel.class);\n        LoggerChannel loggerError = mock(LoggerChannel.class);\n        PluggableLoggerFactory factory = new PluggableLoggerFactory();\n        factory.addLogger(loggerInfo, Level.INFO);\n        factory.addLogger(loggerError, Level.ERROR);\n        factory.addLogger(loggerTrace, Level.TRACE);\n        Logger logger = factory.getLogger(\"test\");\n        // Test\n        logger.error(\"test\");\n        logger.info(\"test\");\n        logger.trace(\"test\");\n        // Assert\n        verify(loggerTrace, times(3)).log(Mockito.any(Level.class), anyString(), Mockito.any(Marker.class), anyString(), Mockito.any(Throwable.class));\n        verify(loggerInfo, times(2)).log(Mockito.any(Level.class), anyString(), Mockito.any(Marker.class), anyString(), Mockito.any(Throwable.class));\n        verify(loggerError, times(1)).log(Mockito.any(Level.class), anyString(), Mockito.any(Marker.class), anyString(), Mockito.any(Throwable.class));\n    }", "focal_method": "public PluggableLoggerFactory addLogger(LoggerChannel logger, Level level) {\n        mSortedLoggers.add(new SortedLogger(logger, level.toInt()));\n        Collections.sort(mSortedLoggers, mSortedLoggersComparator);\n        return this;\n    }", "test_file": "package net.alea.android.slf4j;\n\nimport android.support.test.filters.SmallTest;\n\nimport static org.junit.Assert.*;\n\nimport static org.hamcrest.Matchers.*;\nimport org.junit.Test;\nimport org.mockito.Mockito;\nimport org.slf4j.Logger;\nimport org.slf4j.Marker;\nimport org.slf4j.event.Level;\n\nimport static org.mockito.Mockito.*;\n\n@SmallTest\npublic class PluggableLoggerFactoryTest {\n\n    public final static int NAME_MAX_SIZE = 23;\n\n    @Test\n    public void removeLoggers() {\n        PluggableLoggerFactory factory = new PluggableLoggerFactory();\n        assertThat(factory.getLoggers().size(), equalTo(0));\n        factory.addLogger(mock(LoggerChannel.class), Level.TRACE);\n        factory.addLogger(mock(LoggerChannel.class), Level.TRACE);\n        assertThat(factory.getLoggers().size(), equalTo(2));\n        factory.removeAll();\n        assertThat(factory.getLoggers().size(), equalTo(0));\n    }\n\n\n    @Test\n    public void loggerSortedFromLowToHighLevel() {\n        // Fixture\n        LoggerChannel loggerTrace = mock(LoggerChannel.class);\n        LoggerChannel loggerInfo = mock(LoggerChannel.class);\n        LoggerChannel loggerError = mock(LoggerChannel.class);\n        PluggableLoggerFactory factory = new PluggableLoggerFactory();\n        // Test\n        factory.addLogger(loggerInfo, Level.INFO);\n        factory.addLogger(loggerError, Level.ERROR);\n        factory.addLogger(loggerTrace, Level.TRACE);\n        // Assert\n        assertThat(factory.getLoggers().get(0).logger, sameInstance(loggerTrace));\n        assertThat(factory.getLoggers().get(1).logger, sameInstance(loggerInfo));\n        assertThat(factory.getLoggers().get(2).logger, sameInstance(loggerError));\n    }\n\n\n    @Test\n    public void loggingAccordingToLevel() {\n        // Fixture\n        LoggerChannel loggerTrace = mock(LoggerChannel.class);\n        LoggerChannel loggerInfo = mock(LoggerChannel.class);\n        LoggerChannel loggerError = mock(LoggerChannel.class);\n        PluggableLoggerFactory factory = new PluggableLoggerFactory();\n        factory.addLogger(loggerInfo, Level.INFO);\n        factory.addLogger(loggerError, Level.ERROR);\n        factory.addLogger(loggerTrace, Level.TRACE);\n        Logger logger = factory.getLogger(\"test\");\n        // Test\n        logger.error(\"test\");\n        logger.info(\"test\");\n        logger.trace(\"test\");\n        // Assert\n        verify(loggerTrace, times(3)).log(Mockito.any(Level.class), anyString(), Mockito.any(Marker.class), anyString(), Mockito.any(Throwable.class));\n        verify(loggerInfo, times(2)).log(Mockito.any(Level.class), anyString(), Mockito.any(Marker.class), anyString(), Mockito.any(Throwable.class));\n        verify(loggerError, times(1)).log(Mockito.any(Level.class), anyString(), Mockito.any(Marker.class), anyString(), Mockito.any(Throwable.class));\n    }\n\n\n    @Test\n    public void loggerNameLimitation() {\n        PluggableLoggerFactory factory = new PluggableLoggerFactory();\n        Logger logger = factory.getLogger(\"123456789012345678901234567890\");\n        assertThat(logger.getName().length(), lessThanOrEqualTo(NAME_MAX_SIZE));\n    }\n\n\n    @Test\n    public void loggerNotUsedAfterRemoved() {\n        // Fixture\n        LoggerChannel loggerChannel = mock(LoggerChannel.class);\n        PluggableLoggerFactory factory = new PluggableLoggerFactory();\n        factory.addLogger(loggerChannel, Level.INFO);\n        Logger logger = factory.getLogger(\"test\");\n        // Test and assert\n        logger.info(\"test\");\n        verify(loggerChannel, times(1)).log(Mockito.any(Level.class), anyString(), Mockito.any(Marker.class), anyString(), Mockito.any(Throwable.class));\n        factory.removeAll();\n        logger.info(\"test\");\n        verify(loggerChannel, times(1)).log(Mockito.any(Level.class), anyString(), Mockito.any(Marker.class), anyString(), Mockito.any(Throwable.class));\n    }\n\n\n}\n", "focal_file": "/****************************************************************************************\n * Copyright (c) 2016, 2017, 2019 Vincent Hiribarren                                    *\n *                                                                                      *\n * This program is free software; you can redistribute it and/or modify it under        *\n * the terms of the GNU General Public License as published by the Free Software        *\n * Foundation; either version 3 of the License, or (at your option) any later           *\n * version.                                                                             *\n *                                                                                      *\n * Linking Beacon Simulator statically or dynamically with other modules is making      *\n * a combined work based on Beacon Simulator. Thus, the terms and conditions of         *\n * the GNU General Public License cover the whole combination.                          *\n *                                                                                      *\n * As a special exception, the copyright holders of Beacon Simulator give you           *\n * permission to combine Beacon Simulator program with free software programs           *\n * or libraries that are released under the GNU LGPL and with independent               *\n * modules that communicate with Beacon Simulator solely through the                    *\n * net.alea.beaconsimulator.bluetooth.AdvertiseDataGenerator and the                    *\n * net.alea.beaconsimulator.bluetooth.AdvertiseDataParser interfaces. You may           *\n * copy and distribute such a system following the terms of the GNU GPL for             *\n * Beacon Simulator and the licenses of the other code concerned, provided that         *\n * you include the source code of that other code when and as the GNU GPL               *\n * requires distribution of source code and provided that you do not modify the         *\n * net.alea.beaconsimulator.bluetooth.AdvertiseDataGenerator and the                    *\n * net.alea.beaconsimulator.bluetooth.AdvertiseDataParser interfaces.                   *\n *                                                                                      *\n * The intent of this license exception and interface is to allow Bluetooth low energy  *\n * closed or proprietary advertise data packet structures and contents to be sensibly   *\n * kept closed, while ensuring the GPL is applied. This is done by using an interface   *\n * which only purpose is to generate android.bluetooth.le.AdvertiseData objects.        *\n *                                                                                      *\n * This exception is an additional permission under section 7 of the GNU General        *\n * Public License, version 3 (\u201cGPLv3\u201d).                                                 *\n *                                                                                      *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *\n * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *\n *                                                                                      *\n * You should have received a copy of the GNU General Public License along with         *\n * this program.  If not, see <http://www.gnu.org/licenses/>.                           *\n ****************************************************************************************/\n\npackage net.alea.android.slf4j;\n\n\nimport org.slf4j.Logger;\nimport org.slf4j.event.Level;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\n\n\npublic class PluggableLoggerFactory extends AbstractSimpleLoggerFactory {\n\n    static class SortedLogger {\n        LoggerChannel logger;\n        int level;\n        public SortedLogger(LoggerChannel logger, int level) {\n            this.logger = logger;\n            this.level = level;\n        }\n    }\n\n    private ArrayList<SortedLogger> mSortedLoggers = new ArrayList<>();\n    private Comparator<SortedLogger> mSortedLoggersComparator = new Comparator<SortedLogger>() {\n        @Override\n        public int compare(SortedLogger o1, SortedLogger o2) {\n            return o1.level - o2.level;\n        }\n    };\n\n\n    @Override\n    public Logger generateLogger(String name) {\n        return new PluggableLogger(name, this);\n    }\n\n    public PluggableLoggerFactory removeAll() {\n        mSortedLoggers.clear();\n        return this;\n    }\n\n    public PluggableLoggerFactory addLogger(LoggerChannel logger, Level level) {\n        mSortedLoggers.add(new SortedLogger(logger, level.toInt()));\n        Collections.sort(mSortedLoggers, mSortedLoggersComparator);\n        return this;\n    }\n\n    List<SortedLogger> getLoggers() {\n        return mSortedLoggers;\n    }\n}\n"}
{"test_method": "@Test\n    public void nullLevelDoNotCrash() {\n        LoggerChannelLogcat loggerChannel = spy(LoggerChannelLogcat.class);\n        loggerChannel.log(null, \"name\", null, \"hello\", null);\n    }", "focal_method": "@SuppressWarnings(\"UnnecessaryReturnStatement\")\n    @Override\n    public void log(Level level, String name, Marker marker, String message, Throwable throwable) {\n        if (level == null) {\n            level = Level.WARN;\n        }\n        switch (level) {\n            case TRACE:\n                Log.v(name, message, throwable);\n                return;\n            case DEBUG:\n                Log.d(name, message, throwable);\n                return;\n            case INFO:\n                Log.i(name, message, throwable);\n                return;\n            case WARN:\n                Log.w(name, message, throwable);\n                return;\n            case ERROR:\n                Log.e(name, message, throwable);\n                return;\n        }\n    }", "test_file": "package net.alea.android.slf4j;\n\nimport android.support.test.filters.SmallTest;\n\nimport org.junit.Test;\n\nimport static org.mockito.Mockito.*;\n\n@SmallTest\npublic class LoggerChannelLogcatTest {\n\n    @Test\n    public void nullLevelDoNotCrash() {\n        LoggerChannelLogcat loggerChannel = spy(LoggerChannelLogcat.class);\n        loggerChannel.log(null, \"name\", null, \"hello\", null);\n    }\n\n}\n", "focal_file": "/****************************************************************************************\n * Copyright (c) 2016, 2017, 2019 Vincent Hiribarren                                    *\n *                                                                                      *\n * This program is free software; you can redistribute it and/or modify it under        *\n * the terms of the GNU General Public License as published by the Free Software        *\n * Foundation; either version 3 of the License, or (at your option) any later           *\n * version.                                                                             *\n *                                                                                      *\n * Linking Beacon Simulator statically or dynamically with other modules is making      *\n * a combined work based on Beacon Simulator. Thus, the terms and conditions of         *\n * the GNU General Public License cover the whole combination.                          *\n *                                                                                      *\n * As a special exception, the copyright holders of Beacon Simulator give you           *\n * permission to combine Beacon Simulator program with free software programs           *\n * or libraries that are released under the GNU LGPL and with independent               *\n * modules that communicate with Beacon Simulator solely through the                    *\n * net.alea.beaconsimulator.bluetooth.AdvertiseDataGenerator and the                    *\n * net.alea.beaconsimulator.bluetooth.AdvertiseDataParser interfaces. You may           *\n * copy and distribute such a system following the terms of the GNU GPL for             *\n * Beacon Simulator and the licenses of the other code concerned, provided that         *\n * you include the source code of that other code when and as the GNU GPL               *\n * requires distribution of source code and provided that you do not modify the         *\n * net.alea.beaconsimulator.bluetooth.AdvertiseDataGenerator and the                    *\n * net.alea.beaconsimulator.bluetooth.AdvertiseDataParser interfaces.                   *\n *                                                                                      *\n * The intent of this license exception and interface is to allow Bluetooth low energy  *\n * closed or proprietary advertise data packet structures and contents to be sensibly   *\n * kept closed, while ensuring the GPL is applied. This is done by using an interface   *\n * which only purpose is to generate android.bluetooth.le.AdvertiseData objects.        *\n *                                                                                      *\n * This exception is an additional permission under section 7 of the GNU General        *\n * Public License, version 3 (\u201cGPLv3\u201d).                                                 *\n *                                                                                      *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *\n * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *\n *                                                                                      *\n * You should have received a copy of the GNU General Public License along with         *\n * this program.  If not, see <http://www.gnu.org/licenses/>.                           *\n ****************************************************************************************/\n\npackage net.alea.android.slf4j;\n\n\nimport android.util.Log;\n\nimport org.slf4j.Marker;\nimport org.slf4j.event.Level;\n\npublic class LoggerChannelLogcat implements LoggerChannel {\n\n    @SuppressWarnings(\"UnnecessaryReturnStatement\")\n    @Override\n    public void log(Level level, String name, Marker marker, String message, Throwable throwable) {\n        if (level == null) {\n            level = Level.WARN;\n        }\n        switch (level) {\n            case TRACE:\n                Log.v(name, message, throwable);\n                return;\n            case DEBUG:\n                Log.d(name, message, throwable);\n                return;\n            case INFO:\n                Log.i(name, message, throwable);\n                return;\n            case WARN:\n                Log.w(name, message, throwable);\n                return;\n            case ERROR:\n                Log.e(name, message, throwable);\n                return;\n        }\n    }\n\n}\n"}
{"test_method": "@Test\n    public void test2()\n    {\n        byte[] data = {\n                (byte)18,                // Length\n                (byte)0x16,              // AD Type = Service Data - 16-bit UUID\n                (byte)0xAA, (byte)0xFE,  // Eddystone UUID\n                (byte)0x10,              // Eddystone Frame Type = URL\n                (byte)-50,               // Calibrated Tx power at 0 m\n                (byte)0x01,              // URL Scheme Prefix (\"https://www.\")\n                (byte)'e',               // e\n                (byte)'x',               // x\n                (byte)'a',               // a\n                (byte)'m',               // m\n                (byte)'p',               // p\n                (byte)'l',               // l\n                (byte)'e',               // e\n                (byte)0x01,              // \".org/\"\n                (byte)'t',               // t\n                (byte)'e',               // e\n                (byte)'s',               // s\n                (byte)'t',               // t\n        };\n\n        EddystoneURL es = getEddystoneURL(data);\n\n        // URL\n        assertEquals(\"Unexpected URL.\", \"https://www.example.org/test\", es.getURL().toExternalForm());\n    }", "focal_method": "public URL getURL()\n    {\n        return mURL;\n    }", "test_file": "/*\n * Copyright (C) 2015 Neo Visionaries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.neovisionaries.bluetooth.ble.advertising;\n\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertSame;\nimport static org.junit.Assert.assertTrue;\nimport java.util.List;\nimport java.util.UUID;\nimport org.junit.Test;\nimport com.neovisionaries.bluetooth.ble.advertising.Eddystone.FrameType;\nimport com.neovisionaries.bluetooth.ble.util.UUIDCreator;\n\n\npublic class EddystoneURLTest\n{\n    private static EddystoneURL getEddystoneURL(byte[] data)\n    {\n        List<ADStructure> list = ADPayloadParser.getInstance().parse(data);\n\n        return (EddystoneURL)list.get(0);\n    }\n\n\n    @Test\n    public void test1()\n    {\n        byte[] data = {\n                (byte)14,                // Length\n                (byte)0x16,              // AD Type = Service Data - 16-bit UUID\n                (byte)0xAA, (byte)0xFE,  // Eddystone UUID\n                (byte)0x10,              // Eddystone Frame Type = URL\n                (byte)-50,               // Calibrated Tx power at 0 m\n                (byte)0x00,              // URL Scheme Prefix (\"http://www.\")\n                (byte)'e',               // e\n                (byte)'x',               // x\n                (byte)'a',               // a\n                (byte)'m',               // m\n                (byte)'p',               // p\n                (byte)'l',               // l\n                (byte)'e',               // e\n                (byte)0x00               // \".com/\"\n        };\n\n        List<ADStructure> list = ADPayloadParser.getInstance().parse(data);\n\n        assertNotNull(\"ADPayloadParser.parse(byte[]) returned null.\", list);\n        assertEquals(\"Unexpected size of ADStructure list.\", 1, list.size());\n\n        // EddystoneURL\n        assertTrue(\"Not an instance of EddystoneURL.\", (list.get(0) instanceof EddystoneURL));\n        EddystoneURL es = (EddystoneURL)list.get(0);\n\n        // AD Type\n        assertEquals(\"AD Type is not 0x16.\", 0x16, es.getType());\n\n        // Service UUID\n        UUID uuid = UUIDCreator.from16(new byte[] { (byte)0xAA, (byte)0xFE });\n        assertEquals(\"Service UUID is not for Eddystone.\", uuid, es.getServiceUUID());\n\n        // Frame Type\n        assertSame(\"Unexpected Frame Type.\", FrameType.URL, es.getFrameType());\n\n        // Tx Power\n        assertEquals(\"Unexpected Tx Power.\", -50, es.getTxPower());\n\n        // URL\n        assertEquals(\"Unexpected URL.\", \"http://www.example.com/\", es.getURL().toExternalForm());\n    }\n\n\n    @Test\n    public void test2()\n    {\n        byte[] data = {\n                (byte)18,                // Length\n                (byte)0x16,              // AD Type = Service Data - 16-bit UUID\n                (byte)0xAA, (byte)0xFE,  // Eddystone UUID\n                (byte)0x10,              // Eddystone Frame Type = URL\n                (byte)-50,               // Calibrated Tx power at 0 m\n                (byte)0x01,              // URL Scheme Prefix (\"https://www.\")\n                (byte)'e',               // e\n                (byte)'x',               // x\n                (byte)'a',               // a\n                (byte)'m',               // m\n                (byte)'p',               // p\n                (byte)'l',               // l\n                (byte)'e',               // e\n                (byte)0x01,              // \".org/\"\n                (byte)'t',               // t\n                (byte)'e',               // e\n                (byte)'s',               // s\n                (byte)'t',               // t\n        };\n\n        EddystoneURL es = getEddystoneURL(data);\n\n        // URL\n        assertEquals(\"Unexpected URL.\", \"https://www.example.org/test\", es.getURL().toExternalForm());\n    }\n}\n", "focal_file": "/*\n * Copyright (C) 2015 Neo Visionaries Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.neovisionaries.bluetooth.ble.advertising;\n\n\nimport java.net.MalformedURLException;\nimport java.net.URL;\n\n\n/**\n * Eddystone URL.\n *\n * @since 1.5\n *\n * @see <a href=\"https://github.com/google/eddystone/tree/master/eddystone-url\">Eddystone URL</a>\n */\npublic class EddystoneURL extends Eddystone\n{\n    private static final long serialVersionUID = 1L;\n    private static final String STRING_FORMAT = \"EddystoneURL(TxPower=%d,URL=%s)\";\n\n    private static final String[] SCHEME_PREFIXES = {\n        \"http://www.\",      // 0\n        \"https://www.\",     // 1\n        \"http://\",          // 2\n        \"https://\",         // 3\n    };\n\n    private static final String[] EXPANSION_CODES = {\n        \".com/\",            //  0, 0x00\n        \".org/\",            //  1, 0x01\n        \".edu/\",            //  2, 0x02\n        \".net/\",            //  3, 0x03\n        \".info/\",           //  4, 0x04\n        \".biz/\",            //  5, 0x05\n        \".gov/\",            //  6, 0x06\n        \".com\",             //  7, 0x07\n        \".org\",             //  8, 0x08\n        \".edu\",             //  9, 0x09\n        \".net\",             // 10, 0x0A\n        \".info\",            // 11, 0x0B\n        \".biz\",             // 12, 0x0C\n        \".gov\",             // 13, 0x0D\n    };\n\n\n    private final int mTxPower;\n    private final URL mURL;\n\n\n    /**\n     * Constructor to create an instance with length=5, type=0x16\n     * (Service Data - 16-bit UUID), service-UUID=0xFEAA (Eddystone),\n     * frame-type=URL, tx-power=0, and URL=null.\n     */\n    public EddystoneURL()\n    {\n        this(5, 0x16, new byte[] {\n                (byte)0xAA, (byte)0xFE, // Service UUID of Eddystone.\n                (byte)0x10,             // Frame Type = Eddystone URL\n                (byte)0x00              // Calibrated Tx power at 0 m\n        });\n    }\n\n\n    /**\n     * Constructor.\n     *\n     * @param length\n     *         The length of the AD structure.\n     *\n     * @param type\n     *         The AD type. The value should always be 0x16\n     *         (Service Data - 16-bit UUID).\n     *\n     * @param data\n     *         The AD data whose format is <i>Eddystone UID</i>.\n     *         The first two bytes should be 0xAA and 0xFE\n     *         (meaning Eddystone). The third byte should be 0x1?\n     *         (meaning Eddystone URL).\n     */\n    public EddystoneURL(int length, int type, byte[] data)\n    {\n        super(length, type, data, FrameType.URL);\n\n        mTxPower = extractTxPower(data);\n        mURL     = extractURL(data);\n    }\n\n\n    private int extractTxPower(byte[] data)\n    {\n        // data[0] = 0xAA  // Eddystone\n        // data[1] = 0xFE  //\n        // data[2] = 0x1?  // Frame Type = Eddystone URL\n        // data[3]         // Calibrated Tx power at 0 m.\n\n        if (4 <= data.length)\n        {\n            return data[3];\n        }\n        else\n        {\n            return 0;\n        }\n    }\n\n\n    private URL extractURL(byte[] data)\n    {\n        StringBuilder builder = new StringBuilder();\n\n        // URL Scheme Prefix\n        String prefix = extractSchemePrefix(data);\n        if (prefix != null)\n        {\n            builder.append(prefix);\n        }\n\n        for (int i = 5; i < data.length; ++i)\n        {\n            int ch = data[i];\n\n            if (0 <= ch && ch < EXPANSION_CODES.length)\n            {\n                builder.append(EXPANSION_CODES[ch]);\n            }\n            else if (0x20 < ch && ch < 0x7F)\n            {\n                builder.append((char)ch);\n            }\n        }\n\n        if (builder.length() == 0)\n        {\n            return null;\n        }\n\n        try\n        {\n            return new URL(builder.toString());\n        }\n        catch (MalformedURLException e)\n        {\n            return null;\n        }\n    }\n\n\n    private String extractSchemePrefix(byte[] data)\n    {\n        // data[4] = URL Scheme Prefix\n\n        if (data.length < 5)\n        {\n            return null;\n        }\n\n        int code = data[4];\n\n        if (code < 0 || SCHEME_PREFIXES.length <= code)\n        {\n            return null;\n        }\n\n        return SCHEME_PREFIXES[code];\n    }\n\n\n    /**\n     * Get the calibrated Tx power at 0 m.\n     *\n     * @return\n     *         The calibrated Tx power at 0 m.\n     */\n    public int getTxPower()\n    {\n        return mTxPower;\n    }\n\n\n    /**\n     * Get the URL.\n     *\n     * @return\n     *         The URL.\n     */\n    public URL getURL()\n    {\n        return mURL;\n    }\n\n\n    @Override\n    public String toString()\n    {\n        return String.format(STRING_FORMAT, mTxPower, mURL);\n    }\n}\n"}
{"test_method": "@Test\n\tpublic void testToBytes() {\n\t\tLog.log(\"Testing number to bytes conversion ...\");\n\t\tbyte[] javadata = null;\n\t\tbyte[] data = null;\n\n\t\t// test MIN \n\t\tint n;\n\t\tn=Integer.MIN_VALUE;\n\t\tjavadata = Integer.toString(n).getBytes();\n\t\tdata = Convert.toBytes(n);\n\t\tassertEquals (data.length, javadata.length, \"buffer length\");\n\t\tfor(int j=0; j<data.length;j++)\n\t\t\tassertEquals(data[j], javadata[j], \"for <\"+n+\"> byte @ [\"+j+\"]\");\n\n\t\t// test MAX\n\t\tn=Integer.MAX_VALUE;\n\t\tjavadata = Integer.toString(n).getBytes();\n\t\tdata = Convert.toBytes(n);\n\t\tassertEquals (data.length, javadata.length, \"buffer length\");\n\t\tfor(int j=0; j<data.length;j++)\n\t\t\tassertEquals(data[j], javadata[j], \"for <\"+n+\"> byte @ [\"+j+\"]\");\n\n\t\t// test a bit smaller than Convert.INT_N_65535\n\t\tn=Convert.INT_N_65535 - 444;\n\t\tjavadata = Integer.toString(n).getBytes();\n\t\tdata = Convert.toBytes(n);\n\t\tassertEquals (data.length, javadata.length, \"buffer length\");\n\t\tfor(int j=0; j<data.length;j++)\n\t\t\tassertEquals(data[j], javadata[j], \"for <\"+n+\"> byte @ [\"+j+\"]\");\n\n\t\t// test a bit larger than Convert.INT_P_65535\n\t\tn=Convert.INT_P_65535 + 444;\n\t\tjavadata = Integer.toString(n).getBytes();\n\t\tdata = Convert.toBytes(n);\n\t\tassertEquals (javadata.length, data.length, \"buffer length\");\n\t\tfor(int j=0; j<data.length;j++)\n\t\t\tassertEquals( data[j], javadata[j], \"for <\"+n+\"> byte @ [\"+j+\"]\");\n\n\t\t// test the exact range range\n\t\tfor(int i=Convert.INT_N_65535; i<Convert.INT_P_65535; i++){\n\t\t\t//\t\tfor(int i=Integer.MIN_VALUE; i<Integer.MAX_VALUE; i++){\n\t\t\tjavadata = Integer.toString(i).getBytes();\n\t\t\tdata = Convert.toBytes(i);\n\t\t\tassertEquals (data.length, javadata.length, \"buffer length\" );\n\t\t\tfor(int j=0; j<data.length;j++)\n\t\t\t\tassertEquals( data[j], javadata[j], \"for <\"+i+\"> byte @ [\"+j+\"]\");\n\t\t}\t\t\n\t}", "focal_method": "public static final byte[] toBytes(int i){\n\t\tif(i < INT_N_65535 || i > INT_P_65535) {\n\t\t\treturn Integer.toString(i).getBytes();\n\t\t}\n\t\tfinal int absi = Math.abs(i);\n\t\tfinal byte[] cachedData = i2b_65535[absi];\n\t\tfinal byte[] data;\n\t\tif(cachedData == null) {\n\t\t\tdata = Integer.toString(absi).getBytes();\n\t\t\ti2b_65535[absi] = data;\n\t\t}\n\t\telse {\n\t\t\tdata = cachedData;\n\t\t}\n\t\treturn i >= 0 ? data : getNegativeNumberBytes(data);\n\t}", "test_file": "/*\n * Copyright (c) 2009, Joubin Houshyar <alphazero at sensesay dot net>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *     \n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *     \n *   * Neither the name of JRedis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n * \n */ \n\npackage org.jredis.ri.alphazero.support;\n\n\n\nimport org.testng.annotations.Test;\nimport static org.testng.Assert.*;\n\n/**\n * @author Joubin Houshyar (alphazero@sensesay.net)\n * \n */\n@Test(suiteName=\"support-tests\")\npublic class ConvertTest {\n\t\n\t@Test\n\tpublic void testGetNaturalNumber() {\n\t\tLog.log(\"Testing bytes to number conversion ...\");\n\t\tbyte[] data = null;\n\t\t\n\t\t// test null\n\t\tboolean inputChecking;\n\t\tinputChecking = false;\n\t\ttry { \n\t\t\tConvert.toInt(data); \n\t\t}\n\t\tcatch (IllegalArgumentException e){ inputChecking = true;}\n\t\tfinally { assertTrue(inputChecking);}\n\t\t\n\t\t// test garbage data\n\t\tinputChecking = false;\n\t\tdata = \"2be?\".getBytes();\n\t\ttry { \n\t\t\tConvert.toInt(data); \n\t\t}\n\t\tcatch (IllegalArgumentException e){ inputChecking = true;}\n\t\tfinally { assertTrue(inputChecking);}\n\t\t\n\t\t// test big data\n\t\t// this is bigger than an bit \n\t\tinputChecking = false;\n\t\tdata = \"1234567890123456\".getBytes();\n\t\ttry { Convert.toInt(data); }\n\t\tcatch (IllegalArgumentException e){ inputChecking = true; }\n\t\tfinally { assertTrue(inputChecking);}\n\t\t\n\t\t{\n\t\t// test 0\n\t\tdata = \"0\".getBytes();\n\t\tint value = Convert.toInt(data);\n\t\tassertEquals(0, value);\n\t\t// test -0\n\t\tdata = \"-0\".getBytes();\n\t\t// test +0\n\t\tdata = \"+0\".getBytes();\n\t\tassertEquals(0, Convert.toInt(data));\n\t\t// test -00000\n\t\tdata = \"-0000\".getBytes();\n\t\tassertEquals(0, Convert.toInt(data));\n\t\t// test 00000\n\t\tdata = \"0000\".getBytes();\n\t\t// test +00000\n\t\tdata = \"+0000\".getBytes();\n\t\tassertEquals(0, Convert.toInt(data));\n\t\t// test 00001\n\t\tdata = \"00001\".getBytes();\n\t\tassertEquals(1, Convert.toInt(data));\n\t\t// test 0000100\n\t\tdata = \"0000100\".getBytes();\n\t\tassertEquals(100, Convert.toInt(data));\n\t\t// test 00001\n\t\tdata = \"+00001\".getBytes();\n\t\tassertEquals(1, Convert.toInt(data));\n\t\t// test +0000100\n\t\tdata = \"+0000100\".getBytes();\n\t\tassertEquals(100, Convert.toInt(data));\n\t\t// test 00001\n\t\tdata = \"-00001\".getBytes();\n\t\tassertEquals(-1, Convert.toInt(data));\n\t\t// test +0000100\n\t\tdata = \"-0000100\".getBytes();\n\t\tassertEquals(-100, Convert.toInt(data));\n\t\t// test 1\n\t\tdata = \"1\".getBytes();\n\t\tassertEquals(1, Convert.toInt(data));\n\t\t// test -1\n\t\tdata = \"-1\".getBytes();\n\t\tassertEquals(-1, Convert.toInt(data));\n\t\t// test +1\n\t\tdata = \"+1\".getBytes();\n\t\tassertEquals(1, Convert.toInt(data));\n\t\t\n\t\t// test $+1\n\t\tdata = \"$+1\".getBytes();\n\t\tassertEquals(1, Convert.toInt(data, 1, data.length-1));\n\t\t\n\t\t// test $-1\n\t\tdata = \"$-1\".getBytes();\n\t\tassertEquals(-1, Convert.toInt(data, 1, data.length-1));\n\t\t\n\t\t// test $+1GARBAGEDATA\n\t\tdata = \"$+1GARBAGEDATA\".getBytes();\n\t\tassertEquals(1, Convert.toInt(data, 1, 2));\n\t\t\n\t\t// test $-1GARAGEDATA\n\t\tdata = \"$-1GARAGEDATA\".getBytes();\n\t\tassertEquals(-1, Convert.toInt(data, 1, 2));\n\t\t\n\t\t// do a sensible range\n\t\tint java ;\n\t\tfor(int i=-50000; i<50000; i++) {\n\t\t\tdata = Convert.toBytes(i);\n\t\t\tjava = Integer.parseInt(new String(data), 10);\n\t\t\tassertEquals (java, Convert.toInt(data));\n\t\t}\n\t\t\n\t\t// now lets go to the limit\n\t\t//\n\t\tdata = Integer.toString(Integer.MAX_VALUE).getBytes();\n\t\tassertEquals(Integer.MAX_VALUE, Convert.toInt(data, 0, data.length));\n\n\t\tdata = Integer.toString(Integer.MIN_VALUE).getBytes();\n\t\tassertEquals(Integer.MIN_VALUE, Convert.toInt(data, 0, data.length));\n\t\t\n\t\t}\n\t\t\n\t\t// now lets do the longs\n\n\t\t{\n\t\t// test big data\n\t\t// this is bigger than an bit  but fine for a long\n\t\tinputChecking = false;\n\t\tdata = \"1234567890123456\".getBytes();\n\t\tassertEquals (1234567890123456L, Convert.toLong(data));\n\t\t\n\t\t// test 0\n\t\tdata = \"0\".getBytes();\n\t\tlong value = Convert.toLong(data);\n\t\tassertEquals(0, value);\n\t\t// test -0\n\t\tdata = \"-0\".getBytes();\n\t\t// test +0\n\t\tdata = \"+0\".getBytes();\n\t\tassertEquals(0, Convert.toLong(data));\n\t\t// test -00000\n\t\tdata = \"-0000\".getBytes();\n\t\tassertEquals(0, Convert.toLong(data));\n\t\t// test 00000\n\t\tdata = \"0000\".getBytes();\n\t\t// test +00000\n\t\tdata = \"+0000\".getBytes();\n\t\tassertEquals(0, Convert.toLong(data));\n\t\t// test 00001\n\t\tdata = \"00001\".getBytes();\n\t\tassertEquals(1, Convert.toLong(data));\n\t\t// test 0000100\n\t\tdata = \"0000100\".getBytes();\n\t\tassertEquals(100, Convert.toLong(data));\n\t\t// test 00001\n\t\tdata = \"+00001\".getBytes();\n\t\tassertEquals(1, Convert.toLong(data));\n\t\t// test +0000100\n\t\tdata = \"+0000100\".getBytes();\n\t\tassertEquals(100, Convert.toLong(data));\n\t\t// test 00001\n\t\tdata = \"-00001\".getBytes();\n\t\tassertEquals(-1, Convert.toLong(data));\n\t\t// test +0000100\n\t\tdata = \"-0000100\".getBytes();\n\t\tassertEquals(-100, Convert.toLong(data));\n\t\t// test 1\n\t\tdata = \"1\".getBytes();\n\t\tassertEquals(1, Convert.toLong(data));\n\t\t// test -1\n\t\tdata = \"-1\".getBytes();\n\t\tassertEquals(-1, Convert.toLong(data));\n\t\t// test +1\n\t\tdata = \"+1\".getBytes();\n\t\tassertEquals(1, Convert.toLong(data));\n\t\t\n\t\t// test $+1\n\t\tdata = \"$+1\".getBytes();\n\t\tassertEquals(1, Convert.toLong(data, 1, data.length-1));\n\t\t\n\t\t// test $-1\n\t\tdata = \"$-1\".getBytes();\n\t\tassertEquals(-1, Convert.toLong(data, 1, data.length-1));\n\t\t\n\t\t// test $+1GARBAGEDATA\n\t\tdata = \"$+1GARBAGEDATA\".getBytes();\n\t\tassertEquals(1, Convert.toLong(data, 1, 2));\n\t\t\n\t\t// test $-1GARAGEDATA\n\t\tdata = \"$-1GARAGEDATA\".getBytes();\n\t\tassertEquals(-1, Convert.toLong(data, 1, 2));\n\t\t\n\t\t// now lets go to the limit\n\t\t//\n\t\tdata = Long.toString(Long.MAX_VALUE).getBytes();\n\t\tassertEquals(Long.MAX_VALUE, Convert.toLong(data, 0, data.length));\n\n\t\tdata = Long.toString(Long.MIN_VALUE).getBytes();\n\t\tassertEquals(Long.MIN_VALUE, Convert.toLong(data, 0, data.length));\n\t\t\n\t\t}  // just for scoping  ..\n\t}\n\t/**\n\t * Test method for {@link org.jredis.alphazero.util.util.S27.jredis_deprecated.client.util.Convert#toBytes(int, boolean)}.\n\t */\n\t@Test\n\tpublic void testToBytes() {\n\t\tLog.log(\"Testing number to bytes conversion ...\");\n\t\tbyte[] javadata = null;\n\t\tbyte[] data = null;\n\n\t\t// test MIN \n\t\tint n;\n\t\tn=Integer.MIN_VALUE;\n\t\tjavadata = Integer.toString(n).getBytes();\n\t\tdata = Convert.toBytes(n);\n\t\tassertEquals (data.length, javadata.length, \"buffer length\");\n\t\tfor(int j=0; j<data.length;j++)\n\t\t\tassertEquals(data[j], javadata[j], \"for <\"+n+\"> byte @ [\"+j+\"]\");\n\n\t\t// test MAX\n\t\tn=Integer.MAX_VALUE;\n\t\tjavadata = Integer.toString(n).getBytes();\n\t\tdata = Convert.toBytes(n);\n\t\tassertEquals (data.length, javadata.length, \"buffer length\");\n\t\tfor(int j=0; j<data.length;j++)\n\t\t\tassertEquals(data[j], javadata[j], \"for <\"+n+\"> byte @ [\"+j+\"]\");\n\n\t\t// test a bit smaller than Convert.INT_N_65535\n\t\tn=Convert.INT_N_65535 - 444;\n\t\tjavadata = Integer.toString(n).getBytes();\n\t\tdata = Convert.toBytes(n);\n\t\tassertEquals (data.length, javadata.length, \"buffer length\");\n\t\tfor(int j=0; j<data.length;j++)\n\t\t\tassertEquals(data[j], javadata[j], \"for <\"+n+\"> byte @ [\"+j+\"]\");\n\n\t\t// test a bit larger than Convert.INT_P_65535\n\t\tn=Convert.INT_P_65535 + 444;\n\t\tjavadata = Integer.toString(n).getBytes();\n\t\tdata = Convert.toBytes(n);\n\t\tassertEquals (javadata.length, data.length, \"buffer length\");\n\t\tfor(int j=0; j<data.length;j++)\n\t\t\tassertEquals( data[j], javadata[j], \"for <\"+n+\"> byte @ [\"+j+\"]\");\n\n\t\t// test the exact range range\n\t\tfor(int i=Convert.INT_N_65535; i<Convert.INT_P_65535; i++){\n\t\t\t//\t\tfor(int i=Integer.MIN_VALUE; i<Integer.MAX_VALUE; i++){\n\t\t\tjavadata = Integer.toString(i).getBytes();\n\t\t\tdata = Convert.toBytes(i);\n\t\t\tassertEquals (data.length, javadata.length, \"buffer length\" );\n\t\t\tfor(int j=0; j<data.length;j++)\n\t\t\t\tassertEquals( data[j], javadata[j], \"for <\"+i+\"> byte @ [\"+j+\"]\");\n\t\t}\t\t\n\t}\n}\n", "focal_file": "/*\n *   Copyright 2009 Joubin Houshyar\n * \n *   Licensed under the Apache License, Version 2.0 (the \"License\");\n *   you may not use this file except in compliance with the License.\n *   You may obtain a copy of the License at\n *    \n *   http://www.apache.org/licenses/LICENSE-2.0\n *    \n *   Unless required by applicable law or agreed to in writing, software\n *   distributed under the License is distributed on an \"AS IS\" BASIS,\n *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *   See the License for the specific language governing permissions and\n *   limitations under the License.\n */\n\npackage org.jredis.ri.alphazero.support;\n\n\n/**\n * Perhaps a silly hack, but proven to speed things up.\n * [TODO: document me!]\n *\n * @author  Joubin Houshyar (alphazero@sensesay.net)\n * @version alpha.0, Apr 02, 2009\n * @since   alpha.0\n * \n */\npublic class Convert {\n\t\n\t// ------------------------------------------------------------------------\n\t// Constants\n\t// ------------------------------------------------------------------------\n\tpublic static final int \t\tINT_P_65535 = 65535;\n\tpublic static final int \t\tINT_N_65535 = 0 - INT_P_65535;\n\tprivate static final byte[][]   i2b_65535 = new byte[INT_P_65535+1][];\n\tprivate static final byte       BYTE_MINUS = (byte) '-';\n\tprivate static final byte       BYTE_PLUS = (byte) '+';\n\tprivate static final byte\t    BYTE_ZERO = (byte) '0';\n\tprivate static final byte\t    BYTE_NINE = (byte) '9';\n\n\tprivate static final int\tMAX_POSITIVE_32_BIT_DIGITS\t= 10;\n\tprivate static final int\tMAX_POSITIVE_64_BIT_DIGITS\t= 19;\n\t\n\t// ------------------------------------------------------------------------\n\t// public Interface\n\t// ------------------------------------------------------------------------\n\t\n\t/**\n\t * return the bytes of the string representation of the integer.  Perhaps\n\t * should be called getNumberBytes, or perhaps getHumanReadableBytes()  \n\t * Ex:  444 => \"444\".getBytes() => new byte[3]={52, 52, 52}\n\t * \n\t * If representation is not in our cache or too high (larger than Convert#INT_P_65535 )\n\t * then it will return whatever we would get from {@link Convert#toBytes(int)} which is\n\t * using JDK libs for the same.  \n\t * \n\t * The whole point here is to be faster since we need to convert numbers to the byte array \n\t * of their string representation a lot in JRedis for the protocol and to cut out the \n\t * unnecessary step of creating a new string simply because there apparently isn't any other\n\t * way in JDK to go from a number to the bytes of its textual representation. (!)  \n\t * \n\t * @param i\n\t * @param signed\n\t * @return\n\t */ \n\tpublic static final byte[] toBytes(int i){\n\t\tif(i < INT_N_65535 || i > INT_P_65535) {\n\t\t\treturn Integer.toString(i).getBytes();\n\t\t}\n\t\tfinal int absi = Math.abs(i);\n\t\tfinal byte[] cachedData = i2b_65535[absi];\n\t\tfinal byte[] data;\n\t\tif(cachedData == null) {\n\t\t\tdata = Integer.toString(absi).getBytes();\n\t\t\ti2b_65535[absi] = data;\n\t\t}\n\t\telse {\n\t\t\tdata = cachedData;\n\t\t}\n\t\treturn i >= 0 ? data : getNegativeNumberBytes(data);\n\t}\n\n\t/**\n\t * Will delegate to {@link Convert#getBytes(int)} if the 'long' number is actually\n\t * within the range of our int cache, otherwise it will return the bytes using std\n\t * JDK mechanisms.\n\t * @param lnum\n\t * @return\n\t */\n\tpublic static final byte[] toBytes(long lnum){\n\t\tif(lnum >= INT_N_65535 && lnum <= INT_P_65535) \n\t\t\treturn toBytes((int)lnum);\n\t\t\n\t\treturn Long.toString(lnum).getBytes();\n\t}\n\t\n\tpublic static final byte[] toBytes(double dnum){\n\t\treturn Double.toString(dnum).getBytes();\n\t}\n\t/**\n\t * Converts the byte[]s of the ASCII representation of a decimal number to an int.  \n\t * \n\t * <p>Expects a byte array of no more than {@link Convert#MAX_POSITIVE_32_BIT_DIGITS} bytes in length\n\t * after accounting for potential leading byte indicating the sign of the number representation.\n\t * 9 bytes (for a positive integer).  \n\t *\n\t * @param potentiallySignedAsciiBytes, for example {49, 49, 52} (\"114\")\n\t * @return\n\t * @throw IllegalArgumentException if buffer contains anything other than values 48 to 57\n\t */\n\tpublic static final int toInt(final byte[] potentiallySignedAsciiBytes, final int offsetin, final int len) throws IllegalArgumentException\n\t{\n\t\tint offset = offsetin;\n\t\tfinal byte[] buff = potentiallySignedAsciiBytes; // lets use a sensible name ;)\n\t\tif(null == buff) throw new IllegalArgumentException (\"Null input\");\n\t\tif(len > buff.length) throw new IllegalArgumentException (\"buffer length of \" + buff.length + \" less than the spec'd len \" + len);\n\n\t\tboolean negative = false;\n\t\tint digitCnt = len;\n\t\tfinal byte bs = buff[offset];\n\t\tif(bs ==BYTE_MINUS || bs == BYTE_PLUS){\n\t\t\tif(bs == BYTE_MINUS) negative = true;\n\t\t\toffset++;\n\t\t\tdigitCnt--;\n\t\t}\n\t\tif(digitCnt > MAX_POSITIVE_32_BIT_DIGITS) throw new IllegalArgumentException (\"This \\\"int\\\" has more digits than a 32 bit signed number:\" + digitCnt);\n\t\t\n\t\t// lets do it\n\t\tint value = 0;\n\t\tfor(int p = 0; p < digitCnt; p++){\n\t\t\tfinal byte b = buff[offset+p];\n\t\t\tif(b < BYTE_ZERO || b > BYTE_NINE) throw new IllegalArgumentException(\"That's not a number!  byte value: \" + b);\n\t\t\tvalue = value*10 + b - BYTE_ZERO;\n\t\t}\n\t\tif(negative) value = 0 - value;\n\t\t\n\t\treturn value;\n\t}\n\t\n\t/**\n\t * Its just like (really! :) {@link Convert#toInt(byte[], int, int)} but for {@link Long} values.  Max number of digits \n\t * is now {@link Convert#MAX_POSITIVE_64_BIT_DIGITS}.  \n\t * \n\t * @param potentiallySignedAsciiBytes\n\t * @param offset\n\t * @param len\n\t * @return\n\t * @throws IllegalArgumentException\n\t */\n\tpublic static final long toLong(byte[] potentiallySignedAsciiBytes, final int offsetin, int len) throws IllegalArgumentException\n\t{\n\t\tint offset = offsetin;\n\t\tfinal byte[] buff = potentiallySignedAsciiBytes; // lets use a sensible name ;)\n\t\tif(null == buff) throw new IllegalArgumentException (\"Null input\");\n\t\tif(len > buff.length) throw new IllegalArgumentException (\"buffer length of \" + buff.length + \" less than the spec'd len \" + len);\n\n\t\tboolean negative = false;\n\t\tint digitCnt = len;\n\t\tfinal byte bs = buff[offset];\n\t\tif(bs ==BYTE_MINUS || bs == BYTE_PLUS){\n\t\t\tif(buff[offset]==BYTE_MINUS) negative = true; \n\t\t\toffset++;\n\t\t\tdigitCnt--;\n\t\t}\n\t\tif(digitCnt > MAX_POSITIVE_64_BIT_DIGITS) throw new IllegalArgumentException (\"This \\\"int\\\" has more digits than a 32 bit signed number:\" + digitCnt);\n\t\t\n\t\t// lets do it\n\t\tlong value = 0;\n\t\tfor(int p = 0; p < digitCnt; p++){\n\t\t\tfinal byte b = buff[offset+p];\n\t\t\tif(b < BYTE_ZERO || b > BYTE_NINE) throw new IllegalArgumentException(\"That's not a number!  byte value: \" + b);\n\t\t\tvalue = value*10 + b - BYTE_ZERO;\n\t\t}\n\t\tif(negative) value = 0 - value;\n\t\t\n\t\treturn value;\n\t}\n\t\n\t/**\n\t * @param potentiallySignedBytes\n\t * @return\n\t * @throws IllegalArgumentException\n\t */\n\tpublic static final int toInt(byte[] potentiallySignedBytes) throws IllegalArgumentException\n\t{\n\t\tif(null == potentiallySignedBytes) throw new IllegalArgumentException (\"null input\");\n\t\treturn toInt(potentiallySignedBytes, 0, potentiallySignedBytes.length);\n\t}\n\t\n\t/**\n\t * @param potentiallySignedBytes\n\t * @return\n\t * @throws IllegalArgumentException\n\t */\n\tpublic static final long toLong(byte[] potentiallySignedBytes) throws IllegalArgumentException\n\t{\n\t\tif(null == potentiallySignedBytes) throw new IllegalArgumentException (\"null input\");\n\t\treturn toLong(potentiallySignedBytes, 0, potentiallySignedBytes.length);\n\t}\n\t\n\t/**\n\t * TODO: optimize.\n\t * @param potentiallySignedBytes\n\t * @return\n\t * @throws IllegalArgumentException\n\t */\n\tpublic static final double toDouble (byte[] stringRepOfDoublePrecisionBytes) throws IllegalArgumentException\n\t{\n\t\tdouble dnum = 0;\n\t\tif(null == stringRepOfDoublePrecisionBytes) throw new IllegalArgumentException (\"null input\");\n\t\ttry {\n\t\t\tdnum = Double.parseDouble(new String(stringRepOfDoublePrecisionBytes));\n\t\t}\n\t\tcatch (Exception e){\n\t\t\tthrow new IllegalArgumentException(\"\", e);\n\t\t}\n\t\treturn dnum;\n\t}\n\t\n\t// ------------------------------------------------------------------------\n\t// Inner ops\n\t// ------------------------------------------------------------------------\n\t/**\n\t * @param unsigned\n\t * @return\n\t */\n\tprivate static final byte[] getNegativeNumberBytes(byte[] unsigned){\n\t\tint unsigned_length = unsigned.length;\n\t\tbyte[] data = new byte[unsigned_length+1];\n\t\tdata [0] = BYTE_MINUS;\n\t\tSystem.arraycopy(unsigned, 0, data, 1, unsigned_length);\n\t\treturn data;\n\t}\n}"}
{"test_method": "@Test\n    public void shouldUseFirstCharFromString() {\n        final Character actual = new CharTransformer().in(\"ab\");\n\n        assertThat(actual).isEqualTo('a');\n    }", "focal_method": "@Override\n    public Character in(final String o) {\n        return o.charAt(0);\n    }", "test_file": "package io.smallrye.graphql.transformation;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\n\nimport org.junit.jupiter.api.Test;\n\npublic class CharTransformerTest {\n\n    @Test\n    public void shouldUseFirstCharFromString() {\n        final Character actual = new CharTransformer().in(\"ab\");\n\n        assertThat(actual).isEqualTo('a');\n    }\n\n    @Test\n    public void shouldUseFirstCharFromSingleLetterString() {\n        final Character actual = new CharTransformer().in(\"a\");\n\n        assertThat(actual).isEqualTo('a');\n    }\n\n    @Test\n    public void shouldThrowIfStringIsEmpty() {\n        assertThatThrownBy(() -> new CharTransformer().in(\"\"))\n                .isInstanceOf(Exception.class);\n\n    }\n\n    @Test\n    public void shouldFormatCharAsString() {\n        final String actual = new CharTransformer().out('a');\n\n        assertThat(actual).isEqualTo(\"a\");\n    }\n\n}\n", "focal_file": "package io.smallrye.graphql.transformation;\n\n/**\n * Transforms between char and String.\n */\npublic class CharTransformer implements Transformer<Character, String> {\n\n    @Override\n    public Character in(final String o) {\n        return o.charAt(0);\n    }\n\n    @Override\n    public String out(final Character o) {\n        if (o == null) {\n            return null;\n        }\n        return String.valueOf(o);\n    }\n}\n"}
{"test_method": "@Test\n    public void testCache() throws Exception {\n        // first cache with a size of 0 to stress the remove logic and make sure we\n        // don't leak\n        LRUCache<Integer, Integer> lruCache = new LRUCache<>(0);\n        testWorker(lruCache, k -> {\n            return Integer.valueOf(1);\n        });\n        validateCache(lruCache, 0);\n        testWorker(lruCache, k -> {\n            return Integer.valueOf(k);\n        });\n        validateCache(lruCache, 0);\n        // do the same test with a cache of size 1\n        lruCache = new LRUCache<>(1);\n        testWorker(lruCache, k -> {\n            return Integer.valueOf(1);\n        });\n        validateCache(lruCache, 1);\n        assertNotNull(lruCache.get(Integer.valueOf(1)));\n        testWorker(lruCache, k -> {\n            return Integer.valueOf(k);\n        });\n        validateCache(lruCache, 1);\n        assertNull(lruCache.get(Integer.valueOf(1)));\n        // Now test a larger cache\n        lruCache = new LRUCache<>(Runtime.getRuntime().availableProcessors() * 2);\n        testWorker(lruCache, k -> {\n            return Integer.valueOf(1);\n        });\n        validateCache(lruCache, 1);\n        assertNotNull(lruCache.get(Integer.valueOf(1)));\n        testWorker(lruCache, k -> {\n            return Integer.valueOf(k);\n        });\n        validateCache(lruCache, Runtime.getRuntime().availableProcessors() * 2);\n        assertNull(lruCache.get(Integer.valueOf(1)));\n        // finally test the default cache size\n        lruCache = new LRUCache<>(2048);\n        testWorker(lruCache, k -> {\n            return Integer.valueOf(1);\n        });\n        validateCache(lruCache, 1);\n        assertNotNull(lruCache.get(Integer.valueOf(1)));\n        testWorker(lruCache, k -> {\n            return Integer.valueOf(k);\n        });\n        validateCache(lruCache, 2048);\n        assertNull(lruCache.get(Integer.valueOf(1)));\n    }", "focal_method": "V get(K key) {\n        Entry<V> entry = cache.computeIfPresent(key, this::moveEntryToStart);\n        return entry == null ? null : entry.value;\n    }", "test_file": "package io.smallrye.graphql.execution;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\n\nimport java.lang.reflect.Field;\nimport java.util.Map;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.Function;\n\nimport org.junit.jupiter.api.Test;\n\npublic class LRUCacheTest {\n    @Test\n    public void testCache() throws Exception {\n        // first cache with a size of 0 to stress the remove logic and make sure we\n        // don't leak\n        LRUCache<Integer, Integer> lruCache = new LRUCache<>(0);\n        testWorker(lruCache, k -> {\n            return Integer.valueOf(1);\n        });\n        validateCache(lruCache, 0);\n        testWorker(lruCache, k -> {\n            return Integer.valueOf(k);\n        });\n        validateCache(lruCache, 0);\n        // do the same test with a cache of size 1\n        lruCache = new LRUCache<>(1);\n        testWorker(lruCache, k -> {\n            return Integer.valueOf(1);\n        });\n        validateCache(lruCache, 1);\n        assertNotNull(lruCache.get(Integer.valueOf(1)));\n        testWorker(lruCache, k -> {\n            return Integer.valueOf(k);\n        });\n        validateCache(lruCache, 1);\n        assertNull(lruCache.get(Integer.valueOf(1)));\n        // Now test a larger cache\n        lruCache = new LRUCache<>(Runtime.getRuntime().availableProcessors() * 2);\n        testWorker(lruCache, k -> {\n            return Integer.valueOf(1);\n        });\n        validateCache(lruCache, 1);\n        assertNotNull(lruCache.get(Integer.valueOf(1)));\n        testWorker(lruCache, k -> {\n            return Integer.valueOf(k);\n        });\n        validateCache(lruCache, Runtime.getRuntime().availableProcessors() * 2);\n        assertNull(lruCache.get(Integer.valueOf(1)));\n        // finally test the default cache size\n        lruCache = new LRUCache<>(2048);\n        testWorker(lruCache, k -> {\n            return Integer.valueOf(1);\n        });\n        validateCache(lruCache, 1);\n        assertNotNull(lruCache.get(Integer.valueOf(1)));\n        testWorker(lruCache, k -> {\n            return Integer.valueOf(k);\n        });\n        validateCache(lruCache, 2048);\n        assertNull(lruCache.get(Integer.valueOf(1)));\n    }\n\n    private void validateCache(LRUCache<Integer, Integer> lruCache, int size) throws Exception {\n        Field sizeField = LRUCache.class.getDeclaredField(\"size\");\n        sizeField.setAccessible(true);\n        AtomicInteger lruCacheSize = (AtomicInteger) sizeField.get(lruCache);\n        assertEquals(size, lruCacheSize.get());\n        Field cacheField = LRUCache.class.getDeclaredField(\"cache\");\n        cacheField.setAccessible(true);\n        @SuppressWarnings(\"rawtypes\")\n        Map cache = (Map) cacheField.get(lruCache);\n        assertEquals(size, cache.size());\n    }\n\n    private void testWorker(LRUCache<Integer, Integer> lruCache, Function<Integer, Integer> function) throws Exception {\n        int numThreads = Runtime.getRuntime().availableProcessors() * 2;\n        final CountDownLatch latch = new CountDownLatch(numThreads);\n        Thread[] ts = new Thread[numThreads];\n        for (int i = 0; i < numThreads; ++i) {\n            ts[i] = new Thread(() -> {\n                latch.countDown();\n                try {\n                    latch.await();\n                    for (int j = 0; j < 100000; j++) {\n                        lruCache.computeIfAbsent(function.apply(j), k -> {\n                            return k;\n                        });\n                    }\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            });\n            ts[i].start();\n        }\n        for (int i = 0; i < numThreads; ++i) {\n            ts[i].join();\n        }\n    }\n}\n", "focal_file": "package io.smallrye.graphql.execution;\n\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.Function;\n\npublic class LRUCache<K, V> {\n    private final int maxSize;\n    private final Map<K, Entry<V>> cache = new ConcurrentHashMap<>();\n    private final AtomicInteger size = new AtomicInteger();\n    private Entry<V> start;\n    private Entry<V> end;\n\n    LRUCache(int maxSize) {\n        this.maxSize = maxSize;\n    }\n\n    V get(K key) {\n        Entry<V> entry = cache.computeIfPresent(key, this::moveEntryToStart);\n        return entry == null ? null : entry.value;\n    }\n\n    V computeIfAbsent(K key, Function<K, V> valueFunction) {\n        final AtomicBoolean called = new AtomicBoolean();\n        Entry<V> entry = cache.computeIfAbsent(key, k -> {\n            called.set(true);\n            Entry<V> e = new Entry<V>(k, valueFunction.apply(k));\n            addToStart(e);\n            return e;\n        });\n        if (!called.get()) {\n            cache.computeIfPresent(key, this::moveEntryToStart);\n        } else {\n            int newSize = size.incrementAndGet();\n            if (newSize > maxSize) {\n                AtomicBoolean removed = new AtomicBoolean();\n                do {\n                    final Entry<V> entryToRemove;\n                    synchronized (this) {\n                        entryToRemove = end;\n                    }\n                    if (entryToRemove == null) {\n                        break;\n                    }\n                    cache.computeIfPresent(entryToRemove.key, (k, v) -> {\n                        if (v == entryToRemove) {\n                            removed.set(true);\n                            removeEntry(entryToRemove);\n                            return null;\n                        } else {\n                            return v;\n                        }\n                    });\n                } while (!removed.get());\n                if (removed.get()) {\n                    size.decrementAndGet();\n                }\n            }\n        }\n        return entry.value;\n    }\n\n    private synchronized Entry<V> moveEntryToStart(K key, Entry<V> entry) {\n        // If it is already at the start there is nothing to do\n        if (start != entry) {\n            removeEntry(entry);\n            addToStart(entry);\n        }\n        return entry;\n    }\n\n    private synchronized void removeEntry(Entry<V> entry) {\n        // If entry is null or was already removed, do nothing and return.\n        if (entry == null || entry.left == entry) {\n            return;\n        }\n        if (entry.left != null) {\n            entry.left.right = entry.right;\n        } else {\n            start = entry.right;\n        }\n        if (entry.right != null) {\n            entry.right.left = entry.left;\n        } else {\n            end = entry.left;\n        }\n        entry.left = entry.right = entry;\n    }\n\n    private synchronized void addToStart(Entry<V> entry) {\n        // If entry is null, do nothing and return.\n        if (entry == null) {\n            return;\n        }\n        entry.right = start;\n        entry.left = null;\n        if (start != null) {\n            start.left = entry;\n        }\n        start = entry;\n        if (end == null) {\n            end = start;\n        }\n    }\n\n    private class Entry<V> {\n        final K key;\n        V value;\n        Entry<V> left;\n        Entry<V> right;\n\n        Entry(K key, V value) {\n            this.key = key;\n            this.value = value;\n        }\n    }\n}"}
{"test_method": "@Test\n    public void shouldThrowIfStringIsEmpty() {\n        assertThatThrownBy(() -> new CharTransformer().in(\"\"))\n                .isInstanceOf(Exception.class);\n\n    }", "focal_method": "@Override\n    public Character in(final String o) {\n        return o.charAt(0);\n    }", "test_file": "package io.smallrye.graphql.transformation;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\n\nimport org.junit.jupiter.api.Test;\n\npublic class CharTransformerTest {\n\n    @Test\n    public void shouldUseFirstCharFromString() {\n        final Character actual = new CharTransformer().in(\"ab\");\n\n        assertThat(actual).isEqualTo('a');\n    }\n\n    @Test\n    public void shouldUseFirstCharFromSingleLetterString() {\n        final Character actual = new CharTransformer().in(\"a\");\n\n        assertThat(actual).isEqualTo('a');\n    }\n\n    @Test\n    public void shouldThrowIfStringIsEmpty() {\n        assertThatThrownBy(() -> new CharTransformer().in(\"\"))\n                .isInstanceOf(Exception.class);\n\n    }\n\n    @Test\n    public void shouldFormatCharAsString() {\n        final String actual = new CharTransformer().out('a');\n\n        assertThat(actual).isEqualTo(\"a\");\n    }\n\n}\n", "focal_file": "package io.smallrye.graphql.transformation;\n\n/**\n * Transforms between char and String.\n */\npublic class CharTransformer implements Transformer<Character, String> {\n\n    @Override\n    public Character in(final String o) {\n        return o.charAt(0);\n    }\n\n    @Override\n    public String out(final Character o) {\n        if (o == null) {\n            return null;\n        }\n        return String.valueOf(o);\n    }\n}\n"}
{"test_method": "@Test\n    public void shouldFormatCharAsString() {\n        final String actual = new CharTransformer().out('a');\n\n        assertThat(actual).isEqualTo(\"a\");\n    }", "focal_method": "@Override\n    public String out(final Character o) {\n        if (o == null) {\n            return null;\n        }\n        return String.valueOf(o);\n    }", "test_file": "package io.smallrye.graphql.transformation;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\n\nimport org.junit.jupiter.api.Test;\n\npublic class CharTransformerTest {\n\n    @Test\n    public void shouldUseFirstCharFromString() {\n        final Character actual = new CharTransformer().in(\"ab\");\n\n        assertThat(actual).isEqualTo('a');\n    }\n\n    @Test\n    public void shouldUseFirstCharFromSingleLetterString() {\n        final Character actual = new CharTransformer().in(\"a\");\n\n        assertThat(actual).isEqualTo('a');\n    }\n\n    @Test\n    public void shouldThrowIfStringIsEmpty() {\n        assertThatThrownBy(() -> new CharTransformer().in(\"\"))\n                .isInstanceOf(Exception.class);\n\n    }\n\n    @Test\n    public void shouldFormatCharAsString() {\n        final String actual = new CharTransformer().out('a');\n\n        assertThat(actual).isEqualTo(\"a\");\n    }\n\n}\n", "focal_file": "package io.smallrye.graphql.transformation;\n\n/**\n * Transforms between char and String.\n */\npublic class CharTransformer implements Transformer<Character, String> {\n\n    @Override\n    public Character in(final String o) {\n        return o.charAt(0);\n    }\n\n    @Override\n    public String out(final Character o) {\n        if (o == null) {\n            return null;\n        }\n        return String.valueOf(o);\n    }\n}\n"}
{"test_method": "@Test\n    void testToJsonErrors_WhenExceptionWhileValidationErrorCaught_ShouldReturnJsonBodyWithCustomExtensions() {\n        // Given\n        Map<String, Object> extensions = new HashMap<>();\n        extensions.put(\"code\", \"OPERATION_FAILED\");\n        ValidationError validationError = ValidationError.newValidationError()\n                .validationErrorType(ValidationErrorType.UnknownDirective)\n                .description(\"TestDescription\")\n                .queryPath(singletonList(\"Test-Path\"))\n                .extensions(extensions)\n                .build();\n\n        // When\n        JsonArray jsonArray = executionErrorsService.toJsonErrors(singletonList(validationError));\n\n        // Then\n        JsonObject extensionJsonObject = jsonArray.getJsonObject(0).getJsonObject(\"extensions\");\n        assertThat(extensionJsonObject.getString(\"description\")).isEqualTo(\"TestDescription\");\n        assertThat(extensionJsonObject.getString(\"validationErrorType\")).isEqualTo(\"UnknownDirective\");\n        assertThat(extensionJsonObject.getJsonArray(\"queryPath\").getString(0)).isEqualTo(\"Test-Path\");\n        assertThat(extensionJsonObject.getString(\"classification\")).isEqualTo(\"ValidationError\");\n        assertThat(extensionJsonObject.getString(\"code\")).isEqualTo(\"OPERATION_FAILED\");\n    }", "focal_method": "public JsonArray toJsonErrors(List<GraphQLError> errors) {\n        JsonArrayBuilder arrayBuilder = jsonBuilderFactory.createArrayBuilder();\n        for (GraphQLError e : errors) {\n            arrayBuilder.add(toJsonError(e));\n        }\n        return arrayBuilder.build();\n    }", "test_file": "package io.smallrye.graphql.execution.error;\n\nimport static java.util.Collections.singletonList;\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\n\nimport jakarta.json.JsonArray;\nimport jakarta.json.JsonObject;\n\nimport org.junit.jupiter.api.Test;\n\nimport graphql.ExceptionWhileDataFetching;\nimport graphql.GraphQLError;\nimport graphql.GraphqlErrorException;\nimport graphql.execution.ResultPath;\nimport graphql.language.SourceLocation;\nimport graphql.validation.ValidationError;\nimport graphql.validation.ValidationErrorType;\nimport io.smallrye.graphql.spi.config.Config;\n\n/**\n * Test for {@link ExecutionErrorsService}\n *\n * @author Nandor Holozsnyak (nandor.holozsnyak@gmail.com)\n */\nclass ExecutionErrorsServiceTest {\n\n    private final ExecutionErrorsService executionErrorsService = new ExecutionErrorsService();\n\n    @Test\n    void testToJsonErrors_WhenExceptionWhileDataFetchingErrorCaught_ShouldReturnJsonBodyWithCustomExtensions() {\n        // Given\n        Map<String, Object> extensions = new HashMap<>();\n        extensions.put(\"code\", \"OPERATION_FAILED\");\n        GraphqlErrorException graphqlErrorException = GraphqlErrorException.newErrorException()\n                .extensions(extensions)\n                .build();\n        ExceptionWhileDataFetching exceptionWhileDataFetching = new ExceptionWhileDataFetching(ResultPath.rootPath(),\n                graphqlErrorException, new SourceLocation(1, 1));\n\n        // When\n        JsonArray jsonArray = executionErrorsService.toJsonErrors(singletonList(exceptionWhileDataFetching));\n\n        // Then\n        JsonObject extensionJsonObject = jsonArray.getJsonObject(0).getJsonObject(\"extensions\");\n        assertThat(extensionJsonObject.getString(\"exception\")).isEqualTo(\"graphql.GraphqlErrorException\");\n        assertThat(extensionJsonObject.getString(\"classification\")).isEqualTo(\"DataFetchingException\");\n        assertThat(extensionJsonObject.getString(\"code\")).isEqualTo(\"OPERATION_FAILED\");\n    }\n\n    @Test\n    void testToJsonErrors_WhenExceptionWhileValidationErrorCaught_ShouldReturnJsonBodyWithCustomExtensions() {\n        // Given\n        Map<String, Object> extensions = new HashMap<>();\n        extensions.put(\"code\", \"OPERATION_FAILED\");\n        ValidationError validationError = ValidationError.newValidationError()\n                .validationErrorType(ValidationErrorType.UnknownDirective)\n                .description(\"TestDescription\")\n                .queryPath(singletonList(\"Test-Path\"))\n                .extensions(extensions)\n                .build();\n\n        // When\n        JsonArray jsonArray = executionErrorsService.toJsonErrors(singletonList(validationError));\n\n        // Then\n        JsonObject extensionJsonObject = jsonArray.getJsonObject(0).getJsonObject(\"extensions\");\n        assertThat(extensionJsonObject.getString(\"description\")).isEqualTo(\"TestDescription\");\n        assertThat(extensionJsonObject.getString(\"validationErrorType\")).isEqualTo(\"UnknownDirective\");\n        assertThat(extensionJsonObject.getJsonArray(\"queryPath\").getString(0)).isEqualTo(\"Test-Path\");\n        assertThat(extensionJsonObject.getString(\"classification\")).isEqualTo(\"ValidationError\");\n        assertThat(extensionJsonObject.getString(\"code\")).isEqualTo(\"OPERATION_FAILED\");\n    }\n\n    @Test\n    void shouldMapExceptionNameToCode() {\n        class DummyBusinessException extends RuntimeException {\n            public DummyBusinessException(String message) {\n                super(message);\n            }\n        }\n\n        JsonArray jsonArray = whenConverting(new DummyBusinessException(\"dummy-message\"));\n\n        JsonObject extensions = jsonArray.getJsonObject(0).getJsonObject(\"extensions\");\n        assertThat(extensions.getString(\"exception\")).isEqualTo(DummyBusinessException.class.getName());\n        assertThat(extensions.getString(\"code\", null)).isEqualTo(\"dummy-business\");\n    }\n\n    private JsonArray whenConverting(RuntimeException exception) {\n        ResultPath path = ResultPath.parse(\"/foo/bar\");\n        SourceLocation location = new SourceLocation(12, 34);\n        GraphQLError graphQLError = new GraphQLExceptionWhileDataFetching(path, exception, location);\n        return executionErrorsService.toJsonErrors(singletonList(graphQLError));\n    }\n\n    private Config getGraphQLConfig() {\n        return new Config() {\n            @Override\n            public boolean isPrintDataFetcherException() {\n                return true;\n            }\n\n            @Override\n            public Optional<List<String>> getErrorExtensionFields() {\n                return Optional.of(Config.ERROR_EXTENSION_ALL_KNOWN);\n            }\n\n            @Override\n            public String getName() {\n                return \"Test Execution errors config\";\n            }\n        };\n    }\n}\n", "focal_file": "package io.smallrye.graphql.execution.error;\n\nimport java.io.StringReader;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\n\nimport jakarta.json.Json;\nimport jakarta.json.JsonArray;\nimport jakarta.json.JsonArrayBuilder;\nimport jakarta.json.JsonBuilderFactory;\nimport jakarta.json.JsonObject;\nimport jakarta.json.JsonObjectBuilder;\nimport jakarta.json.JsonReader;\nimport jakarta.json.JsonReaderFactory;\nimport jakarta.json.JsonValue;\nimport jakarta.json.bind.Jsonb;\nimport jakarta.json.bind.JsonbBuilder;\nimport jakarta.json.bind.JsonbConfig;\n\nimport graphql.ExceptionWhileDataFetching;\nimport graphql.GraphQLError;\nimport graphql.validation.ValidationError;\nimport io.smallrye.graphql.spi.config.Config;\n\n/**\n * Help to create the exceptions\n *\n * @author Phillip Kruger (phillip.kruger@redhat.com)\n */\npublic class ExecutionErrorsService {\n\n    private static final JsonBuilderFactory jsonBuilderFactory = Json.createBuilderFactory(null);\n    private static final JsonReaderFactory jsonReaderFactory = Json.createReaderFactory(null);\n    private static final Jsonb JSONB = JsonbBuilder.create(new JsonbConfig()\n            .withNullValues(Boolean.TRUE)\n            .withFormatting(Boolean.TRUE));\n\n    private final ErrorExtensionProviders errorExtensionProviders = new ErrorExtensionProviders();\n\n    private final Config config = Config.get();\n\n    public JsonArray toJsonErrors(List<GraphQLError> errors) {\n        JsonArrayBuilder arrayBuilder = jsonBuilderFactory.createArrayBuilder();\n        for (GraphQLError e : errors) {\n            arrayBuilder.add(toJsonError(e));\n        }\n        return arrayBuilder.build();\n    }\n\n    private JsonObject toJsonError(GraphQLError error) {\n        String json = JSONB.toJson(error.toSpecification());\n        try (StringReader sr = new StringReader(json); JsonReader reader = jsonReaderFactory.createReader(sr)) {\n\n            JsonObject jsonErrors = reader.readObject();\n\n            JsonObjectBuilder resultBuilder = jsonBuilderFactory.createObjectBuilder(jsonErrors);\n\n            getOptionalExtensions(error).ifPresent(jsonObject -> resultBuilder.add(EXTENSIONS, jsonObject));\n            return resultBuilder.build();\n        }\n    }\n\n    private Optional<JsonObject> getOptionalExtensions(GraphQLError error) {\n        if (error instanceof ValidationError) {\n            return getValidationExtensions((ValidationError) error);\n        } else if (error instanceof ExceptionWhileDataFetching) {\n            return getDataFetchingExtensions((ExceptionWhileDataFetching) error);\n        }\n        return Optional.empty();\n    }\n\n    private Optional<JsonObject> getValidationExtensions(ValidationError error) {\n        if (config.getErrorExtensionFields().isPresent()) {\n            JsonObjectBuilder objectBuilder = jsonBuilderFactory.createObjectBuilder();\n            addKeyValue(objectBuilder, Config.ERROR_EXTENSION_DESCRIPTION, error.getDescription());\n            addKeyValue(objectBuilder, Config.ERROR_EXTENSION_VALIDATION_ERROR_TYPE, error.getValidationErrorType().toString());\n            objectBuilder.add(Config.ERROR_EXTENSION_QUERY_PATH, toJsonArray(error.getQueryPath()));\n            addKeyValue(objectBuilder, Config.ERROR_EXTENSION_CLASSIFICATION, error.getErrorType().toString());\n            Map<String, Object> extensions = error.getExtensions();\n            populateCustomExtensions(objectBuilder, extensions);\n            return Optional.of(objectBuilder.build());\n        }\n        return Optional.empty();\n    }\n\n    private Optional<JsonObject> getDataFetchingExtensions(ExceptionWhileDataFetching error) {\n        if (config.getErrorExtensionFields().isPresent()) {\n            Throwable exception = error.getException();\n\n            JsonObjectBuilder objectBuilder = jsonBuilderFactory.createObjectBuilder();\n            addKeyValue(objectBuilder, Config.ERROR_EXTENSION_CLASSIFICATION, error.getErrorType().toString());\n            addErrorExtensions(objectBuilder, exception);\n            Map<String, Object> extensions = error.getExtensions();\n            populateCustomExtensions(objectBuilder, extensions);\n\n            return Optional.of(objectBuilder.build());\n        }\n        return Optional.empty();\n    }\n\n    private void addErrorExtensions(JsonObjectBuilder objectBuilder, Throwable exception) {\n        errorExtensionProviders.get()\n                .forEach(provider -> addKeyValue(objectBuilder, provider.getKey(), provider.mapValueFrom(exception)));\n    }\n\n    private void populateCustomExtensions(JsonObjectBuilder objectBuilder, Map<String, Object> extensions) {\n        if (extensions != null) {\n            for (Map.Entry<String, Object> entry : extensions.entrySet()) {\n                if (config.getErrorExtensionFields().isEmpty()\n                        || (config.getErrorExtensionFields().isPresent()\n                                && config.getErrorExtensionFields().get().contains(entry.getKey()))) {\n                    addKeyValue(objectBuilder, entry.getKey(), entry.getValue().toString());\n                }\n            }\n        }\n    }\n\n    private JsonArray toJsonArray(List<?> list) {\n        JsonArrayBuilder arrayBuilder = jsonBuilderFactory.createArrayBuilder();\n        if (list != null && !list.isEmpty()) {\n            for (Object o : list) {\n                if (o != null)\n                    arrayBuilder.add(o.toString());\n            }\n        }\n        return arrayBuilder.build();\n    }\n\n    private void addKeyValue(JsonObjectBuilder objectBuilder, String key, String value) {\n        addKeyValue(objectBuilder, key, Json.createValue(value));\n    }\n\n    private void addKeyValue(JsonObjectBuilder objectBuilder, String key, JsonValue value) {\n        if (config.getErrorExtensionFields().isPresent()) {\n            List<String> fieldsThatShouldBeIncluded = config.getErrorExtensionFields().get();\n            if (fieldsThatShouldBeIncluded.contains(key)) {\n                objectBuilder.add(key, value);\n            }\n        } else {\n            if (value != null) {\n                objectBuilder.add(key, value);\n            }\n        }\n    }\n\n    private static final String EXTENSIONS = \"extensions\";\n\n}\n"}
{"test_method": "@Test\n    public void shouldUseFirstCharFromSingleLetterString() {\n        final Character actual = new CharTransformer().in(\"a\");\n\n        assertThat(actual).isEqualTo('a');\n    }", "focal_method": "@Override\n    public Character in(final String o) {\n        return o.charAt(0);\n    }", "test_file": "package io.smallrye.graphql.transformation;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\n\nimport org.junit.jupiter.api.Test;\n\npublic class CharTransformerTest {\n\n    @Test\n    public void shouldUseFirstCharFromString() {\n        final Character actual = new CharTransformer().in(\"ab\");\n\n        assertThat(actual).isEqualTo('a');\n    }\n\n    @Test\n    public void shouldUseFirstCharFromSingleLetterString() {\n        final Character actual = new CharTransformer().in(\"a\");\n\n        assertThat(actual).isEqualTo('a');\n    }\n\n    @Test\n    public void shouldThrowIfStringIsEmpty() {\n        assertThatThrownBy(() -> new CharTransformer().in(\"\"))\n                .isInstanceOf(Exception.class);\n\n    }\n\n    @Test\n    public void shouldFormatCharAsString() {\n        final String actual = new CharTransformer().out('a');\n\n        assertThat(actual).isEqualTo(\"a\");\n    }\n\n}\n", "focal_file": "package io.smallrye.graphql.transformation;\n\n/**\n * Transforms between char and String.\n */\npublic class CharTransformer implements Transformer<Character, String> {\n\n    @Override\n    public Character in(final String o) {\n        return o.charAt(0);\n    }\n\n    @Override\n    public String out(final Character o) {\n        if (o == null) {\n            return null;\n        }\n        return String.valueOf(o);\n    }\n}\n"}
{"test_method": "@Test\n    public void readAirKeyData() throws Exception {\n        mockMvc.perform((post(\"/api/device/air_data\")\n                .param(\"device_id\", 1129 + \"\")\n                .param(\"cmd\", \"power\")\n                .param(\"temp\", \"26\"))).andExpect(status().isOk())\n                .andDo(print());\n    }", "focal_method": "@RequestMapping(value = \"/air_data\", method = RequestMethod.POST)\n    public\n    @ResponseBody\n    ResponseHeader readAirKeyData(\n            @RequestParam(value = \"device_id\", required = true) int deviceId,\n            @RequestParam(value = \"cmd\", required = true) String cmd,\n            @RequestParam(value = \"temp\", required = true) String temp) {\n        ResponseHeader header = new ResponseHeader();\n        header.setCode(RESPONSE_OK);\n        System.out.println(deviceId + \":\" + cmd + \":\" + temp);\n        try {\n            AirKey airKey = airCmdDao.query(deviceId, cmd, temp);\n\n            if (airKey == null || airKey.getData() == null) {\n                String data = apiData.getAirData(deviceId, cmd, temp, LoadApiData.GOOGLE_FORMAT);\n                System.out.println(\"request air data:\" + cmd + \":\" + temp + \":\" + data);\n                airKey = new AirKey(deviceId, cmd, temp, data);\n                airCmdDao.insert(airKey);\n            } else {\n                header.setResult(airKey.getData());\n                return header;\n            }\n            header.setResult(airKey.getData());\n        } catch (Exception e) {\n            e.printStackTrace();\n            header.setCode(RESPONSE_EXCEPTION);\n            header.setErrorMsg(\"\u6570\u636e\u83b7\u53d6\u5f02\u5e38\");\n            return header;\n        }\n        return header;\n    }", "test_file": "package com.zjianhao.controller;\n\nimport com.zjianhao.dao.DeviceTypeDao;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\nimport org.springframework.test.context.web.WebAppConfiguration;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.web.context.WebApplicationContext;\n\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\nimport static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\nimport static org.springframework.test.web.servlet.setup.MockMvcBuilders.webAppContextSetup;\n\n/**\n * Created by \u5f20\u5efa\u6d69\uff08Clarence) on 2017-4-24 16:04.\n * the author's website:http://www.zjianhao.cn\n * the author's github: https://github.com/zhangjianhao\n */\n\n@RunWith(SpringJUnit4ClassRunner.class)\n@WebAppConfiguration\n@ContextConfiguration(locations = {\"classpath:applicationContext.xml\"})\npublic class DeviceControllerTest {\n    private MockMvc mockMvc;\n    @Autowired\n    private WebApplicationContext wac;\n\n    @Autowired\n    private DeviceTypeDao deviceTypeDao;\n\n    @Before\n    public void setup() {\n        this.mockMvc = webAppContextSetup(this.wac).build();\n    }\n\n    @Test\n    public void readDeviceType() throws Exception {\n        mockMvc.perform((get(\"/api/device/types\"))).andExpect(status().isOk())\n                .andDo(print());\n    }\n\n    @Test\n    public void readKeyData() throws Exception {\n        mockMvc.perform((post(\"/api/device/key_data\")\n                .param(\"device_id\", 1129 + \"\")\n                .param(\"cmd\", \"power\"))).andExpect(status().isOk())\n                .andDo(print());\n    }\n\n    @Test\n    public void readKeyList() throws Exception {\n        mockMvc.perform((post(\"/api/device/key_list\")\n                .param(\"device_id\", 1129 + \"\")\n        )).andExpect(status().isOk())\n                .andDo(print());\n    }\n\n    @Test\n    public void readAirKeyData() throws Exception {\n        mockMvc.perform((post(\"/api/device/air_data\")\n                .param(\"device_id\", 1129 + \"\")\n                .param(\"cmd\", \"power\")\n                .param(\"temp\", \"26\"))).andExpect(status().isOk())\n                .andDo(print());\n    }\n\n}", "focal_file": "package com.zjianhao.controller;\n\nimport com.zjianhao.dao.*;\nimport com.zjianhao.http.LoadApiData;\nimport com.zjianhao.model.*;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport java.util.List;\n\n/**\n * Created by \u5f20\u5efa\u6d69\uff08Clarence) on 2017-4-20 22:35.\n * the author's website:http://www.zjianhao.cn\n * the author's github: https://github.com/zhangjianhao\n */\n\n@Controller\n@RequestMapping(value = \"/api/device\")\npublic class DeviceController {\n\n    private static final int RESPONSE_OK = 200;\n    private static final int RESPONSE_EXCEPTION = 500;\n    @Autowired\n    private DeviceTypeDao deviceTypeDao;\n\n    @Autowired\n    private BrandDao brandDao;\n\n    @Autowired\n    private KeyTestDao keyTestDao;\n    @Autowired\n    private LoadApiData apiData;\n    @Autowired\n    private CmdDao cmdDao;\n    @Autowired\n    private AirCmdDao airCmdDao;\n\n\n    @RequestMapping(value = \"/types\", method = RequestMethod.GET)\n    public\n    @ResponseBody\n    ResponseHeader readDeviceType() {\n        ResponseHeader header = new ResponseHeader();\n        header.setCode(RESPONSE_OK);\n        List<DeviceType> deviceTypeList = deviceTypeDao.getDeviceTypeList();\n        header.setResult(deviceTypeList);\n        return header;\n    }\n\n    @RequestMapping(value = \"/brands\", method = RequestMethod.POST)\n    public\n    @ResponseBody\n    ResponseHeader readBrands(@RequestParam(value = \"type_id\", required = true) int typeid) {\n        ResponseHeader header = new ResponseHeader();\n        try {\n            header.setCode(RESPONSE_OK);\n            List<Brand> brands = brandDao.queryBrands(typeid);\n            if (brands == null || brands.size() == 0) {\n                brands = apiData.getBrand(typeid);\n                brandDao.insert(brands);\n            }\n            header.setResult(brands);\n        } catch (Exception e) {\n            e.printStackTrace();\n            header.setCode(RESPONSE_EXCEPTION);\n            header.setErrorMsg(\"\u6570\u636e\u67e5\u8be2\u9519\u8bef\");\n            return header;\n        }\n        return header;\n    }\n\n    @RequestMapping(value = \"/key_test\", method = RequestMethod.POST)\n    public\n    @ResponseBody\n    ResponseHeader readKeyTests(\n            @RequestParam(value = \"type_id\", required = true) int typeId,\n            @RequestParam(value = \"brand_id\", required = true) int brandId) {\n        ResponseHeader header = new ResponseHeader();\n        try {\n\n            List<KeyTest> keyTests = keyTestDao.queryKeyTests(typeId, brandId);\n            if (keyTests == null || keyTests.size() == 0) {\n                System.out.println(\"------start request network--------\");\n                keyTests = apiData.getKeyTestList(typeId, brandId, LoadApiData.GOOGLE_FORMAT);\n                keyTestDao.insert(keyTests);\n            }\n            header.setCode(RESPONSE_OK);\n            header.setResult(keyTests);\n        } catch (Exception e) {\n            e.printStackTrace();\n            header.setCode(RESPONSE_EXCEPTION);\n            header.setErrorMsg(\"\u6570\u636e\u83b7\u53d6\u5f02\u5e38\");\n            return header;\n        }\n        return header;\n    }\n\n    @RequestMapping(value = \"/key_list\", method = RequestMethod.POST)\n    public\n    @ResponseBody\n    ResponseHeader readKeyList(\n            @RequestParam(value = \"device_id\", required = true) int deviceId) {\n        ResponseHeader header = new ResponseHeader();\n        try {\n\n            List<Key> keys = cmdDao.queryKeyList(deviceId);\n            if (keys == null || keys.size() == 0) {\n                System.out.println(\"------start key list request network--------\");\n                keys = apiData.getkeyList(deviceId);\n                cmdDao.insert(keys);\n            }\n            header.setCode(RESPONSE_OK);\n            header.setResult(keys);\n        } catch (Exception e) {\n            e.printStackTrace();\n            header.setCode(RESPONSE_EXCEPTION);\n            header.setErrorMsg(\"\u6570\u636e\u83b7\u53d6\u5f02\u5e38\");\n            return header;\n        }\n        return header;\n    }\n\n    @RequestMapping(value = \"/key_data\", method = RequestMethod.POST)\n    public\n    @ResponseBody\n    ResponseHeader readDeviceKeyData(\n            @RequestParam(value = \"device_id\", required = true) int deviceId,\n            @RequestParam(value = \"cmd\", required = true) String cmd) {\n        ResponseHeader header = new ResponseHeader();\n        System.out.println(\"device_id:\" + deviceId + \":cmd:\" + cmd);\n        header.setCode(RESPONSE_OK);\n        try {\n            Key key = cmdDao.queryKey(deviceId, cmd);\n            if (key != null) {\n                if (key.getData() == null) {\n                    String data = apiData.getKeyData(deviceId, cmd, LoadApiData.GOOGLE_FORMAT);\n                    System.out.println(\"resut data:\" + data);\n                    key.setData(data);\n                    cmdDao.updateKey(key);\n                }\n            } else {\n                header.setResult(null);\n                return header;\n            }\n            header.setResult(key.getData());\n        } catch (Exception e) {\n            e.printStackTrace();\n            header.setCode(RESPONSE_EXCEPTION);\n            header.setErrorMsg(\"\u6570\u636e\u83b7\u53d6\u5f02\u5e38\");\n            return header;\n        }\n        return header;\n    }\n\n    @RequestMapping(value = \"/air_data\", method = RequestMethod.POST)\n    public\n    @ResponseBody\n    ResponseHeader readAirKeyData(\n            @RequestParam(value = \"device_id\", required = true) int deviceId,\n            @RequestParam(value = \"cmd\", required = true) String cmd,\n            @RequestParam(value = \"temp\", required = true) String temp) {\n        ResponseHeader header = new ResponseHeader();\n        header.setCode(RESPONSE_OK);\n        System.out.println(deviceId + \":\" + cmd + \":\" + temp);\n        try {\n            AirKey airKey = airCmdDao.query(deviceId, cmd, temp);\n\n            if (airKey == null || airKey.getData() == null) {\n                String data = apiData.getAirData(deviceId, cmd, temp, LoadApiData.GOOGLE_FORMAT);\n                System.out.println(\"request air data:\" + cmd + \":\" + temp + \":\" + data);\n                airKey = new AirKey(deviceId, cmd, temp, data);\n                airCmdDao.insert(airKey);\n            } else {\n                header.setResult(airKey.getData());\n                return header;\n            }\n            header.setResult(airKey.getData());\n        } catch (Exception e) {\n            e.printStackTrace();\n            header.setCode(RESPONSE_EXCEPTION);\n            header.setErrorMsg(\"\u6570\u636e\u83b7\u53d6\u5f02\u5e38\");\n            return header;\n        }\n        return header;\n    }\n\n\n}\n"}
{"test_method": "@Test\n    public void insert() throws Exception {\n        DeviceType deviceType = new DeviceType();\n        deviceType.setName(\"aa\");\n        deviceType.setImgUrl(\"bb\");\n        deviceType.setTypeId(1);\n        deviceTypeDao.insert(deviceType);\n\n    }", "focal_method": "@Override\n    public void insert(List<DeviceType> deviceTypes) {\n        String sql = \"insert into device_type(type_id,name,img_url) values(?,?,?)\";\n        for (DeviceType deviceType : deviceTypes) {\n            template.update(sql, new Object[]{deviceType.getTypeId(), deviceType.getName(), deviceType.getImgUrl()});\n        }\n    }", "test_file": "package com.zjianhao.dao.impl;\n\nimport com.zjianhao.model.DeviceType;\nimport org.apache.commons.dbcp.BasicDataSource;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport java.util.List;\n\n/**\n * Created by \u5f20\u5efa\u6d69\uff08Clarence) on 2017-4-19 15:27.\n * the author's website:http://www.zjianhao.cn\n * the author's github: https://github.com/zhangjianhao\n */\n\npublic class DeviceTypeDaoImplTest {\n\n    private JdbcTemplate template;\n    private DeviceTypeDaoImpl deviceTypeDao;\n\n    @Before\n    public void setUp() throws Exception {\n        template = new JdbcTemplate();\n        BasicDataSource dataSource = new BasicDataSource();\n        dataSource.setDriverClassName(\"com.mysql.jdbc.Driver\");\n        dataSource.setUrl(\"jdbc:mysql://localhost:3306/infrared?useUnicode=true&characterEncoding=UTF-8\");\n        dataSource.setUsername(\"root\");\n        dataSource.setPassword(\"101606\");\n        template.setDataSource(dataSource);\n        deviceTypeDao = new DeviceTypeDaoImpl();\n        deviceTypeDao.setTemplate(template);\n    }\n\n    @Test\n    public void insert() throws Exception {\n        DeviceType deviceType = new DeviceType();\n        deviceType.setName(\"aa\");\n        deviceType.setImgUrl(\"bb\");\n        deviceType.setTypeId(1);\n        deviceTypeDao.insert(deviceType);\n\n    }\n\n    @Test\n    public void getDeviceTypeList() throws Exception {\n\n        List<DeviceType> deviceTypeList = deviceTypeDao.getDeviceTypeList();\n        for (DeviceType deviceType : deviceTypeList) {\n            System.out.println(deviceType.getName());\n            System.out.println(deviceType.getTypeId());\n            System.out.println(deviceType.getImgUrl());\n        }\n    }\n\n}", "focal_file": "package com.zjianhao.dao.impl;\n\nimport com.zjianhao.dao.DeviceTypeDao;\nimport com.zjianhao.model.DeviceType;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.jdbc.support.rowset.SqlRowSet;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Created by \u5f20\u5efa\u6d69\uff08Clarence) on 2017-4-19 14:53.\n * the author's website:http://www.zjianhao.cn\n * the author's github: https://github.com/zhangjianhao\n */\n\npublic class DeviceTypeDaoImpl implements DeviceTypeDao {\n\n    @Autowired\n    private JdbcTemplate template;\n\n\n    public JdbcTemplate getTemplate() {\n        return template;\n    }\n\n    public void setTemplate(JdbcTemplate template) {\n        this.template = template;\n    }\n\n    @Override\n    public void insert(List<DeviceType> deviceTypes) {\n        String sql = \"insert into device_type(type_id,name,img_url) values(?,?,?)\";\n        for (DeviceType deviceType : deviceTypes) {\n            template.update(sql, new Object[]{deviceType.getTypeId(), deviceType.getName(), deviceType.getImgUrl()});\n        }\n    }\n\n    @Override\n    public void insert(DeviceType deviceType) {\n        String sql = \"insert into device_type(type_id,name,img_url) values(?,?,?)\";\n        template.update(sql, new Object[]{deviceType.getTypeId(), deviceType.getName(), deviceType.getImgUrl()});\n    }\n\n\n    @Override\n    public List<DeviceType> getDeviceTypeList() {\n        String sql = \"select * from device_type\";\n        SqlRowSet row = template.queryForRowSet(sql);\n        List<DeviceType> list = new ArrayList<>();\n        DeviceType deviceType = null;\n        while (row.next()) {\n            deviceType = new DeviceType();\n            deviceType.setTypeId(row.getInt(\"type_id\"));\n            deviceType.setName(row.getString(\"name\"));\n            deviceType.setImgUrl(row.getString(\"img_url\"));\n            list.add(deviceType);\n        }\n        return list;\n    }\n}\n"}
{"test_method": "@Test\n    public void queryBrands() throws Exception {\n        List<Brand> brands = brandDao.queryBrands(1);\n        for (Brand brand : brands) {\n            System.out.println(brand.getName());\n        }\n    }", "focal_method": "@Override\n    public List<Brand> queryBrands(int typeId) {\n        String sql = \"SELECT * FROM brand WHERE type_id = ?\";\n        SqlRowSet row = template.queryForRowSet(sql, new Object[]{typeId});\n        List<Brand> list = new ArrayList<>();\n        Brand brand = null;\n        while (row.next()) {\n            brand = new Brand();\n            brand.setTypeId(row.getInt(\"type_id\"));\n            brand.setName(row.getString(\"name\"));\n            brand.setBrandId(row.getInt(\"brand_id\"));\n            brand.setCommon(row.getInt(\"common\"));\n            list.add(brand);\n        }\n        return list;\n    }", "test_file": "package com.zjianhao.dao.impl;\n\nimport com.zjianhao.model.Brand;\nimport org.apache.commons.dbcp.BasicDataSource;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport java.util.List;\n\n/**\n * Created by \u5f20\u5efa\u6d69\uff08Clarence) on 2017-4-20 19:42.\n * the author's website:http://www.zjianhao.cn\n * the author's github: https://github.com/zhangjianhao\n */\n\npublic class BrandDaoImplTest {\n    private JdbcTemplate template;\n    private BrandDaoImpl brandDao;\n\n    @Before\n    public void setUp() throws Exception {\n        template = new JdbcTemplate();\n        BasicDataSource dataSource = new BasicDataSource();\n        dataSource.setDriverClassName(\"com.mysql.jdbc.Driver\");\n        dataSource.setUrl(\"jdbc:mysql://localhost:3306/infrared?useUnicode=true&characterEncoding=UTF-8\");\n        dataSource.setUsername(\"root\");\n        dataSource.setPassword(\"101606\");\n        template.setDataSource(dataSource);\n        brandDao = new BrandDaoImpl();\n        brandDao.setTemplate(template);\n    }\n\n\n    @Test\n    public void insert() throws Exception {\n        Brand brand = new Brand();\n        brand.setTypeId(1);\n        brand.setCommon(1);\n        brand.setName(\"brand\");\n        brand.setBrandId(2);\n        brandDao.insert(brand);\n    }\n\n    @Test\n    public void queryBrands() throws Exception {\n        List<Brand> brands = brandDao.queryBrands(1);\n        for (Brand brand : brands) {\n            System.out.println(brand.getName());\n        }\n    }\n\n}", "focal_file": "package com.zjianhao.dao.impl;\n\nimport com.zjianhao.dao.BrandDao;\nimport com.zjianhao.model.Brand;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.jdbc.support.rowset.SqlRowSet;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Created by \u5f20\u5efa\u6d69\uff08Clarence) on 2017-4-20 16:47.\n * the author's website:http://www.zjianhao.cn\n * the author's github: https://github.com/zhangjianhao\n */\n\npublic class BrandDaoImpl implements BrandDao {\n    @Autowired\n    private JdbcTemplate template;\n\n\n    public JdbcTemplate getTemplate() {\n        return template;\n    }\n\n    public void setTemplate(JdbcTemplate template) {\n        this.template = template;\n    }\n\n\n    @Override\n    public void insert(Brand brand) {\n        String sql = \"insert into brand(type_id,brand_id,common,name) values(?,?,?,?)\";\n        template.update(sql, new Object[]{brand.getTypeId(), brand.getBrandId(), brand.getCommon(), brand.getName()});\n    }\n\n    @Override\n    public void insert(List<Brand> brands) {\n        String sql = \"insert into brand(type_id,brand_id,common,name) values(?,?,?,?)\";\n        for (Brand brand : brands) {\n            template.update(sql, new Object[]{brand.getTypeId(), brand.getBrandId(), brand.getCommon(), brand.getName()});\n        }\n\n    }\n\n    @Override\n    public List<Brand> queryBrands(int typeId) {\n        String sql = \"SELECT * FROM brand WHERE type_id = ?\";\n        SqlRowSet row = template.queryForRowSet(sql, new Object[]{typeId});\n        List<Brand> list = new ArrayList<>();\n        Brand brand = null;\n        while (row.next()) {\n            brand = new Brand();\n            brand.setTypeId(row.getInt(\"type_id\"));\n            brand.setName(row.getString(\"name\"));\n            brand.setBrandId(row.getInt(\"brand_id\"));\n            brand.setCommon(row.getInt(\"common\"));\n            list.add(brand);\n        }\n        return list;\n    }\n}\n"}
{"test_method": "@Test\n    public void insert() throws Exception {\n        Brand brand = new Brand();\n        brand.setTypeId(1);\n        brand.setCommon(1);\n        brand.setName(\"brand\");\n        brand.setBrandId(2);\n        brandDao.insert(brand);\n    }", "focal_method": "@Override\n    public void insert(Brand brand) {\n        String sql = \"insert into brand(type_id,brand_id,common,name) values(?,?,?,?)\";\n        template.update(sql, new Object[]{brand.getTypeId(), brand.getBrandId(), brand.getCommon(), brand.getName()});\n    }", "test_file": "package com.zjianhao.dao.impl;\n\nimport com.zjianhao.model.Brand;\nimport org.apache.commons.dbcp.BasicDataSource;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport java.util.List;\n\n/**\n * Created by \u5f20\u5efa\u6d69\uff08Clarence) on 2017-4-20 19:42.\n * the author's website:http://www.zjianhao.cn\n * the author's github: https://github.com/zhangjianhao\n */\n\npublic class BrandDaoImplTest {\n    private JdbcTemplate template;\n    private BrandDaoImpl brandDao;\n\n    @Before\n    public void setUp() throws Exception {\n        template = new JdbcTemplate();\n        BasicDataSource dataSource = new BasicDataSource();\n        dataSource.setDriverClassName(\"com.mysql.jdbc.Driver\");\n        dataSource.setUrl(\"jdbc:mysql://localhost:3306/infrared?useUnicode=true&characterEncoding=UTF-8\");\n        dataSource.setUsername(\"root\");\n        dataSource.setPassword(\"101606\");\n        template.setDataSource(dataSource);\n        brandDao = new BrandDaoImpl();\n        brandDao.setTemplate(template);\n    }\n\n\n    @Test\n    public void insert() throws Exception {\n        Brand brand = new Brand();\n        brand.setTypeId(1);\n        brand.setCommon(1);\n        brand.setName(\"brand\");\n        brand.setBrandId(2);\n        brandDao.insert(brand);\n    }\n\n    @Test\n    public void queryBrands() throws Exception {\n        List<Brand> brands = brandDao.queryBrands(1);\n        for (Brand brand : brands) {\n            System.out.println(brand.getName());\n        }\n    }\n\n}", "focal_file": "package com.zjianhao.dao.impl;\n\nimport com.zjianhao.dao.BrandDao;\nimport com.zjianhao.model.Brand;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.jdbc.support.rowset.SqlRowSet;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Created by \u5f20\u5efa\u6d69\uff08Clarence) on 2017-4-20 16:47.\n * the author's website:http://www.zjianhao.cn\n * the author's github: https://github.com/zhangjianhao\n */\n\npublic class BrandDaoImpl implements BrandDao {\n    @Autowired\n    private JdbcTemplate template;\n\n\n    public JdbcTemplate getTemplate() {\n        return template;\n    }\n\n    public void setTemplate(JdbcTemplate template) {\n        this.template = template;\n    }\n\n\n    @Override\n    public void insert(Brand brand) {\n        String sql = \"insert into brand(type_id,brand_id,common,name) values(?,?,?,?)\";\n        template.update(sql, new Object[]{brand.getTypeId(), brand.getBrandId(), brand.getCommon(), brand.getName()});\n    }\n\n    @Override\n    public void insert(List<Brand> brands) {\n        String sql = \"insert into brand(type_id,brand_id,common,name) values(?,?,?,?)\";\n        for (Brand brand : brands) {\n            template.update(sql, new Object[]{brand.getTypeId(), brand.getBrandId(), brand.getCommon(), brand.getName()});\n        }\n\n    }\n\n    @Override\n    public List<Brand> queryBrands(int typeId) {\n        String sql = \"SELECT * FROM brand WHERE type_id = ?\";\n        SqlRowSet row = template.queryForRowSet(sql, new Object[]{typeId});\n        List<Brand> list = new ArrayList<>();\n        Brand brand = null;\n        while (row.next()) {\n            brand = new Brand();\n            brand.setTypeId(row.getInt(\"type_id\"));\n            brand.setName(row.getString(\"name\"));\n            brand.setBrandId(row.getInt(\"brand_id\"));\n            brand.setCommon(row.getInt(\"common\"));\n            list.add(brand);\n        }\n        return list;\n    }\n}\n"}
{"test_method": "@Test\n    public void insert() throws Exception {\n\n    }", "focal_method": "@Override\n    public void insert(List<Key> keys) {\n        String sql = \"INSERT INTO cmd(device_id,cmd,name,data) VALUES (?,?,?,?)\";\n        for (Key key : keys) {\n            template.update(sql, new Object[]{key.getDeviceId(), key.getCmd(), key.getName(), key.getData()});\n        }\n    }", "test_file": "package com.zjianhao.dao.impl;\n\nimport com.zjianhao.model.Key;\nimport org.apache.commons.dbcp.BasicDataSource;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport java.util.List;\n\n/**\n * Created by \u5f20\u5efa\u6d69\uff08Clarence) on 2017-4-23 21:21.\n * the author's website:http://www.zjianhao.cn\n * the author's github: https://github.com/zhangjianhao\n */\n\npublic class CmdDaoImplTest {\n    private JdbcTemplate template;\n    private CmdDaoImpl cmdDao;\n\n    @Before\n    public void setUp() throws Exception {\n        template = new JdbcTemplate();\n        BasicDataSource dataSource = new BasicDataSource();\n        dataSource.setDriverClassName(\"com.mysql.jdbc.Driver\");\n        dataSource.setUrl(\"jdbc:mysql://localhost:3306/infrared?useUnicode=true&characterEncoding=UTF-8\");\n        dataSource.setUsername(\"root\");\n        dataSource.setPassword(\"101606\");\n        template.setDataSource(dataSource);\n        cmdDao = new CmdDaoImpl();\n        cmdDao.setTemplate(template);\n    }\n\n    @Test\n    public void insert() throws Exception {\n\n    }\n\n    @Test\n    public void queryKeyList() throws Exception {\n        List<Key> keys = cmdDao.queryKeyList(1);\n        for (Key key : keys) {\n            System.out.println(key.getName() + \":\" + key.getCmd());\n        }\n    }\n\n}", "focal_file": "package com.zjianhao.dao.impl;\n\nimport com.zjianhao.dao.CmdDao;\nimport com.zjianhao.model.Key;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.jdbc.support.rowset.SqlRowSet;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Created by \u5f20\u5efa\u6d69\uff08Clarence) on 2017-4-23 21:11.\n * the author's website:http://www.zjianhao.cn\n * the author's github: https://github.com/zhangjianhao\n */\n\npublic class CmdDaoImpl implements CmdDao {\n    @Autowired\n    private JdbcTemplate template;\n\n    public JdbcTemplate getTemplate() {\n        return template;\n    }\n\n    public void setTemplate(JdbcTemplate template) {\n        this.template = template;\n    }\n\n    @Override\n    public Key queryKey(int deviceId, String cmd) {\n        String sql = \"SELECT * FROM cmd WHERE device_id = ? AND cmd = ?\";\n        SqlRowSet row = template.queryForRowSet(sql, new Object[]{deviceId, cmd});\n        Key key = null;\n        while (row.next()) {\n            key = new Key();\n            key.setId(row.getInt(\"id\"));\n            key.setDeviceId(deviceId);\n            key.setCmd(cmd);\n            key.setName(row.getString(\"name\"));\n            key.setData(row.getString(\"data\"));\n            return key;\n        }\n        return null;\n    }\n\n    @Override\n    public void updateKey(Key key) {\n        String sql = \"UPDATE cmd SET data = ? WHERE id = ?\";\n        template.update(sql, new Object[]{key.getData(), key.getId()});\n    }\n\n\n    @Override\n    public void insert(List<Key> keys) {\n        String sql = \"INSERT INTO cmd(device_id,cmd,name,data) VALUES (?,?,?,?)\";\n        for (Key key : keys) {\n            template.update(sql, new Object[]{key.getDeviceId(), key.getCmd(), key.getName(), key.getData()});\n        }\n    }\n\n    @Override\n    public List<Key> queryKeyList(int deviceId) {\n        String sql = \"select * from cmd where device_id = ?\";\n        SqlRowSet row = template.queryForRowSet(sql, new Object[]{deviceId});\n        List<Key> keys = new ArrayList<>();\n        Key key = null;\n        while (row.next()) {\n            key = new Key();\n            key.setDeviceId(deviceId);\n            key.setCmd(row.getString(\"cmd\"));\n            key.setName(row.getString(\"name\"));\n            key.setData(row.getString(\"data\"));\n            keys.add(key);\n        }\n        return keys;\n\n    }\n}\n"}
{"test_method": "@Test\n    public void queryKeyList() throws Exception {\n        List<Key> keys = cmdDao.queryKeyList(1);\n        for (Key key : keys) {\n            System.out.println(key.getName() + \":\" + key.getCmd());\n        }\n    }", "focal_method": "@Override\n    public List<Key> queryKeyList(int deviceId) {\n        String sql = \"select * from cmd where device_id = ?\";\n        SqlRowSet row = template.queryForRowSet(sql, new Object[]{deviceId});\n        List<Key> keys = new ArrayList<>();\n        Key key = null;\n        while (row.next()) {\n            key = new Key();\n            key.setDeviceId(deviceId);\n            key.setCmd(row.getString(\"cmd\"));\n            key.setName(row.getString(\"name\"));\n            key.setData(row.getString(\"data\"));\n            keys.add(key);\n        }\n        return keys;\n\n    }", "test_file": "package com.zjianhao.dao.impl;\n\nimport com.zjianhao.model.Key;\nimport org.apache.commons.dbcp.BasicDataSource;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport java.util.List;\n\n/**\n * Created by \u5f20\u5efa\u6d69\uff08Clarence) on 2017-4-23 21:21.\n * the author's website:http://www.zjianhao.cn\n * the author's github: https://github.com/zhangjianhao\n */\n\npublic class CmdDaoImplTest {\n    private JdbcTemplate template;\n    private CmdDaoImpl cmdDao;\n\n    @Before\n    public void setUp() throws Exception {\n        template = new JdbcTemplate();\n        BasicDataSource dataSource = new BasicDataSource();\n        dataSource.setDriverClassName(\"com.mysql.jdbc.Driver\");\n        dataSource.setUrl(\"jdbc:mysql://localhost:3306/infrared?useUnicode=true&characterEncoding=UTF-8\");\n        dataSource.setUsername(\"root\");\n        dataSource.setPassword(\"101606\");\n        template.setDataSource(dataSource);\n        cmdDao = new CmdDaoImpl();\n        cmdDao.setTemplate(template);\n    }\n\n    @Test\n    public void insert() throws Exception {\n\n    }\n\n    @Test\n    public void queryKeyList() throws Exception {\n        List<Key> keys = cmdDao.queryKeyList(1);\n        for (Key key : keys) {\n            System.out.println(key.getName() + \":\" + key.getCmd());\n        }\n    }\n\n}", "focal_file": "package com.zjianhao.dao.impl;\n\nimport com.zjianhao.dao.CmdDao;\nimport com.zjianhao.model.Key;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.jdbc.support.rowset.SqlRowSet;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Created by \u5f20\u5efa\u6d69\uff08Clarence) on 2017-4-23 21:11.\n * the author's website:http://www.zjianhao.cn\n * the author's github: https://github.com/zhangjianhao\n */\n\npublic class CmdDaoImpl implements CmdDao {\n    @Autowired\n    private JdbcTemplate template;\n\n    public JdbcTemplate getTemplate() {\n        return template;\n    }\n\n    public void setTemplate(JdbcTemplate template) {\n        this.template = template;\n    }\n\n    @Override\n    public Key queryKey(int deviceId, String cmd) {\n        String sql = \"SELECT * FROM cmd WHERE device_id = ? AND cmd = ?\";\n        SqlRowSet row = template.queryForRowSet(sql, new Object[]{deviceId, cmd});\n        Key key = null;\n        while (row.next()) {\n            key = new Key();\n            key.setId(row.getInt(\"id\"));\n            key.setDeviceId(deviceId);\n            key.setCmd(cmd);\n            key.setName(row.getString(\"name\"));\n            key.setData(row.getString(\"data\"));\n            return key;\n        }\n        return null;\n    }\n\n    @Override\n    public void updateKey(Key key) {\n        String sql = \"UPDATE cmd SET data = ? WHERE id = ?\";\n        template.update(sql, new Object[]{key.getData(), key.getId()});\n    }\n\n\n    @Override\n    public void insert(List<Key> keys) {\n        String sql = \"INSERT INTO cmd(device_id,cmd,name,data) VALUES (?,?,?,?)\";\n        for (Key key : keys) {\n            template.update(sql, new Object[]{key.getDeviceId(), key.getCmd(), key.getName(), key.getData()});\n        }\n    }\n\n    @Override\n    public List<Key> queryKeyList(int deviceId) {\n        String sql = \"select * from cmd where device_id = ?\";\n        SqlRowSet row = template.queryForRowSet(sql, new Object[]{deviceId});\n        List<Key> keys = new ArrayList<>();\n        Key key = null;\n        while (row.next()) {\n            key = new Key();\n            key.setDeviceId(deviceId);\n            key.setCmd(row.getString(\"cmd\"));\n            key.setName(row.getString(\"name\"));\n            key.setData(row.getString(\"data\"));\n            keys.add(key);\n        }\n        return keys;\n\n    }\n}\n"}
{"test_method": "@Test\n    public void readKeyList() throws Exception {\n        mockMvc.perform((post(\"/api/device/key_list\")\n                .param(\"device_id\", 1129 + \"\")\n        )).andExpect(status().isOk())\n                .andDo(print());\n    }", "focal_method": "@RequestMapping(value = \"/key_list\", method = RequestMethod.POST)\n    public\n    @ResponseBody\n    ResponseHeader readKeyList(\n            @RequestParam(value = \"device_id\", required = true) int deviceId) {\n        ResponseHeader header = new ResponseHeader();\n        try {\n\n            List<Key> keys = cmdDao.queryKeyList(deviceId);\n            if (keys == null || keys.size() == 0) {\n                System.out.println(\"------start key list request network--------\");\n                keys = apiData.getkeyList(deviceId);\n                cmdDao.insert(keys);\n            }\n            header.setCode(RESPONSE_OK);\n            header.setResult(keys);\n        } catch (Exception e) {\n            e.printStackTrace();\n            header.setCode(RESPONSE_EXCEPTION);\n            header.setErrorMsg(\"\u6570\u636e\u83b7\u53d6\u5f02\u5e38\");\n            return header;\n        }\n        return header;\n    }", "test_file": "package com.zjianhao.controller;\n\nimport com.zjianhao.dao.DeviceTypeDao;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\nimport org.springframework.test.context.web.WebAppConfiguration;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.web.context.WebApplicationContext;\n\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\nimport static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\nimport static org.springframework.test.web.servlet.setup.MockMvcBuilders.webAppContextSetup;\n\n/**\n * Created by \u5f20\u5efa\u6d69\uff08Clarence) on 2017-4-24 16:04.\n * the author's website:http://www.zjianhao.cn\n * the author's github: https://github.com/zhangjianhao\n */\n\n@RunWith(SpringJUnit4ClassRunner.class)\n@WebAppConfiguration\n@ContextConfiguration(locations = {\"classpath:applicationContext.xml\"})\npublic class DeviceControllerTest {\n    private MockMvc mockMvc;\n    @Autowired\n    private WebApplicationContext wac;\n\n    @Autowired\n    private DeviceTypeDao deviceTypeDao;\n\n    @Before\n    public void setup() {\n        this.mockMvc = webAppContextSetup(this.wac).build();\n    }\n\n    @Test\n    public void readDeviceType() throws Exception {\n        mockMvc.perform((get(\"/api/device/types\"))).andExpect(status().isOk())\n                .andDo(print());\n    }\n\n    @Test\n    public void readKeyData() throws Exception {\n        mockMvc.perform((post(\"/api/device/key_data\")\n                .param(\"device_id\", 1129 + \"\")\n                .param(\"cmd\", \"power\"))).andExpect(status().isOk())\n                .andDo(print());\n    }\n\n    @Test\n    public void readKeyList() throws Exception {\n        mockMvc.perform((post(\"/api/device/key_list\")\n                .param(\"device_id\", 1129 + \"\")\n        )).andExpect(status().isOk())\n                .andDo(print());\n    }\n\n    @Test\n    public void readAirKeyData() throws Exception {\n        mockMvc.perform((post(\"/api/device/air_data\")\n                .param(\"device_id\", 1129 + \"\")\n                .param(\"cmd\", \"power\")\n                .param(\"temp\", \"26\"))).andExpect(status().isOk())\n                .andDo(print());\n    }\n\n}", "focal_file": "package com.zjianhao.controller;\n\nimport com.zjianhao.dao.*;\nimport com.zjianhao.http.LoadApiData;\nimport com.zjianhao.model.*;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport java.util.List;\n\n/**\n * Created by \u5f20\u5efa\u6d69\uff08Clarence) on 2017-4-20 22:35.\n * the author's website:http://www.zjianhao.cn\n * the author's github: https://github.com/zhangjianhao\n */\n\n@Controller\n@RequestMapping(value = \"/api/device\")\npublic class DeviceController {\n\n    private static final int RESPONSE_OK = 200;\n    private static final int RESPONSE_EXCEPTION = 500;\n    @Autowired\n    private DeviceTypeDao deviceTypeDao;\n\n    @Autowired\n    private BrandDao brandDao;\n\n    @Autowired\n    private KeyTestDao keyTestDao;\n    @Autowired\n    private LoadApiData apiData;\n    @Autowired\n    private CmdDao cmdDao;\n    @Autowired\n    private AirCmdDao airCmdDao;\n\n\n    @RequestMapping(value = \"/types\", method = RequestMethod.GET)\n    public\n    @ResponseBody\n    ResponseHeader readDeviceType() {\n        ResponseHeader header = new ResponseHeader();\n        header.setCode(RESPONSE_OK);\n        List<DeviceType> deviceTypeList = deviceTypeDao.getDeviceTypeList();\n        header.setResult(deviceTypeList);\n        return header;\n    }\n\n    @RequestMapping(value = \"/brands\", method = RequestMethod.POST)\n    public\n    @ResponseBody\n    ResponseHeader readBrands(@RequestParam(value = \"type_id\", required = true) int typeid) {\n        ResponseHeader header = new ResponseHeader();\n        try {\n            header.setCode(RESPONSE_OK);\n            List<Brand> brands = brandDao.queryBrands(typeid);\n            if (brands == null || brands.size() == 0) {\n                brands = apiData.getBrand(typeid);\n                brandDao.insert(brands);\n            }\n            header.setResult(brands);\n        } catch (Exception e) {\n            e.printStackTrace();\n            header.setCode(RESPONSE_EXCEPTION);\n            header.setErrorMsg(\"\u6570\u636e\u67e5\u8be2\u9519\u8bef\");\n            return header;\n        }\n        return header;\n    }\n\n    @RequestMapping(value = \"/key_test\", method = RequestMethod.POST)\n    public\n    @ResponseBody\n    ResponseHeader readKeyTests(\n            @RequestParam(value = \"type_id\", required = true) int typeId,\n            @RequestParam(value = \"brand_id\", required = true) int brandId) {\n        ResponseHeader header = new ResponseHeader();\n        try {\n\n            List<KeyTest> keyTests = keyTestDao.queryKeyTests(typeId, brandId);\n            if (keyTests == null || keyTests.size() == 0) {\n                System.out.println(\"------start request network--------\");\n                keyTests = apiData.getKeyTestList(typeId, brandId, LoadApiData.GOOGLE_FORMAT);\n                keyTestDao.insert(keyTests);\n            }\n            header.setCode(RESPONSE_OK);\n            header.setResult(keyTests);\n        } catch (Exception e) {\n            e.printStackTrace();\n            header.setCode(RESPONSE_EXCEPTION);\n            header.setErrorMsg(\"\u6570\u636e\u83b7\u53d6\u5f02\u5e38\");\n            return header;\n        }\n        return header;\n    }\n\n    @RequestMapping(value = \"/key_list\", method = RequestMethod.POST)\n    public\n    @ResponseBody\n    ResponseHeader readKeyList(\n            @RequestParam(value = \"device_id\", required = true) int deviceId) {\n        ResponseHeader header = new ResponseHeader();\n        try {\n\n            List<Key> keys = cmdDao.queryKeyList(deviceId);\n            if (keys == null || keys.size() == 0) {\n                System.out.println(\"------start key list request network--------\");\n                keys = apiData.getkeyList(deviceId);\n                cmdDao.insert(keys);\n            }\n            header.setCode(RESPONSE_OK);\n            header.setResult(keys);\n        } catch (Exception e) {\n            e.printStackTrace();\n            header.setCode(RESPONSE_EXCEPTION);\n            header.setErrorMsg(\"\u6570\u636e\u83b7\u53d6\u5f02\u5e38\");\n            return header;\n        }\n        return header;\n    }\n\n    @RequestMapping(value = \"/key_data\", method = RequestMethod.POST)\n    public\n    @ResponseBody\n    ResponseHeader readDeviceKeyData(\n            @RequestParam(value = \"device_id\", required = true) int deviceId,\n            @RequestParam(value = \"cmd\", required = true) String cmd) {\n        ResponseHeader header = new ResponseHeader();\n        System.out.println(\"device_id:\" + deviceId + \":cmd:\" + cmd);\n        header.setCode(RESPONSE_OK);\n        try {\n            Key key = cmdDao.queryKey(deviceId, cmd);\n            if (key != null) {\n                if (key.getData() == null) {\n                    String data = apiData.getKeyData(deviceId, cmd, LoadApiData.GOOGLE_FORMAT);\n                    System.out.println(\"resut data:\" + data);\n                    key.setData(data);\n                    cmdDao.updateKey(key);\n                }\n            } else {\n                header.setResult(null);\n                return header;\n            }\n            header.setResult(key.getData());\n        } catch (Exception e) {\n            e.printStackTrace();\n            header.setCode(RESPONSE_EXCEPTION);\n            header.setErrorMsg(\"\u6570\u636e\u83b7\u53d6\u5f02\u5e38\");\n            return header;\n        }\n        return header;\n    }\n\n    @RequestMapping(value = \"/air_data\", method = RequestMethod.POST)\n    public\n    @ResponseBody\n    ResponseHeader readAirKeyData(\n            @RequestParam(value = \"device_id\", required = true) int deviceId,\n            @RequestParam(value = \"cmd\", required = true) String cmd,\n            @RequestParam(value = \"temp\", required = true) String temp) {\n        ResponseHeader header = new ResponseHeader();\n        header.setCode(RESPONSE_OK);\n        System.out.println(deviceId + \":\" + cmd + \":\" + temp);\n        try {\n            AirKey airKey = airCmdDao.query(deviceId, cmd, temp);\n\n            if (airKey == null || airKey.getData() == null) {\n                String data = apiData.getAirData(deviceId, cmd, temp, LoadApiData.GOOGLE_FORMAT);\n                System.out.println(\"request air data:\" + cmd + \":\" + temp + \":\" + data);\n                airKey = new AirKey(deviceId, cmd, temp, data);\n                airCmdDao.insert(airKey);\n            } else {\n                header.setResult(airKey.getData());\n                return header;\n            }\n            header.setResult(airKey.getData());\n        } catch (Exception e) {\n            e.printStackTrace();\n            header.setCode(RESPONSE_EXCEPTION);\n            header.setErrorMsg(\"\u6570\u636e\u83b7\u53d6\u5f02\u5e38\");\n            return header;\n        }\n        return header;\n    }\n\n\n}\n"}
{"test_method": "@Test\n    public void readDeviceType() throws Exception {\n        mockMvc.perform((get(\"/api/device/types\"))).andExpect(status().isOk())\n                .andDo(print());\n    }", "focal_method": "@RequestMapping(value = \"/types\", method = RequestMethod.GET)\n    public\n    @ResponseBody\n    ResponseHeader readDeviceType() {\n        ResponseHeader header = new ResponseHeader();\n        header.setCode(RESPONSE_OK);\n        List<DeviceType> deviceTypeList = deviceTypeDao.getDeviceTypeList();\n        header.setResult(deviceTypeList);\n        return header;\n    }", "test_file": "package com.zjianhao.controller;\n\nimport com.zjianhao.dao.DeviceTypeDao;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\nimport org.springframework.test.context.web.WebAppConfiguration;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.web.context.WebApplicationContext;\n\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\nimport static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\nimport static org.springframework.test.web.servlet.setup.MockMvcBuilders.webAppContextSetup;\n\n/**\n * Created by \u5f20\u5efa\u6d69\uff08Clarence) on 2017-4-24 16:04.\n * the author's website:http://www.zjianhao.cn\n * the author's github: https://github.com/zhangjianhao\n */\n\n@RunWith(SpringJUnit4ClassRunner.class)\n@WebAppConfiguration\n@ContextConfiguration(locations = {\"classpath:applicationContext.xml\"})\npublic class DeviceControllerTest {\n    private MockMvc mockMvc;\n    @Autowired\n    private WebApplicationContext wac;\n\n    @Autowired\n    private DeviceTypeDao deviceTypeDao;\n\n    @Before\n    public void setup() {\n        this.mockMvc = webAppContextSetup(this.wac).build();\n    }\n\n    @Test\n    public void readDeviceType() throws Exception {\n        mockMvc.perform((get(\"/api/device/types\"))).andExpect(status().isOk())\n                .andDo(print());\n    }\n\n    @Test\n    public void readKeyData() throws Exception {\n        mockMvc.perform((post(\"/api/device/key_data\")\n                .param(\"device_id\", 1129 + \"\")\n                .param(\"cmd\", \"power\"))).andExpect(status().isOk())\n                .andDo(print());\n    }\n\n    @Test\n    public void readKeyList() throws Exception {\n        mockMvc.perform((post(\"/api/device/key_list\")\n                .param(\"device_id\", 1129 + \"\")\n        )).andExpect(status().isOk())\n                .andDo(print());\n    }\n\n    @Test\n    public void readAirKeyData() throws Exception {\n        mockMvc.perform((post(\"/api/device/air_data\")\n                .param(\"device_id\", 1129 + \"\")\n                .param(\"cmd\", \"power\")\n                .param(\"temp\", \"26\"))).andExpect(status().isOk())\n                .andDo(print());\n    }\n\n}", "focal_file": "package com.zjianhao.controller;\n\nimport com.zjianhao.dao.*;\nimport com.zjianhao.http.LoadApiData;\nimport com.zjianhao.model.*;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport java.util.List;\n\n/**\n * Created by \u5f20\u5efa\u6d69\uff08Clarence) on 2017-4-20 22:35.\n * the author's website:http://www.zjianhao.cn\n * the author's github: https://github.com/zhangjianhao\n */\n\n@Controller\n@RequestMapping(value = \"/api/device\")\npublic class DeviceController {\n\n    private static final int RESPONSE_OK = 200;\n    private static final int RESPONSE_EXCEPTION = 500;\n    @Autowired\n    private DeviceTypeDao deviceTypeDao;\n\n    @Autowired\n    private BrandDao brandDao;\n\n    @Autowired\n    private KeyTestDao keyTestDao;\n    @Autowired\n    private LoadApiData apiData;\n    @Autowired\n    private CmdDao cmdDao;\n    @Autowired\n    private AirCmdDao airCmdDao;\n\n\n    @RequestMapping(value = \"/types\", method = RequestMethod.GET)\n    public\n    @ResponseBody\n    ResponseHeader readDeviceType() {\n        ResponseHeader header = new ResponseHeader();\n        header.setCode(RESPONSE_OK);\n        List<DeviceType> deviceTypeList = deviceTypeDao.getDeviceTypeList();\n        header.setResult(deviceTypeList);\n        return header;\n    }\n\n    @RequestMapping(value = \"/brands\", method = RequestMethod.POST)\n    public\n    @ResponseBody\n    ResponseHeader readBrands(@RequestParam(value = \"type_id\", required = true) int typeid) {\n        ResponseHeader header = new ResponseHeader();\n        try {\n            header.setCode(RESPONSE_OK);\n            List<Brand> brands = brandDao.queryBrands(typeid);\n            if (brands == null || brands.size() == 0) {\n                brands = apiData.getBrand(typeid);\n                brandDao.insert(brands);\n            }\n            header.setResult(brands);\n        } catch (Exception e) {\n            e.printStackTrace();\n            header.setCode(RESPONSE_EXCEPTION);\n            header.setErrorMsg(\"\u6570\u636e\u67e5\u8be2\u9519\u8bef\");\n            return header;\n        }\n        return header;\n    }\n\n    @RequestMapping(value = \"/key_test\", method = RequestMethod.POST)\n    public\n    @ResponseBody\n    ResponseHeader readKeyTests(\n            @RequestParam(value = \"type_id\", required = true) int typeId,\n            @RequestParam(value = \"brand_id\", required = true) int brandId) {\n        ResponseHeader header = new ResponseHeader();\n        try {\n\n            List<KeyTest> keyTests = keyTestDao.queryKeyTests(typeId, brandId);\n            if (keyTests == null || keyTests.size() == 0) {\n                System.out.println(\"------start request network--------\");\n                keyTests = apiData.getKeyTestList(typeId, brandId, LoadApiData.GOOGLE_FORMAT);\n                keyTestDao.insert(keyTests);\n            }\n            header.setCode(RESPONSE_OK);\n            header.setResult(keyTests);\n        } catch (Exception e) {\n            e.printStackTrace();\n            header.setCode(RESPONSE_EXCEPTION);\n            header.setErrorMsg(\"\u6570\u636e\u83b7\u53d6\u5f02\u5e38\");\n            return header;\n        }\n        return header;\n    }\n\n    @RequestMapping(value = \"/key_list\", method = RequestMethod.POST)\n    public\n    @ResponseBody\n    ResponseHeader readKeyList(\n            @RequestParam(value = \"device_id\", required = true) int deviceId) {\n        ResponseHeader header = new ResponseHeader();\n        try {\n\n            List<Key> keys = cmdDao.queryKeyList(deviceId);\n            if (keys == null || keys.size() == 0) {\n                System.out.println(\"------start key list request network--------\");\n                keys = apiData.getkeyList(deviceId);\n                cmdDao.insert(keys);\n            }\n            header.setCode(RESPONSE_OK);\n            header.setResult(keys);\n        } catch (Exception e) {\n            e.printStackTrace();\n            header.setCode(RESPONSE_EXCEPTION);\n            header.setErrorMsg(\"\u6570\u636e\u83b7\u53d6\u5f02\u5e38\");\n            return header;\n        }\n        return header;\n    }\n\n    @RequestMapping(value = \"/key_data\", method = RequestMethod.POST)\n    public\n    @ResponseBody\n    ResponseHeader readDeviceKeyData(\n            @RequestParam(value = \"device_id\", required = true) int deviceId,\n            @RequestParam(value = \"cmd\", required = true) String cmd) {\n        ResponseHeader header = new ResponseHeader();\n        System.out.println(\"device_id:\" + deviceId + \":cmd:\" + cmd);\n        header.setCode(RESPONSE_OK);\n        try {\n            Key key = cmdDao.queryKey(deviceId, cmd);\n            if (key != null) {\n                if (key.getData() == null) {\n                    String data = apiData.getKeyData(deviceId, cmd, LoadApiData.GOOGLE_FORMAT);\n                    System.out.println(\"resut data:\" + data);\n                    key.setData(data);\n                    cmdDao.updateKey(key);\n                }\n            } else {\n                header.setResult(null);\n                return header;\n            }\n            header.setResult(key.getData());\n        } catch (Exception e) {\n            e.printStackTrace();\n            header.setCode(RESPONSE_EXCEPTION);\n            header.setErrorMsg(\"\u6570\u636e\u83b7\u53d6\u5f02\u5e38\");\n            return header;\n        }\n        return header;\n    }\n\n    @RequestMapping(value = \"/air_data\", method = RequestMethod.POST)\n    public\n    @ResponseBody\n    ResponseHeader readAirKeyData(\n            @RequestParam(value = \"device_id\", required = true) int deviceId,\n            @RequestParam(value = \"cmd\", required = true) String cmd,\n            @RequestParam(value = \"temp\", required = true) String temp) {\n        ResponseHeader header = new ResponseHeader();\n        header.setCode(RESPONSE_OK);\n        System.out.println(deviceId + \":\" + cmd + \":\" + temp);\n        try {\n            AirKey airKey = airCmdDao.query(deviceId, cmd, temp);\n\n            if (airKey == null || airKey.getData() == null) {\n                String data = apiData.getAirData(deviceId, cmd, temp, LoadApiData.GOOGLE_FORMAT);\n                System.out.println(\"request air data:\" + cmd + \":\" + temp + \":\" + data);\n                airKey = new AirKey(deviceId, cmd, temp, data);\n                airCmdDao.insert(airKey);\n            } else {\n                header.setResult(airKey.getData());\n                return header;\n            }\n            header.setResult(airKey.getData());\n        } catch (Exception e) {\n            e.printStackTrace();\n            header.setCode(RESPONSE_EXCEPTION);\n            header.setErrorMsg(\"\u6570\u636e\u83b7\u53d6\u5f02\u5e38\");\n            return header;\n        }\n        return header;\n    }\n\n\n}\n"}
{"test_method": "@Test\n    public void getDeviceTypeList() throws Exception {\n\n        List<DeviceType> deviceTypeList = deviceTypeDao.getDeviceTypeList();\n        for (DeviceType deviceType : deviceTypeList) {\n            System.out.println(deviceType.getName());\n            System.out.println(deviceType.getTypeId());\n            System.out.println(deviceType.getImgUrl());\n        }\n    }", "focal_method": "@Override\n    public List<DeviceType> getDeviceTypeList() {\n        String sql = \"select * from device_type\";\n        SqlRowSet row = template.queryForRowSet(sql);\n        List<DeviceType> list = new ArrayList<>();\n        DeviceType deviceType = null;\n        while (row.next()) {\n            deviceType = new DeviceType();\n            deviceType.setTypeId(row.getInt(\"type_id\"));\n            deviceType.setName(row.getString(\"name\"));\n            deviceType.setImgUrl(row.getString(\"img_url\"));\n            list.add(deviceType);\n        }\n        return list;\n    }", "test_file": "package com.zjianhao.dao.impl;\n\nimport com.zjianhao.model.DeviceType;\nimport org.apache.commons.dbcp.BasicDataSource;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport java.util.List;\n\n/**\n * Created by \u5f20\u5efa\u6d69\uff08Clarence) on 2017-4-19 15:27.\n * the author's website:http://www.zjianhao.cn\n * the author's github: https://github.com/zhangjianhao\n */\n\npublic class DeviceTypeDaoImplTest {\n\n    private JdbcTemplate template;\n    private DeviceTypeDaoImpl deviceTypeDao;\n\n    @Before\n    public void setUp() throws Exception {\n        template = new JdbcTemplate();\n        BasicDataSource dataSource = new BasicDataSource();\n        dataSource.setDriverClassName(\"com.mysql.jdbc.Driver\");\n        dataSource.setUrl(\"jdbc:mysql://localhost:3306/infrared?useUnicode=true&characterEncoding=UTF-8\");\n        dataSource.setUsername(\"root\");\n        dataSource.setPassword(\"101606\");\n        template.setDataSource(dataSource);\n        deviceTypeDao = new DeviceTypeDaoImpl();\n        deviceTypeDao.setTemplate(template);\n    }\n\n    @Test\n    public void insert() throws Exception {\n        DeviceType deviceType = new DeviceType();\n        deviceType.setName(\"aa\");\n        deviceType.setImgUrl(\"bb\");\n        deviceType.setTypeId(1);\n        deviceTypeDao.insert(deviceType);\n\n    }\n\n    @Test\n    public void getDeviceTypeList() throws Exception {\n\n        List<DeviceType> deviceTypeList = deviceTypeDao.getDeviceTypeList();\n        for (DeviceType deviceType : deviceTypeList) {\n            System.out.println(deviceType.getName());\n            System.out.println(deviceType.getTypeId());\n            System.out.println(deviceType.getImgUrl());\n        }\n    }\n\n}", "focal_file": "package com.zjianhao.dao.impl;\n\nimport com.zjianhao.dao.DeviceTypeDao;\nimport com.zjianhao.model.DeviceType;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.jdbc.support.rowset.SqlRowSet;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Created by \u5f20\u5efa\u6d69\uff08Clarence) on 2017-4-19 14:53.\n * the author's website:http://www.zjianhao.cn\n * the author's github: https://github.com/zhangjianhao\n */\n\npublic class DeviceTypeDaoImpl implements DeviceTypeDao {\n\n    @Autowired\n    private JdbcTemplate template;\n\n\n    public JdbcTemplate getTemplate() {\n        return template;\n    }\n\n    public void setTemplate(JdbcTemplate template) {\n        this.template = template;\n    }\n\n    @Override\n    public void insert(List<DeviceType> deviceTypes) {\n        String sql = \"insert into device_type(type_id,name,img_url) values(?,?,?)\";\n        for (DeviceType deviceType : deviceTypes) {\n            template.update(sql, new Object[]{deviceType.getTypeId(), deviceType.getName(), deviceType.getImgUrl()});\n        }\n    }\n\n    @Override\n    public void insert(DeviceType deviceType) {\n        String sql = \"insert into device_type(type_id,name,img_url) values(?,?,?)\";\n        template.update(sql, new Object[]{deviceType.getTypeId(), deviceType.getName(), deviceType.getImgUrl()});\n    }\n\n\n    @Override\n    public List<DeviceType> getDeviceTypeList() {\n        String sql = \"select * from device_type\";\n        SqlRowSet row = template.queryForRowSet(sql);\n        List<DeviceType> list = new ArrayList<>();\n        DeviceType deviceType = null;\n        while (row.next()) {\n            deviceType = new DeviceType();\n            deviceType.setTypeId(row.getInt(\"type_id\"));\n            deviceType.setName(row.getString(\"name\"));\n            deviceType.setImgUrl(row.getString(\"img_url\"));\n            list.add(deviceType);\n        }\n        return list;\n    }\n}\n"}
{"test_method": "@Test\n    void cantOrderForNonExistentCustomer() {\n        // given\n        int customerId = 666;\n        var quantities = Map.of(2, 1);\n\n        // when\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addOrder(customerId, quantities));\n    }", "focal_method": "public void addOrder(int customerId, Map<Integer, Integer> quantities) throws WarehouseException {\n        if (quantities.isEmpty()) {\n            throw new IllegalArgumentException(\"There has to items in the order, it cannot be empty.\");\n        }\n        Customer customer = customerDao.getCustomer(customerId);\n        if (customer == null) {\n            throw new IllegalArgumentException(\"Unknown customer ID: \" + customerId);\n        }\n        Map<Product, Integer> mappedQuantities = new HashMap<>();\n        for (var entry : quantities.entrySet()) {\n            Product product = productDao.getProduct(entry.getKey());\n            if (product == null) {\n                throw new IllegalArgumentException(\"Unknown product ID: \" + entry.getKey());\n            }\n            int quantity = entry.getValue();\n            if (quantity < 1) {\n                throw new IllegalArgumentException(\"Ordered quantity must be greater than 0.\");\n            }\n            mappedQuantities.put(product, quantity);\n        }\n        inventoryDao.updateStock(mappedQuantities);\n        Order order = new Order(customer, mappedQuantities);\n        // TODO: updating stock and adding order should be atomic.\n        orderDao.addOrder(order);\n    }", "test_file": "package com.example.warehouse;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Collection;\nimport java.util.Map;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nclass WarehouseTest {\n\n    private Warehouse warehouse;\n\n    @BeforeEach\n    void beforeEach() {\n        warehouse = Warehouses.newInMemoryWarehouse(1);\n    }\n\n    @Test\n    void canAddNewProduct() throws Exception {\n        // given\n        Collection<Product> productsBefore = warehouse.getProducts();\n\n        // and\n        String name = \"test\";\n        int price = 123;\n\n        // when\n        warehouse.addProduct(name, price);\n\n        // then\n        Collection<Product> productsAfter = warehouse.getProducts();\n        assertEquals(productsBefore.size() + 1, productsAfter.size());\n    }\n\n    @Test\n    void cantAddProductWithNegativePrice() {\n        // given\n        String name = \"test\";\n        int price = -123;\n\n        // when/then\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addProduct(name, price));\n    }\n\n    @Test\n    void canPlaceCorrectOrder() throws Exception {\n        // given\n        Collection<Order> ordersBefore = warehouse.getOrders();\n        int customerId = 12;\n        var quantities = Map.of(2, 1);\n\n        // when\n        warehouse.addOrder(customerId, quantities);\n\n        // then\n        Collection<Order> ordersAfter = warehouse.getOrders();\n        assertEquals(ordersBefore.size() + 1, ordersAfter.size());\n    }\n\n    @Test\n    void cantOrderForNonExistentCustomer() {\n        // given\n        int customerId = 666;\n        var quantities = Map.of(2, 1);\n\n        // when\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addOrder(customerId, quantities));\n    }\n\n    @Test\n    void cantOrderMoreThanAvailableStock() {\n        // given\n        int customerId = 12;\n        var quantities = Map.of(2, 3);\n\n        // when\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addOrder(customerId, quantities));\n    }\n}\n", "focal_file": "package com.example.warehouse;\n\nimport com.example.warehouse.dal.CustomerDao;\nimport com.example.warehouse.dal.InventoryDao;\nimport com.example.warehouse.dal.OrderDao;\nimport com.example.warehouse.dal.ProductDao;\n\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport static java.util.stream.Collectors.toUnmodifiableList;\n\npublic final class Warehouse {\n\n    private final ProductDao productDao;\n    private final CustomerDao customerDao;\n    private final InventoryDao inventoryDao;\n    private final OrderDao orderDao;\n\n    private final ReportGeneration reportGeneration;\n\n    public Warehouse(\n        ProductDao productDao,\n        CustomerDao customerDao,\n        InventoryDao inventoryDao,\n        OrderDao orderDao,\n        ReportGeneration reportGeneration) {\n        this.productDao = productDao;\n        this.customerDao = customerDao;\n        this.inventoryDao = inventoryDao;\n        this.orderDao = orderDao;\n        this.reportGeneration = reportGeneration;\n    }\n\n    public Collection<Product> getProducts() throws WarehouseException {\n        return productDao.getProducts()\n            .stream()\n            .sorted(Comparator.comparing(Product::getId))\n            .collect(toUnmodifiableList());\n    }\n\n    public Collection<Customer> getCustomers() throws WarehouseException {\n        return customerDao.getCustomers()\n            .stream()\n            .sorted(Comparator.comparing(Customer::getId))\n            .collect(toUnmodifiableList());\n    }\n\n    public Collection<Order> getOrders() throws WarehouseException {\n        return orderDao.getOrders()\n            .stream()\n            .sorted(Comparator.comparing(Order::getId))\n            .collect(toUnmodifiableList());\n    }\n\n    public void addProduct(String name, int price) throws WarehouseException {\n        if (price < 0) {\n            throw new IllegalArgumentException(\"The product's price cannot be negative.\");\n        }\n        Product product = new Product(name, price);\n        productDao.addProduct(product);\n    }\n\n    public void addOrder(int customerId, Map<Integer, Integer> quantities) throws WarehouseException {\n        if (quantities.isEmpty()) {\n            throw new IllegalArgumentException(\"There has to items in the order, it cannot be empty.\");\n        }\n        Customer customer = customerDao.getCustomer(customerId);\n        if (customer == null) {\n            throw new IllegalArgumentException(\"Unknown customer ID: \" + customerId);\n        }\n        Map<Product, Integer> mappedQuantities = new HashMap<>();\n        for (var entry : quantities.entrySet()) {\n            Product product = productDao.getProduct(entry.getKey());\n            if (product == null) {\n                throw new IllegalArgumentException(\"Unknown product ID: \" + entry.getKey());\n            }\n            int quantity = entry.getValue();\n            if (quantity < 1) {\n                throw new IllegalArgumentException(\"Ordered quantity must be greater than 0.\");\n            }\n            mappedQuantities.put(product, quantity);\n        }\n        inventoryDao.updateStock(mappedQuantities);\n        Order order = new Order(customer, mappedQuantities);\n        // TODO: updating stock and adding order should be atomic.\n        orderDao.addOrder(order);\n    }\n\n    public Report generateReport(Report.Type type) throws WarehouseException {\n        return reportGeneration.generateReport(type);\n    }\n}\n"}
{"test_method": "@Test\n    void cantOrderMoreThanAvailableStock() {\n        // given\n        int customerId = 12;\n        var quantities = Map.of(2, 3);\n\n        // when\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addOrder(customerId, quantities));\n    }", "focal_method": "public void addOrder(int customerId, Map<Integer, Integer> quantities) throws WarehouseException {\n        if (quantities.isEmpty()) {\n            throw new IllegalArgumentException(\"There has to items in the order, it cannot be empty.\");\n        }\n        Customer customer = customerDao.getCustomer(customerId);\n        if (customer == null) {\n            throw new IllegalArgumentException(\"Unknown customer ID: \" + customerId);\n        }\n        Map<Product, Integer> mappedQuantities = new HashMap<>();\n        for (var entry : quantities.entrySet()) {\n            Product product = productDao.getProduct(entry.getKey());\n            if (product == null) {\n                throw new IllegalArgumentException(\"Unknown product ID: \" + entry.getKey());\n            }\n            int quantity = entry.getValue();\n            if (quantity < 1) {\n                throw new IllegalArgumentException(\"Ordered quantity must be greater than 0.\");\n            }\n            mappedQuantities.put(product, quantity);\n        }\n        inventoryDao.updateStock(mappedQuantities);\n        Order order = new Order(customer, mappedQuantities);\n        // TODO: updating stock and adding order should be atomic.\n        orderDao.addOrder(order);\n    }", "test_file": "package com.example.warehouse;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Collection;\nimport java.util.Map;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nclass WarehouseTest {\n\n    private Warehouse warehouse;\n\n    @BeforeEach\n    void beforeEach() {\n        warehouse = Warehouses.newInMemoryWarehouse(1);\n    }\n\n    @Test\n    void canAddNewProduct() throws Exception {\n        // given\n        Collection<Product> productsBefore = warehouse.getProducts();\n\n        // and\n        String name = \"test\";\n        int price = 123;\n\n        // when\n        warehouse.addProduct(name, price);\n\n        // then\n        Collection<Product> productsAfter = warehouse.getProducts();\n        assertEquals(productsBefore.size() + 1, productsAfter.size());\n    }\n\n    @Test\n    void cantAddProductWithNegativePrice() {\n        // given\n        String name = \"test\";\n        int price = -123;\n\n        // when/then\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addProduct(name, price));\n    }\n\n    @Test\n    void canPlaceCorrectOrder() throws Exception {\n        // given\n        Collection<Order> ordersBefore = warehouse.getOrders();\n        int customerId = 12;\n        var quantities = Map.of(2, 1);\n\n        // when\n        warehouse.addOrder(customerId, quantities);\n\n        // then\n        Collection<Order> ordersAfter = warehouse.getOrders();\n        assertEquals(ordersBefore.size() + 1, ordersAfter.size());\n    }\n\n    @Test\n    void cantOrderForNonExistentCustomer() {\n        // given\n        int customerId = 666;\n        var quantities = Map.of(2, 1);\n\n        // when\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addOrder(customerId, quantities));\n    }\n\n    @Test\n    void cantOrderMoreThanAvailableStock() {\n        // given\n        int customerId = 12;\n        var quantities = Map.of(2, 3);\n\n        // when\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addOrder(customerId, quantities));\n    }\n}\n", "focal_file": "package com.example.warehouse;\n\nimport com.example.warehouse.dal.CustomerDao;\nimport com.example.warehouse.dal.InventoryDao;\nimport com.example.warehouse.dal.OrderDao;\nimport com.example.warehouse.dal.ProductDao;\n\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport static java.util.stream.Collectors.toUnmodifiableList;\n\npublic final class Warehouse {\n\n    private final ProductDao productDao;\n    private final CustomerDao customerDao;\n    private final InventoryDao inventoryDao;\n    private final OrderDao orderDao;\n\n    private final ReportGeneration reportGeneration;\n\n    public Warehouse(\n        ProductDao productDao,\n        CustomerDao customerDao,\n        InventoryDao inventoryDao,\n        OrderDao orderDao,\n        ReportGeneration reportGeneration) {\n        this.productDao = productDao;\n        this.customerDao = customerDao;\n        this.inventoryDao = inventoryDao;\n        this.orderDao = orderDao;\n        this.reportGeneration = reportGeneration;\n    }\n\n    public Collection<Product> getProducts() throws WarehouseException {\n        return productDao.getProducts()\n            .stream()\n            .sorted(Comparator.comparing(Product::getId))\n            .collect(toUnmodifiableList());\n    }\n\n    public Collection<Customer> getCustomers() throws WarehouseException {\n        return customerDao.getCustomers()\n            .stream()\n            .sorted(Comparator.comparing(Customer::getId))\n            .collect(toUnmodifiableList());\n    }\n\n    public Collection<Order> getOrders() throws WarehouseException {\n        return orderDao.getOrders()\n            .stream()\n            .sorted(Comparator.comparing(Order::getId))\n            .collect(toUnmodifiableList());\n    }\n\n    public void addProduct(String name, int price) throws WarehouseException {\n        if (price < 0) {\n            throw new IllegalArgumentException(\"The product's price cannot be negative.\");\n        }\n        Product product = new Product(name, price);\n        productDao.addProduct(product);\n    }\n\n    public void addOrder(int customerId, Map<Integer, Integer> quantities) throws WarehouseException {\n        if (quantities.isEmpty()) {\n            throw new IllegalArgumentException(\"There has to items in the order, it cannot be empty.\");\n        }\n        Customer customer = customerDao.getCustomer(customerId);\n        if (customer == null) {\n            throw new IllegalArgumentException(\"Unknown customer ID: \" + customerId);\n        }\n        Map<Product, Integer> mappedQuantities = new HashMap<>();\n        for (var entry : quantities.entrySet()) {\n            Product product = productDao.getProduct(entry.getKey());\n            if (product == null) {\n                throw new IllegalArgumentException(\"Unknown product ID: \" + entry.getKey());\n            }\n            int quantity = entry.getValue();\n            if (quantity < 1) {\n                throw new IllegalArgumentException(\"Ordered quantity must be greater than 0.\");\n            }\n            mappedQuantities.put(product, quantity);\n        }\n        inventoryDao.updateStock(mappedQuantities);\n        Order order = new Order(customer, mappedQuantities);\n        // TODO: updating stock and adding order should be atomic.\n        orderDao.addOrder(order);\n    }\n\n    public Report generateReport(Report.Type type) throws WarehouseException {\n        return reportGeneration.generateReport(type);\n    }\n}\n"}
{"test_method": "@Test\n    void cantOrderForNonExistentCustomer() {\n        // given\n        int customerId = 666;\n        var quantities = Map.of(2, 1);\n\n        // when\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addOrder(customerId, quantities));\n    }", "focal_method": "public void addOrder(int customerId, Map<Integer, Integer> quantities) throws WarehouseException {\n        if (quantities.isEmpty()) {\n            throw new IllegalArgumentException(\"There has to items in the order, it cannot be empty.\");\n        }\n        Customer customer = customerDao.getCustomer(customerId);\n        if (customer == null) {\n            throw new IllegalArgumentException(\"Unknown customer ID: \" + customerId);\n        }\n        Map<Product, Integer> mappedQuantities = new HashMap<>();\n        for (var entry : quantities.entrySet()) {\n            Product product = productDao.getProduct(entry.getKey());\n            if (product == null) {\n                throw new IllegalArgumentException(\"Unknown product ID: \" + entry.getKey());\n            }\n            int quantity = entry.getValue();\n            if (quantity < 1) {\n                throw new IllegalArgumentException(\"Ordered quantity must be greater than 0.\");\n            }\n            mappedQuantities.put(product, quantity);\n        }\n        inventoryDao.updateStock(mappedQuantities);\n        Order order = new Order(customer, mappedQuantities);\n        // TODO: updating stock and adding order should be atomic.\n        orderDao.addOrder(order);\n    }", "test_file": "package com.example.warehouse;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Collection;\nimport java.util.Map;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nclass WarehouseTest {\n\n    private Warehouse warehouse;\n\n    @BeforeEach\n    void beforeEach() {\n        warehouse = Warehouses.newInMemoryWarehouse(1);\n    }\n\n    @Test\n    void canAddNewProduct() throws Exception {\n        // given\n        Collection<Product> productsBefore = warehouse.getProducts();\n\n        // and\n        String name = \"test\";\n        int price = 123;\n\n        // when\n        warehouse.addProduct(name, price);\n\n        // then\n        Collection<Product> productsAfter = warehouse.getProducts();\n        assertEquals(productsBefore.size() + 1, productsAfter.size());\n    }\n\n    @Test\n    void cantAddProductWithNegativePrice() {\n        // given\n        String name = \"test\";\n        int price = -123;\n\n        // when/then\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addProduct(name, price));\n    }\n\n    @Test\n    void canPlaceCorrectOrder() throws Exception {\n        // given\n        Collection<Order> ordersBefore = warehouse.getOrders();\n        int customerId = 12;\n        var quantities = Map.of(2, 1);\n\n        // when\n        warehouse.addOrder(customerId, quantities);\n\n        // then\n        Collection<Order> ordersAfter = warehouse.getOrders();\n        assertEquals(ordersBefore.size() + 1, ordersAfter.size());\n    }\n\n    @Test\n    void cantOrderForNonExistentCustomer() {\n        // given\n        int customerId = 666;\n        var quantities = Map.of(2, 1);\n\n        // when\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addOrder(customerId, quantities));\n    }\n\n    @Test\n    void cantOrderMoreThanAvailableStock() {\n        // given\n        int customerId = 12;\n        var quantities = Map.of(2, 3);\n\n        // when\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addOrder(customerId, quantities));\n    }\n}\n", "focal_file": "package com.example.warehouse;\n\nimport com.example.warehouse.dal.CustomerDao;\nimport com.example.warehouse.dal.InventoryDao;\nimport com.example.warehouse.dal.OrderDao;\nimport com.example.warehouse.dal.ProductDao;\n\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport static java.util.stream.Collectors.toUnmodifiableList;\n\npublic final class Warehouse {\n\n    private final ProductDao productDao;\n    private final CustomerDao customerDao;\n    private final InventoryDao inventoryDao;\n    private final OrderDao orderDao;\n\n    private final ReportGeneration reportGeneration;\n\n    public Warehouse(\n        ProductDao productDao,\n        CustomerDao customerDao,\n        InventoryDao inventoryDao,\n        OrderDao orderDao,\n        ReportGeneration reportGeneration) {\n        this.productDao = productDao;\n        this.customerDao = customerDao;\n        this.inventoryDao = inventoryDao;\n        this.orderDao = orderDao;\n        this.reportGeneration = reportGeneration;\n    }\n\n    public Collection<Product> getProducts() throws WarehouseException {\n        return productDao.getProducts()\n            .stream()\n            .sorted(Comparator.comparing(Product::getId))\n            .collect(toUnmodifiableList());\n    }\n\n    public Product getProduct(int id) throws WarehouseException {\n        return productDao.getProduct(id);\n    }\n\n    public Collection<Customer> getCustomers() throws WarehouseException {\n        return customerDao.getCustomers()\n            .stream()\n            .sorted(Comparator.comparing(Customer::getId))\n            .collect(toUnmodifiableList());\n    }\n\n    public Customer getCustomer(int id) throws WarehouseException {\n        return customerDao.getCustomer(id);\n    }\n\n    public Collection<Order> getOrders() throws WarehouseException {\n        return orderDao.getOrders()\n            .stream()\n            .sorted(Comparator.comparing(Order::getId))\n            .collect(toUnmodifiableList());\n    }\n\n    public Order getOrder(int id) throws WarehouseException {\n        return orderDao.getOrder(id);\n    }\n\n    public void addProduct(String name, int price) throws WarehouseException {\n        if (price < 0) {\n            throw new IllegalArgumentException(\"The product's price cannot be negative.\");\n        }\n        Product product = new Product(name, price);\n        productDao.addProduct(product);\n    }\n\n    public void deleteCustomer(int customerId) throws WarehouseException {\n        customerDao.deleteCustomer(customerId);\n    }\n\n    public void addOrder(int customerId, Map<Integer, Integer> quantities) throws WarehouseException {\n        if (quantities.isEmpty()) {\n            throw new IllegalArgumentException(\"There has to items in the order, it cannot be empty.\");\n        }\n        Customer customer = customerDao.getCustomer(customerId);\n        if (customer == null) {\n            throw new IllegalArgumentException(\"Unknown customer ID: \" + customerId);\n        }\n        Map<Product, Integer> mappedQuantities = new HashMap<>();\n        for (var entry : quantities.entrySet()) {\n            Product product = productDao.getProduct(entry.getKey());\n            if (product == null) {\n                throw new IllegalArgumentException(\"Unknown product ID: \" + entry.getKey());\n            }\n            int quantity = entry.getValue();\n            if (quantity < 1) {\n                throw new IllegalArgumentException(\"Ordered quantity must be greater than 0.\");\n            }\n            mappedQuantities.put(product, quantity);\n        }\n        inventoryDao.updateStock(mappedQuantities);\n        Order order = new Order(customer, mappedQuantities);\n        // TODO: updating stock and adding order should be atomic.\n        orderDao.addOrder(order);\n    }\n\n    public Report generateReport(Report.Type type) throws WarehouseException {\n        return reportGeneration.generateReport(type);\n    }\n}\n"}
{"test_method": "@Test\n    void cantAddProductWithNegativePrice() {\n        // given\n        String name = \"test\";\n        int price = -123;\n\n        // when/then\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addProduct(name, price));\n    }", "focal_method": "public void addProduct(String name, int price) throws WarehouseException {\n        if (price < 0) {\n            throw new IllegalArgumentException(\"The product's price cannot be negative.\");\n        }\n        Product product = new Product(name, price);\n        productDao.addProduct(product);\n    }", "test_file": "package com.example.warehouse;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Collection;\nimport java.util.Map;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nclass WarehouseTest {\n\n    private Warehouse warehouse;\n\n    @BeforeEach\n    void beforeEach() {\n        warehouse = Warehouses.newInMemoryWarehouse(1);\n    }\n\n    @Test\n    void canAddNewProduct() throws Exception {\n        // given\n        Collection<Product> productsBefore = warehouse.getProducts();\n\n        // and\n        String name = \"test\";\n        int price = 123;\n\n        // when\n        warehouse.addProduct(name, price);\n\n        // then\n        Collection<Product> productsAfter = warehouse.getProducts();\n        assertEquals(productsBefore.size() + 1, productsAfter.size());\n    }\n\n    @Test\n    void cantAddProductWithNegativePrice() {\n        // given\n        String name = \"test\";\n        int price = -123;\n\n        // when/then\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addProduct(name, price));\n    }\n\n    @Test\n    void canPlaceCorrectOrder() throws Exception {\n        // given\n        Collection<Order> ordersBefore = warehouse.getOrders();\n        int customerId = 12;\n        var quantities = Map.of(2, 1);\n\n        // when\n        warehouse.addOrder(customerId, quantities);\n\n        // then\n        Collection<Order> ordersAfter = warehouse.getOrders();\n        assertEquals(ordersBefore.size() + 1, ordersAfter.size());\n    }\n\n    @Test\n    void cantOrderForNonExistentCustomer() {\n        // given\n        int customerId = 666;\n        var quantities = Map.of(2, 1);\n\n        // when\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addOrder(customerId, quantities));\n    }\n\n    @Test\n    void cantOrderMoreThanAvailableStock() {\n        // given\n        int customerId = 12;\n        var quantities = Map.of(2, 3);\n\n        // when\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addOrder(customerId, quantities));\n    }\n}\n", "focal_file": "package com.example.warehouse;\n\nimport com.example.warehouse.dal.CustomerDao;\nimport com.example.warehouse.dal.InventoryDao;\nimport com.example.warehouse.dal.OrderDao;\nimport com.example.warehouse.dal.ProductDao;\nimport com.example.warehouse.service.ExternalCustomerService;\nimport org.json.JSONObject;\n\nimport java.time.LocalDate;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport static java.util.stream.Collectors.toUnmodifiableList;\n\npublic final class Warehouse {\n\n    private final ProductDao productDao;\n    private final CustomerDao customerDao;\n    private final InventoryDao inventoryDao;\n    private final OrderDao orderDao;\n\n    private final ReportGeneration reportGeneration;\n    private final ExternalCustomerService externalCustomerService;\n\n    public Warehouse(\n        ProductDao productDao,\n        CustomerDao customerDao,\n        InventoryDao inventoryDao,\n        OrderDao orderDao,\n        ReportGeneration reportGeneration,\n        ExternalCustomerService externalCustomerService) {\n        this.productDao = productDao;\n        this.customerDao = customerDao;\n        this.inventoryDao = inventoryDao;\n        this.orderDao = orderDao;\n        this.reportGeneration = reportGeneration;\n        this.externalCustomerService = externalCustomerService;\n    }\n\n    public Collection<Product> getProducts() throws WarehouseException {\n        return productDao.getProducts()\n            .stream()\n            .sorted(Comparator.comparing(Product::getId))\n            .collect(toUnmodifiableList());\n    }\n\n    public Collection<Customer> getCustomers() throws WarehouseException {\n        Map<Integer, JSONObject> externalCustomers = externalCustomerService.fetchCustomers();\n        return customerDao.getCustomers()\n            .stream()\n            .map(c -> {\n                JSONObject customer = externalCustomers.get(c.getId());\n                JSONObject address = customer.getJSONObject(\"address\");\n                return new Customer(\n                    c.getId(),\n                    c.getName(),\n                    LocalDate.parse(customer.getString(\"date_of_birth\")),\n                    customer.getString(\"company\"),\n                    customer.getString(\"phone\"),\n                    address.getString(\"street_address\"),\n                    address.getString(\"city\"),\n                    address.getString(\"state\"),\n                    address.getInt(\"zip_code\"));\n            })\n            .sorted(Comparator.comparing(Customer::getId))\n            .collect(toUnmodifiableList());\n    }\n\n    public Collection<Order> getOrders() throws WarehouseException {\n        return orderDao.getOrders()\n            .stream()\n            .sorted(Comparator.comparing(Order::getId))\n            .collect(toUnmodifiableList());\n    }\n\n    public void addProduct(String name, int price) throws WarehouseException {\n        if (price < 0) {\n            throw new IllegalArgumentException(\"The product's price cannot be negative.\");\n        }\n        Product product = new Product(name, price);\n        productDao.addProduct(product);\n    }\n\n    public void addOrder(int customerId, Map<Integer, Integer> quantities) throws WarehouseException {\n        if (quantities.isEmpty()) {\n            throw new IllegalArgumentException(\"There has to items in the order, it cannot be empty.\");\n        }\n        Customer customer = customerDao.getCustomer(customerId);\n        if (customer == null) {\n            throw new IllegalArgumentException(\"Unknown customer ID: \" + customerId);\n        }\n        Map<Product, Integer> mappedQuantities = new HashMap<>();\n        for (var entry : quantities.entrySet()) {\n            Product product = productDao.getProduct(entry.getKey());\n            if (product == null) {\n                throw new IllegalArgumentException(\"Unknown product ID: \" + entry.getKey());\n            }\n            int quantity = entry.getValue();\n            if (quantity < 1) {\n                throw new IllegalArgumentException(\"Ordered quantity must be greater than 0.\");\n            }\n            mappedQuantities.put(product, quantity);\n        }\n        inventoryDao.updateStock(mappedQuantities);\n        Order order = new Order(customer, mappedQuantities);\n        // TODO: updating stock and adding order should be atomic.\n        orderDao.addOrder(order);\n    }\n\n    public Report generateReport(Report.Type type) throws WarehouseException {\n        return reportGeneration.generateReport(type);\n    }\n}\n"}
{"test_method": "@Test\n    void cantOrderMoreThanAvailableStock() {\n        // given\n        int customerId = 12;\n        var quantities = Map.of(2, 3);\n\n        // when\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addOrder(customerId, quantities));\n    }", "focal_method": "public void addOrder(int customerId, Map<Integer, Integer> quantities) throws WarehouseException {\n        if (quantities.isEmpty()) {\n            throw new IllegalArgumentException(\"There has to items in the order, it cannot be empty.\");\n        }\n        Customer customer = customerDao.getCustomer(customerId);\n        if (customer == null) {\n            throw new IllegalArgumentException(\"Unknown customer ID: \" + customerId);\n        }\n        Map<Product, Integer> mappedQuantities = new HashMap<>();\n        for (var entry : quantities.entrySet()) {\n            Product product = productDao.getProduct(entry.getKey());\n            if (product == null) {\n                throw new IllegalArgumentException(\"Unknown product ID: \" + entry.getKey());\n            }\n            int quantity = entry.getValue();\n            if (quantity < 1) {\n                throw new IllegalArgumentException(\"Ordered quantity must be greater than 0.\");\n            }\n            mappedQuantities.put(product, quantity);\n        }\n        inventoryDao.updateStock(mappedQuantities);\n        Order order = new Order(customer, mappedQuantities);\n        // TODO: updating stock and adding order should be atomic.\n        orderDao.addOrder(order);\n    }", "test_file": "package com.example.warehouse;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Collection;\nimport java.util.Map;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nclass WarehouseTest {\n\n    private Warehouse warehouse;\n\n    @BeforeEach\n    void beforeEach() {\n        warehouse = Warehouses.newInMemoryWarehouse(1);\n    }\n\n    @Test\n    void canAddNewProduct() throws Exception {\n        // given\n        Collection<Product> productsBefore = warehouse.getProducts();\n\n        // and\n        String name = \"test\";\n        int price = 123;\n\n        // when\n        warehouse.addProduct(name, price);\n\n        // then\n        Collection<Product> productsAfter = warehouse.getProducts();\n        assertEquals(productsBefore.size() + 1, productsAfter.size());\n    }\n\n    @Test\n    void cantAddProductWithNegativePrice() {\n        // given\n        String name = \"test\";\n        int price = -123;\n\n        // when/then\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addProduct(name, price));\n    }\n\n    @Test\n    void canPlaceCorrectOrder() throws Exception {\n        // given\n        Collection<Order> ordersBefore = warehouse.getOrders();\n        int customerId = 12;\n        var quantities = Map.of(2, 1);\n\n        // when\n        warehouse.addOrder(customerId, quantities);\n\n        // then\n        Collection<Order> ordersAfter = warehouse.getOrders();\n        assertEquals(ordersBefore.size() + 1, ordersAfter.size());\n    }\n\n    @Test\n    void cantOrderForNonExistentCustomer() {\n        // given\n        int customerId = 666;\n        var quantities = Map.of(2, 1);\n\n        // when\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addOrder(customerId, quantities));\n    }\n\n    @Test\n    void cantOrderMoreThanAvailableStock() {\n        // given\n        int customerId = 12;\n        var quantities = Map.of(2, 3);\n\n        // when\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addOrder(customerId, quantities));\n    }\n}\n", "focal_file": "package com.example.warehouse;\n\nimport com.example.warehouse.dal.CustomerDao;\nimport com.example.warehouse.dal.InventoryDao;\nimport com.example.warehouse.dal.OrderDao;\nimport com.example.warehouse.dal.ProductDao;\nimport com.example.warehouse.service.ExternalCustomerService;\nimport org.json.JSONObject;\n\nimport java.time.LocalDate;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport static java.util.stream.Collectors.toUnmodifiableList;\n\npublic final class Warehouse {\n\n    private final ProductDao productDao;\n    private final CustomerDao customerDao;\n    private final InventoryDao inventoryDao;\n    private final OrderDao orderDao;\n\n    private final ReportGeneration reportGeneration;\n    private final ExternalCustomerService externalCustomerService;\n\n    public Warehouse(\n        ProductDao productDao,\n        CustomerDao customerDao,\n        InventoryDao inventoryDao,\n        OrderDao orderDao,\n        ReportGeneration reportGeneration,\n        ExternalCustomerService externalCustomerService) {\n        this.productDao = productDao;\n        this.customerDao = customerDao;\n        this.inventoryDao = inventoryDao;\n        this.orderDao = orderDao;\n        this.reportGeneration = reportGeneration;\n        this.externalCustomerService = externalCustomerService;\n    }\n\n    public Collection<Product> getProducts() throws WarehouseException {\n        return productDao.getProducts()\n            .stream()\n            .sorted(Comparator.comparing(Product::getId))\n            .collect(toUnmodifiableList());\n    }\n\n    public Collection<Customer> getCustomers() throws WarehouseException {\n        Map<Integer, JSONObject> externalCustomers = externalCustomerService.fetchCustomers();\n        return customerDao.getCustomers()\n            .stream()\n            .map(c -> {\n                JSONObject customer = externalCustomers.get(c.getId());\n                JSONObject address = customer.getJSONObject(\"address\");\n                return new Customer(\n                    c.getId(),\n                    c.getName(),\n                    LocalDate.parse(customer.getString(\"date_of_birth\")),\n                    customer.getString(\"company\"),\n                    customer.getString(\"phone\"),\n                    address.getString(\"street_address\"),\n                    address.getString(\"city\"),\n                    address.getString(\"state\"),\n                    address.getInt(\"zip_code\"));\n            })\n            .sorted(Comparator.comparing(Customer::getId))\n            .collect(toUnmodifiableList());\n    }\n\n    public Collection<Order> getOrders() throws WarehouseException {\n        return orderDao.getOrders()\n            .stream()\n            .sorted(Comparator.comparing(Order::getId))\n            .collect(toUnmodifiableList());\n    }\n\n    public void addProduct(String name, int price) throws WarehouseException {\n        if (price < 0) {\n            throw new IllegalArgumentException(\"The product's price cannot be negative.\");\n        }\n        Product product = new Product(name, price);\n        productDao.addProduct(product);\n    }\n\n    public void addOrder(int customerId, Map<Integer, Integer> quantities) throws WarehouseException {\n        if (quantities.isEmpty()) {\n            throw new IllegalArgumentException(\"There has to items in the order, it cannot be empty.\");\n        }\n        Customer customer = customerDao.getCustomer(customerId);\n        if (customer == null) {\n            throw new IllegalArgumentException(\"Unknown customer ID: \" + customerId);\n        }\n        Map<Product, Integer> mappedQuantities = new HashMap<>();\n        for (var entry : quantities.entrySet()) {\n            Product product = productDao.getProduct(entry.getKey());\n            if (product == null) {\n                throw new IllegalArgumentException(\"Unknown product ID: \" + entry.getKey());\n            }\n            int quantity = entry.getValue();\n            if (quantity < 1) {\n                throw new IllegalArgumentException(\"Ordered quantity must be greater than 0.\");\n            }\n            mappedQuantities.put(product, quantity);\n        }\n        inventoryDao.updateStock(mappedQuantities);\n        Order order = new Order(customer, mappedQuantities);\n        // TODO: updating stock and adding order should be atomic.\n        orderDao.addOrder(order);\n    }\n\n    public Report generateReport(Report.Type type) throws WarehouseException {\n        return reportGeneration.generateReport(type);\n    }\n}\n"}
{"test_method": "@Test\n    void cantAddProductWithNegativePrice() {\n        // given\n        String name = \"test\";\n        int price = -123;\n\n        // when/then\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addProduct(name, price));\n    }", "focal_method": "public void addProduct(String name, int price) throws WarehouseException {\n        if (price < 0) {\n            throw new IllegalArgumentException(\"The product's price cannot be negative.\");\n        }\n        Product product = new Product(name, price);\n        productDao.addProduct(product);\n    }", "test_file": "package com.example.warehouse;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Collection;\nimport java.util.Map;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nclass WarehouseTest {\n\n    private Warehouse warehouse;\n\n    @BeforeEach\n    void beforeEach() {\n        warehouse = Warehouses.newInMemoryWarehouse(1);\n    }\n\n    @Test\n    void canAddNewProduct() throws Exception {\n        // given\n        Collection<Product> productsBefore = warehouse.getProducts();\n\n        // and\n        String name = \"test\";\n        int price = 123;\n\n        // when\n        warehouse.addProduct(name, price);\n\n        // then\n        Collection<Product> productsAfter = warehouse.getProducts();\n        assertEquals(productsBefore.size() + 1, productsAfter.size());\n    }\n\n    @Test\n    void cantAddProductWithNegativePrice() {\n        // given\n        String name = \"test\";\n        int price = -123;\n\n        // when/then\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addProduct(name, price));\n    }\n\n    @Test\n    void canPlaceCorrectOrder() throws Exception {\n        // given\n        Collection<Order> ordersBefore = warehouse.getOrders();\n        int customerId = 12;\n        var quantities = Map.of(2, 1);\n\n        // when\n        warehouse.addOrder(customerId, quantities);\n\n        // then\n        Collection<Order> ordersAfter = warehouse.getOrders();\n        assertEquals(ordersBefore.size() + 1, ordersAfter.size());\n    }\n\n    @Test\n    void cantOrderForNonExistentCustomer() {\n        // given\n        int customerId = 666;\n        var quantities = Map.of(2, 1);\n\n        // when\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addOrder(customerId, quantities));\n    }\n\n    @Test\n    void cantOrderMoreThanAvailableStock() {\n        // given\n        int customerId = 12;\n        var quantities = Map.of(2, 3);\n\n        // when\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addOrder(customerId, quantities));\n    }\n}\n", "focal_file": "package com.example.warehouse;\n\nimport com.example.warehouse.dal.CustomerDao;\nimport com.example.warehouse.dal.InventoryDao;\nimport com.example.warehouse.dal.OrderDao;\nimport com.example.warehouse.dal.ProductDao;\n\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport static java.util.stream.Collectors.toUnmodifiableList;\n\npublic final class Warehouse {\n\n    private final ProductDao productDao;\n    private final CustomerDao customerDao;\n    private final InventoryDao inventoryDao;\n    private final OrderDao orderDao;\n\n    private final ReportGeneration reportGeneration;\n\n    public Warehouse(\n        ProductDao productDao,\n        CustomerDao customerDao,\n        InventoryDao inventoryDao,\n        OrderDao orderDao,\n        ReportGeneration reportGeneration) {\n        this.productDao = productDao;\n        this.customerDao = customerDao;\n        this.inventoryDao = inventoryDao;\n        this.orderDao = orderDao;\n        this.reportGeneration = reportGeneration;\n    }\n\n    public Collection<Product> getProducts() throws WarehouseException {\n        return productDao.getProducts()\n            .stream()\n            .sorted(Comparator.comparing(Product::getId))\n            .collect(toUnmodifiableList());\n    }\n\n    public Collection<Customer> getCustomers() throws WarehouseException {\n        return customerDao.getCustomers()\n            .stream()\n            .sorted(Comparator.comparing(Customer::getId))\n            .collect(toUnmodifiableList());\n    }\n\n    public Collection<Order> getOrders() throws WarehouseException {\n        return orderDao.getOrders()\n            .stream()\n            .sorted()\n            .sorted(Comparator.comparing(Order::getId))\n            .collect(toUnmodifiableList());\n    }\n\n    public void addProduct(String name, int price) throws WarehouseException {\n        if (price < 0) {\n            throw new IllegalArgumentException(\"The product's price cannot be negative.\");\n        }\n        Product product = new Product(name, price);\n        productDao.addProduct(product);\n    }\n\n    public void addOrder(int customerId, Map<Integer, Integer> quantities) throws WarehouseException {\n        if (quantities.isEmpty()) {\n            throw new IllegalArgumentException(\"There has to items in the order, it cannot be empty.\");\n        }\n        Customer customer = customerDao.getCustomer(customerId);\n        if (customer == null) {\n            throw new IllegalArgumentException(\"Unknown customer ID: \" + customerId);\n        }\n        Map<Product, Integer> mappedQuantities = new HashMap<>();\n        for (var entry : quantities.entrySet()) {\n            Product product = productDao.getProduct(entry.getKey());\n            if (product == null) {\n                throw new IllegalArgumentException(\"Unknown product ID: \" + entry.getKey());\n            }\n            int quantity = entry.getValue();\n            if (quantity < 1) {\n                throw new IllegalArgumentException(\"Ordered quantity must be greater than 0.\");\n            }\n            mappedQuantities.put(product, quantity);\n        }\n        inventoryDao.updateStock(mappedQuantities);\n        Order order = new Order(customer, mappedQuantities);\n        // TODO: updating stock and adding order should be atomic.\n        orderDao.addOrder(order);\n    }\n\n    public Report generateReport(Report.Type type) throws WarehouseException {\n        return reportGeneration.generateReport(type);\n    }\n}\n"}
{"test_method": "@Test\n    void cantOrderMoreThanAvailableStock() {\n        // given\n        int customerId = 12;\n        var quantities = Map.of(2, 3);\n\n        // when\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addOrder(customerId, quantities));\n    }", "focal_method": "public void addOrder(int customerId, Map<Integer, Integer> quantities) throws WarehouseException {\n        if (quantities.isEmpty()) {\n            throw new IllegalArgumentException(\"There has to items in the order, it cannot be empty.\");\n        }\n        Customer customer = customerDao.getCustomer(customerId);\n        if (customer == null) {\n            throw new IllegalArgumentException(\"Unknown customer ID: \" + customerId);\n        }\n        Map<Product, Integer> mappedQuantities = new HashMap<>();\n        for (var entry : quantities.entrySet()) {\n            Product product = productDao.getProduct(entry.getKey());\n            if (product == null) {\n                throw new IllegalArgumentException(\"Unknown product ID: \" + entry.getKey());\n            }\n            int quantity = entry.getValue();\n            if (quantity < 1) {\n                throw new IllegalArgumentException(\"Ordered quantity must be greater than 0.\");\n            }\n            mappedQuantities.put(product, quantity);\n        }\n        inventoryDao.updateStock(mappedQuantities);\n        Order order = new Order(customer, mappedQuantities);\n        // TODO: updating stock and adding order should be atomic.\n        orderDao.addOrder(order);\n    }", "test_file": "package com.example.warehouse;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Collection;\nimport java.util.Map;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nclass WarehouseTest {\n\n    private Warehouse warehouse;\n\n    @BeforeEach\n    void beforeEach() {\n        warehouse = Warehouses.newInMemoryWarehouse(1);\n    }\n\n    @Test\n    void canAddNewProduct() throws Exception {\n        // given\n        Collection<Product> productsBefore = warehouse.getProducts();\n\n        // and\n        String name = \"test\";\n        int price = 123;\n\n        // when\n        warehouse.addProduct(name, price);\n\n        // then\n        Collection<Product> productsAfter = warehouse.getProducts();\n        assertEquals(productsBefore.size() + 1, productsAfter.size());\n    }\n\n    @Test\n    void cantAddProductWithNegativePrice() {\n        // given\n        String name = \"test\";\n        int price = -123;\n\n        // when/then\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addProduct(name, price));\n    }\n\n    @Test\n    void canPlaceCorrectOrder() throws Exception {\n        // given\n        Collection<Order> ordersBefore = warehouse.getOrders();\n        int customerId = 12;\n        var quantities = Map.of(2, 1);\n\n        // when\n        warehouse.addOrder(customerId, quantities);\n\n        // then\n        Collection<Order> ordersAfter = warehouse.getOrders();\n        assertEquals(ordersBefore.size() + 1, ordersAfter.size());\n    }\n\n    @Test\n    void cantOrderForNonExistentCustomer() {\n        // given\n        int customerId = 666;\n        var quantities = Map.of(2, 1);\n\n        // when\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addOrder(customerId, quantities));\n    }\n\n    @Test\n    void cantOrderMoreThanAvailableStock() {\n        // given\n        int customerId = 12;\n        var quantities = Map.of(2, 3);\n\n        // when\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addOrder(customerId, quantities));\n    }\n}\n", "focal_file": "package com.example.warehouse;\n\nimport com.example.warehouse.dal.CustomerDao;\nimport com.example.warehouse.dal.InventoryDao;\nimport com.example.warehouse.dal.OrderDao;\nimport com.example.warehouse.dal.ProductDao;\n\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport static java.util.stream.Collectors.toUnmodifiableList;\n\npublic final class Warehouse {\n\n    private final ProductDao productDao;\n    private final CustomerDao customerDao;\n    private final InventoryDao inventoryDao;\n    private final OrderDao orderDao;\n\n    private final ReportGeneration reportGeneration;\n\n    public Warehouse(\n        ProductDao productDao,\n        CustomerDao customerDao,\n        InventoryDao inventoryDao,\n        OrderDao orderDao,\n        ReportGeneration reportGeneration) {\n        this.productDao = productDao;\n        this.customerDao = customerDao;\n        this.inventoryDao = inventoryDao;\n        this.orderDao = orderDao;\n        this.reportGeneration = reportGeneration;\n    }\n\n    public Collection<Product> getProducts() throws WarehouseException {\n        return productDao.getProducts()\n            .stream()\n            .sorted(Comparator.comparing(Product::getId))\n            .collect(toUnmodifiableList());\n    }\n\n    public Product getProduct(int id) throws WarehouseException {\n        return productDao.getProduct(id);\n    }\n\n    public Collection<Customer> getCustomers() throws WarehouseException {\n        return customerDao.getCustomers()\n            .stream()\n            .sorted(Comparator.comparing(Customer::getId))\n            .collect(toUnmodifiableList());\n    }\n\n    public Customer getCustomer(int id) throws WarehouseException {\n        return customerDao.getCustomer(id);\n    }\n\n    public Collection<Order> getOrders() throws WarehouseException {\n        return orderDao.getOrders()\n            .stream()\n            .sorted(Comparator.comparing(Order::getId))\n            .collect(toUnmodifiableList());\n    }\n\n    public Order getOrder(int id) throws WarehouseException {\n        return orderDao.getOrder(id);\n    }\n\n    public void addProduct(String name, int price) throws WarehouseException {\n        if (price < 0) {\n            throw new IllegalArgumentException(\"The product's price cannot be negative.\");\n        }\n        Product product = new Product(name, price);\n        productDao.addProduct(product);\n    }\n\n    public void deleteCustomer(int customerId) throws WarehouseException {\n        customerDao.deleteCustomer(customerId);\n    }\n\n    public void addOrder(int customerId, Map<Integer, Integer> quantities) throws WarehouseException {\n        if (quantities.isEmpty()) {\n            throw new IllegalArgumentException(\"There has to items in the order, it cannot be empty.\");\n        }\n        Customer customer = customerDao.getCustomer(customerId);\n        if (customer == null) {\n            throw new IllegalArgumentException(\"Unknown customer ID: \" + customerId);\n        }\n        Map<Product, Integer> mappedQuantities = new HashMap<>();\n        for (var entry : quantities.entrySet()) {\n            Product product = productDao.getProduct(entry.getKey());\n            if (product == null) {\n                throw new IllegalArgumentException(\"Unknown product ID: \" + entry.getKey());\n            }\n            int quantity = entry.getValue();\n            if (quantity < 1) {\n                throw new IllegalArgumentException(\"Ordered quantity must be greater than 0.\");\n            }\n            mappedQuantities.put(product, quantity);\n        }\n        inventoryDao.updateStock(mappedQuantities);\n        Order order = new Order(customer, mappedQuantities);\n        // TODO: updating stock and adding order should be atomic.\n        orderDao.addOrder(order);\n    }\n\n    public Report generateReport(Report.Type type) throws WarehouseException {\n        return reportGeneration.generateReport(type);\n    }\n}\n"}
{"test_method": "@Test\n    void cantAddProductWithNegativePrice() {\n        // given\n        String name = \"test\";\n        int price = -123;\n\n        // when/then\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addProduct(name, price));\n    }", "focal_method": "public void addProduct(String name, int price) throws WarehouseException {\n        if (price < 0) {\n            throw new IllegalArgumentException(\"The product's price cannot be negative.\");\n        }\n        Product product = new Product(name, price);\n        productDao.addProduct(product);\n    }", "test_file": "package com.example.warehouse;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Collection;\nimport java.util.Map;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nclass WarehouseTest {\n\n    private Warehouse warehouse;\n\n    @BeforeEach\n    void beforeEach() {\n        warehouse = Warehouses.newInMemoryWarehouse(1);\n    }\n\n    @Test\n    void canAddNewProduct() throws Exception {\n        // given\n        Collection<Product> productsBefore = warehouse.getProducts();\n\n        // and\n        String name = \"test\";\n        int price = 123;\n\n        // when\n        warehouse.addProduct(name, price);\n\n        // then\n        Collection<Product> productsAfter = warehouse.getProducts();\n        assertEquals(productsBefore.size() + 1, productsAfter.size());\n    }\n\n    @Test\n    void cantAddProductWithNegativePrice() {\n        // given\n        String name = \"test\";\n        int price = -123;\n\n        // when/then\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addProduct(name, price));\n    }\n\n    @Test\n    void canPlaceCorrectOrder() throws Exception {\n        // given\n        Collection<Order> ordersBefore = warehouse.getOrders();\n        int customerId = 12;\n        var quantities = Map.of(2, 1);\n\n        // when\n        warehouse.addOrder(customerId, quantities);\n\n        // then\n        Collection<Order> ordersAfter = warehouse.getOrders();\n        assertEquals(ordersBefore.size() + 1, ordersAfter.size());\n    }\n\n    @Test\n    void cantOrderForNonExistentCustomer() {\n        // given\n        int customerId = 666;\n        var quantities = Map.of(2, 1);\n\n        // when\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addOrder(customerId, quantities));\n    }\n\n    @Test\n    void cantOrderMoreThanAvailableStock() {\n        // given\n        int customerId = 12;\n        var quantities = Map.of(2, 3);\n\n        // when\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addOrder(customerId, quantities));\n    }\n}\n", "focal_file": "package com.example.warehouse;\n\nimport com.example.warehouse.dal.CustomerDao;\nimport com.example.warehouse.dal.InventoryDao;\nimport com.example.warehouse.dal.OrderDao;\nimport com.example.warehouse.dal.ProductDao;\n\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport static java.util.stream.Collectors.toUnmodifiableList;\n\npublic final class Warehouse {\n\n    private final ProductDao productDao;\n    private final CustomerDao customerDao;\n    private final InventoryDao inventoryDao;\n    private final OrderDao orderDao;\n\n    private final ReportGeneration reportGeneration;\n\n    public Warehouse(\n        ProductDao productDao,\n        CustomerDao customerDao,\n        InventoryDao inventoryDao,\n        OrderDao orderDao,\n        ReportGeneration reportGeneration) {\n        this.productDao = productDao;\n        this.customerDao = customerDao;\n        this.inventoryDao = inventoryDao;\n        this.orderDao = orderDao;\n        this.reportGeneration = reportGeneration;\n    }\n\n    public Collection<Product> getProducts() throws WarehouseException {\n        return productDao.getProducts()\n            .stream()\n            .sorted(Comparator.comparing(Product::getId))\n            .collect(toUnmodifiableList());\n    }\n\n    public Product getProduct(int id) throws WarehouseException {\n        return productDao.getProduct(id);\n    }\n\n    public Collection<Customer> getCustomers() throws WarehouseException {\n        return customerDao.getCustomers()\n            .stream()\n            .sorted(Comparator.comparing(Customer::getId))\n            .collect(toUnmodifiableList());\n    }\n\n    public Customer getCustomer(int id) throws WarehouseException {\n        return customerDao.getCustomer(id);\n    }\n\n    public Collection<Order> getOrders() throws WarehouseException {\n        return orderDao.getOrders()\n            .stream()\n            .sorted(Comparator.comparing(Order::getId))\n            .collect(toUnmodifiableList());\n    }\n\n    public Order getOrder(int id) throws WarehouseException {\n        return orderDao.getOrder(id);\n    }\n\n    public void addProduct(String name, int price) throws WarehouseException {\n        if (price < 0) {\n            throw new IllegalArgumentException(\"The product's price cannot be negative.\");\n        }\n        Product product = new Product(name, price);\n        productDao.addProduct(product);\n    }\n\n    public void deleteCustomer(int customerId) throws WarehouseException {\n        customerDao.deleteCustomer(customerId);\n    }\n\n    public void addOrder(int customerId, Map<Integer, Integer> quantities) throws WarehouseException {\n        if (quantities.isEmpty()) {\n            throw new IllegalArgumentException(\"There has to items in the order, it cannot be empty.\");\n        }\n        Customer customer = customerDao.getCustomer(customerId);\n        if (customer == null) {\n            throw new IllegalArgumentException(\"Unknown customer ID: \" + customerId);\n        }\n        Map<Product, Integer> mappedQuantities = new HashMap<>();\n        for (var entry : quantities.entrySet()) {\n            Product product = productDao.getProduct(entry.getKey());\n            if (product == null) {\n                throw new IllegalArgumentException(\"Unknown product ID: \" + entry.getKey());\n            }\n            int quantity = entry.getValue();\n            if (quantity < 1) {\n                throw new IllegalArgumentException(\"Ordered quantity must be greater than 0.\");\n            }\n            mappedQuantities.put(product, quantity);\n        }\n        inventoryDao.updateStock(mappedQuantities);\n        Order order = new Order(customer, mappedQuantities);\n        // TODO: updating stock and adding order should be atomic.\n        orderDao.addOrder(order);\n    }\n\n    public Report generateReport(Report.Type type) throws WarehouseException {\n        return reportGeneration.generateReport(type);\n    }\n}\n"}
{"test_method": "@Test\n    void cantOrderMoreThanAvailableStock() {\n        // given\n        int customerId = 12;\n        var quantities = Map.of(2, 3);\n\n        // when\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addOrder(customerId, quantities));\n    }", "focal_method": "public void addOrder(int customerId, Map<Integer, Integer> quantities) throws WarehouseException {\n        if (quantities.isEmpty()) {\n            throw new IllegalArgumentException(\"There has to items in the order, it cannot be empty.\");\n        }\n        Customer customer = customerDao.getCustomer(customerId);\n        if (customer == null) {\n            throw new IllegalArgumentException(\"Unknown customer ID: \" + customerId);\n        }\n        Map<Product, Integer> mappedQuantities = new HashMap<>();\n        for (var entry : quantities.entrySet()) {\n            Product product = productDao.getProduct(entry.getKey());\n            if (product == null) {\n                throw new IllegalArgumentException(\"Unknown product ID: \" + entry.getKey());\n            }\n            int quantity = entry.getValue();\n            if (quantity < 1) {\n                throw new IllegalArgumentException(\"Ordered quantity must be greater than 0.\");\n            }\n            mappedQuantities.put(product, quantity);\n        }\n        inventoryDao.updateStock(mappedQuantities);\n        Order order = new Order(customer, mappedQuantities);\n        // TODO: updating stock and adding order should be atomic.\n        orderDao.addOrder(order);\n    }", "test_file": "package com.example.warehouse;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Collection;\nimport java.util.Map;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nclass WarehouseTest {\n\n    private Warehouse warehouse;\n\n    @BeforeEach\n    void beforeEach() {\n        warehouse = Warehouses.newInMemoryWarehouse(1);\n    }\n\n    @Test\n    void canAddNewProduct() throws Exception {\n        // given\n        Collection<Product> productsBefore = warehouse.getProducts();\n\n        // and\n        String name = \"test\";\n        int price = 123;\n\n        // when\n        warehouse.addProduct(name, price);\n\n        // then\n        Collection<Product> productsAfter = warehouse.getProducts();\n        assertEquals(productsBefore.size() + 1, productsAfter.size());\n    }\n\n    @Test\n    void cantAddProductWithNegativePrice() {\n        // given\n        String name = \"test\";\n        int price = -123;\n\n        // when/then\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addProduct(name, price));\n    }\n\n    @Test\n    void canPlaceCorrectOrder() throws Exception {\n        // given\n        Collection<Order> ordersBefore = warehouse.getOrders();\n        int customerId = 12;\n        var quantities = Map.of(2, 1);\n\n        // when\n        warehouse.addOrder(customerId, quantities);\n\n        // then\n        Collection<Order> ordersAfter = warehouse.getOrders();\n        assertEquals(ordersBefore.size() + 1, ordersAfter.size());\n    }\n\n    @Test\n    void cantOrderForNonExistentCustomer() {\n        // given\n        int customerId = 666;\n        var quantities = Map.of(2, 1);\n\n        // when\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addOrder(customerId, quantities));\n    }\n\n    @Test\n    void cantOrderMoreThanAvailableStock() {\n        // given\n        int customerId = 12;\n        var quantities = Map.of(2, 3);\n\n        // when\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addOrder(customerId, quantities));\n    }\n}\n", "focal_file": "package com.example.warehouse;\n\nimport com.example.warehouse.dal.CustomerDao;\nimport com.example.warehouse.dal.InventoryDao;\nimport com.example.warehouse.dal.OrderDao;\nimport com.example.warehouse.dal.ProductDao;\n\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport static java.util.stream.Collectors.toUnmodifiableList;\n\npublic final class Warehouse {\n\n    private final ProductDao productDao;\n    private final CustomerDao customerDao;\n    private final InventoryDao inventoryDao;\n    private final OrderDao orderDao;\n\n    private final ReportGeneration reportGeneration;\n\n    public Warehouse(\n        ProductDao productDao,\n        CustomerDao customerDao,\n        InventoryDao inventoryDao,\n        OrderDao orderDao,\n        ReportGeneration reportGeneration) {\n        this.productDao = productDao;\n        this.customerDao = customerDao;\n        this.inventoryDao = inventoryDao;\n        this.orderDao = orderDao;\n        this.reportGeneration = reportGeneration;\n    }\n\n    public Collection<Product> getProducts() throws WarehouseException {\n        return productDao.getProducts()\n            .stream()\n            .sorted(Comparator.comparing(Product::getId))\n            .collect(toUnmodifiableList());\n    }\n\n    public Product getProduct(int id) throws WarehouseException {\n        return productDao.getProduct(id);\n    }\n\n    public Collection<Customer> getCustomers() throws WarehouseException {\n        return customerDao.getCustomers()\n            .stream()\n            .sorted(Comparator.comparing(Customer::getId))\n            .collect(toUnmodifiableList());\n    }\n\n    public Customer getCustomer(int id) throws WarehouseException {\n        return customerDao.getCustomer(id);\n    }\n\n    public Collection<Order> getOrders() throws WarehouseException {\n        return orderDao.getOrders()\n            .stream()\n            .sorted(Comparator.comparing(Order::getId))\n            .collect(toUnmodifiableList());\n    }\n\n    public Order getOrder(int id) throws WarehouseException {\n        return orderDao.getOrder(id);\n    }\n\n    public void addProduct(String name, int price) throws WarehouseException {\n        if (price < 0) {\n            throw new IllegalArgumentException(\"The product's price cannot be negative.\");\n        }\n        Product product = new Product(name, price);\n        productDao.addProduct(product);\n    }\n\n    public void addOrder(int customerId, Map<Integer, Integer> quantities) throws WarehouseException {\n        if (quantities.isEmpty()) {\n            throw new IllegalArgumentException(\"There has to items in the order, it cannot be empty.\");\n        }\n        Customer customer = customerDao.getCustomer(customerId);\n        if (customer == null) {\n            throw new IllegalArgumentException(\"Unknown customer ID: \" + customerId);\n        }\n        Map<Product, Integer> mappedQuantities = new HashMap<>();\n        for (var entry : quantities.entrySet()) {\n            Product product = productDao.getProduct(entry.getKey());\n            if (product == null) {\n                throw new IllegalArgumentException(\"Unknown product ID: \" + entry.getKey());\n            }\n            int quantity = entry.getValue();\n            if (quantity < 1) {\n                throw new IllegalArgumentException(\"Ordered quantity must be greater than 0.\");\n            }\n            mappedQuantities.put(product, quantity);\n        }\n        inventoryDao.updateStock(mappedQuantities);\n        Order order = new Order(customer, mappedQuantities);\n        // TODO: updating stock and adding order should be atomic.\n        orderDao.addOrder(order);\n    }\n\n    public Report generateReport(Report.Type type) throws WarehouseException {\n        return reportGeneration.generateReport(type);\n    }\n}\n"}
{"test_method": "@Test\n    void cantOrderForNonExistentCustomer() {\n        // given\n        int customerId = 666;\n        var quantities = Map.of(2, 1);\n\n        // when\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addOrder(customerId, quantities));\n    }", "focal_method": "public void addOrder(int customerId, Map<Integer, Integer> quantities) throws WarehouseException {\n        if (quantities.isEmpty()) {\n            throw new IllegalArgumentException(\"There has to items in the order, it cannot be empty.\");\n        }\n        Customer customer = customerDao.getCustomer(customerId);\n        if (customer == null) {\n            throw new IllegalArgumentException(\"Unknown customer ID: \" + customerId);\n        }\n        Map<Product, Integer> mappedQuantities = new HashMap<>();\n        for (var entry : quantities.entrySet()) {\n            Product product = productDao.getProduct(entry.getKey());\n            if (product == null) {\n                throw new IllegalArgumentException(\"Unknown product ID: \" + entry.getKey());\n            }\n            int quantity = entry.getValue();\n            if (quantity < 1) {\n                throw new IllegalArgumentException(\"Ordered quantity must be greater than 0.\");\n            }\n            mappedQuantities.put(product, quantity);\n        }\n        inventoryDao.updateStock(mappedQuantities);\n        Order order = new Order(customer, mappedQuantities);\n        // TODO: updating stock and adding order should be atomic.\n        orderDao.addOrder(order);\n    }", "test_file": "package com.example.warehouse;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Collection;\nimport java.util.Map;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nclass WarehouseTest {\n\n    private Warehouse warehouse;\n\n    @BeforeEach\n    void beforeEach() {\n        warehouse = Warehouses.newInMemoryWarehouse(1);\n    }\n\n    @Test\n    void canAddNewProduct() throws Exception {\n        // given\n        Collection<Product> productsBefore = warehouse.getProducts();\n\n        // and\n        String name = \"test\";\n        int price = 123;\n\n        // when\n        warehouse.addProduct(name, price);\n\n        // then\n        Collection<Product> productsAfter = warehouse.getProducts();\n        assertEquals(productsBefore.size() + 1, productsAfter.size());\n    }\n\n    @Test\n    void cantAddProductWithNegativePrice() {\n        // given\n        String name = \"test\";\n        int price = -123;\n\n        // when/then\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addProduct(name, price));\n    }\n\n    @Test\n    void canPlaceCorrectOrder() throws Exception {\n        // given\n        Collection<Order> ordersBefore = warehouse.getOrders();\n        int customerId = 12;\n        var quantities = Map.of(2, 1);\n\n        // when\n        warehouse.addOrder(customerId, quantities);\n\n        // then\n        Collection<Order> ordersAfter = warehouse.getOrders();\n        assertEquals(ordersBefore.size() + 1, ordersAfter.size());\n    }\n\n    @Test\n    void cantOrderForNonExistentCustomer() {\n        // given\n        int customerId = 666;\n        var quantities = Map.of(2, 1);\n\n        // when\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addOrder(customerId, quantities));\n    }\n\n    @Test\n    void cantOrderMoreThanAvailableStock() {\n        // given\n        int customerId = 12;\n        var quantities = Map.of(2, 3);\n\n        // when\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addOrder(customerId, quantities));\n    }\n}\n", "focal_file": "package com.example.warehouse;\n\nimport com.example.warehouse.dal.CustomerDao;\nimport com.example.warehouse.dal.InventoryDao;\nimport com.example.warehouse.dal.OrderDao;\nimport com.example.warehouse.dal.ProductDao;\n\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport static java.util.stream.Collectors.toUnmodifiableList;\n\npublic final class Warehouse {\n\n    private final ProductDao productDao;\n    private final CustomerDao customerDao;\n    private final InventoryDao inventoryDao;\n    private final OrderDao orderDao;\n\n    private final ReportGeneration reportGeneration;\n\n    public Warehouse(\n        ProductDao productDao,\n        CustomerDao customerDao,\n        InventoryDao inventoryDao,\n        OrderDao orderDao,\n        ReportGeneration reportGeneration) {\n        this.productDao = productDao;\n        this.customerDao = customerDao;\n        this.inventoryDao = inventoryDao;\n        this.orderDao = orderDao;\n        this.reportGeneration = reportGeneration;\n    }\n\n    public Collection<Product> getProducts() throws WarehouseException {\n        return productDao.getProducts()\n            .stream()\n            .sorted(Comparator.comparing(Product::getId))\n            .collect(toUnmodifiableList());\n    }\n\n    public Product getProduct(int id) throws WarehouseException {\n        return productDao.getProduct(id);\n    }\n\n    public Collection<Customer> getCustomers() throws WarehouseException {\n        return customerDao.getCustomers()\n            .stream()\n            .sorted(Comparator.comparing(Customer::getId))\n            .collect(toUnmodifiableList());\n    }\n\n    public Customer getCustomer(int id) throws WarehouseException {\n        return customerDao.getCustomer(id);\n    }\n\n    public Collection<Order> getOrders() throws WarehouseException {\n        return orderDao.getOrders()\n            .stream()\n            .sorted(Comparator.comparing(Order::getId))\n            .collect(toUnmodifiableList());\n    }\n\n    public Order getOrder(int id) throws WarehouseException {\n        return orderDao.getOrder(id);\n    }\n\n    public void addProduct(String name, int price) throws WarehouseException {\n        if (price < 0) {\n            throw new IllegalArgumentException(\"The product's price cannot be negative.\");\n        }\n        Product product = new Product(name, price);\n        productDao.addProduct(product);\n    }\n\n    public void addOrder(int customerId, Map<Integer, Integer> quantities) throws WarehouseException {\n        if (quantities.isEmpty()) {\n            throw new IllegalArgumentException(\"There has to items in the order, it cannot be empty.\");\n        }\n        Customer customer = customerDao.getCustomer(customerId);\n        if (customer == null) {\n            throw new IllegalArgumentException(\"Unknown customer ID: \" + customerId);\n        }\n        Map<Product, Integer> mappedQuantities = new HashMap<>();\n        for (var entry : quantities.entrySet()) {\n            Product product = productDao.getProduct(entry.getKey());\n            if (product == null) {\n                throw new IllegalArgumentException(\"Unknown product ID: \" + entry.getKey());\n            }\n            int quantity = entry.getValue();\n            if (quantity < 1) {\n                throw new IllegalArgumentException(\"Ordered quantity must be greater than 0.\");\n            }\n            mappedQuantities.put(product, quantity);\n        }\n        inventoryDao.updateStock(mappedQuantities);\n        Order order = new Order(customer, mappedQuantities);\n        // TODO: updating stock and adding order should be atomic.\n        orderDao.addOrder(order);\n    }\n\n    public Report generateReport(Report.Type type) throws WarehouseException {\n        return reportGeneration.generateReport(type);\n    }\n}\n"}
{"test_method": "@Test\n    void cantOrderForNonExistentCustomer() {\n        // given\n        int customerId = 666;\n        var quantities = Map.of(2, 1);\n\n        // when\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addOrder(customerId, quantities));\n    }", "focal_method": "public void addOrder(int customerId, Map<Integer, Integer> quantities) throws WarehouseException {\n        if (quantities.isEmpty()) {\n            throw new IllegalArgumentException(\"There has to items in the order, it cannot be empty.\");\n        }\n        Customer customer = customerDao.getCustomer(customerId);\n        if (customer == null) {\n            throw new IllegalArgumentException(\"Unknown customer ID: \" + customerId);\n        }\n        Map<Product, Integer> mappedQuantities = new HashMap<>();\n        for (var entry : quantities.entrySet()) {\n            Product product = productDao.getProduct(entry.getKey());\n            if (product == null) {\n                throw new IllegalArgumentException(\"Unknown product ID: \" + entry.getKey());\n            }\n            int quantity = entry.getValue();\n            if (quantity < 1) {\n                throw new IllegalArgumentException(\"Ordered quantity must be greater than 0.\");\n            }\n            mappedQuantities.put(product, quantity);\n        }\n        inventoryDao.updateStock(mappedQuantities);\n        Order order = new Order(customer, mappedQuantities);\n        // TODO: updating stock and adding order should be atomic.\n        orderDao.addOrder(order);\n    }", "test_file": "package com.example.warehouse;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Collection;\nimport java.util.Map;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nclass WarehouseTest {\n\n    private Warehouse warehouse;\n\n    @BeforeEach\n    void beforeEach() {\n        warehouse = Warehouses.newInMemoryWarehouse(1);\n    }\n\n    @Test\n    void canAddNewProduct() throws Exception {\n        // given\n        Collection<Product> productsBefore = warehouse.getProducts();\n\n        // and\n        String name = \"test\";\n        int price = 123;\n\n        // when\n        warehouse.addProduct(name, price);\n\n        // then\n        Collection<Product> productsAfter = warehouse.getProducts();\n        assertEquals(productsBefore.size() + 1, productsAfter.size());\n    }\n\n    @Test\n    void cantAddProductWithNegativePrice() {\n        // given\n        String name = \"test\";\n        int price = -123;\n\n        // when/then\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addProduct(name, price));\n    }\n\n    @Test\n    void canPlaceCorrectOrder() throws Exception {\n        // given\n        Collection<Order> ordersBefore = warehouse.getOrders();\n        int customerId = 12;\n        var quantities = Map.of(2, 1);\n\n        // when\n        warehouse.addOrder(customerId, quantities);\n\n        // then\n        Collection<Order> ordersAfter = warehouse.getOrders();\n        assertEquals(ordersBefore.size() + 1, ordersAfter.size());\n    }\n\n    @Test\n    void cantOrderForNonExistentCustomer() {\n        // given\n        int customerId = 666;\n        var quantities = Map.of(2, 1);\n\n        // when\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addOrder(customerId, quantities));\n    }\n\n    @Test\n    void cantOrderMoreThanAvailableStock() {\n        // given\n        int customerId = 12;\n        var quantities = Map.of(2, 3);\n\n        // when\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addOrder(customerId, quantities));\n    }\n}\n", "focal_file": "package com.example.warehouse;\n\nimport com.example.warehouse.dal.CustomerDao;\nimport com.example.warehouse.dal.InventoryDao;\nimport com.example.warehouse.dal.OrderDao;\nimport com.example.warehouse.dal.ProductDao;\nimport com.example.warehouse.service.ExternalCustomerService;\nimport org.json.JSONObject;\n\nimport java.time.LocalDate;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport static java.util.stream.Collectors.toUnmodifiableList;\n\npublic final class Warehouse {\n\n    private final ProductDao productDao;\n    private final CustomerDao customerDao;\n    private final InventoryDao inventoryDao;\n    private final OrderDao orderDao;\n\n    private final ReportGeneration reportGeneration;\n    private final ExternalCustomerService externalCustomerService;\n\n    public Warehouse(\n        ProductDao productDao,\n        CustomerDao customerDao,\n        InventoryDao inventoryDao,\n        OrderDao orderDao,\n        ReportGeneration reportGeneration,\n        ExternalCustomerService externalCustomerService) {\n        this.productDao = productDao;\n        this.customerDao = customerDao;\n        this.inventoryDao = inventoryDao;\n        this.orderDao = orderDao;\n        this.reportGeneration = reportGeneration;\n        this.externalCustomerService = externalCustomerService;\n    }\n\n    public Collection<Product> getProducts() throws WarehouseException {\n        return productDao.getProducts()\n            .stream()\n            .sorted(Comparator.comparing(Product::getId))\n            .collect(toUnmodifiableList());\n    }\n\n    public Collection<Customer> getCustomers() throws WarehouseException {\n        Map<Integer, JSONObject> externalCustomers = externalCustomerService.fetchCustomers();\n        return customerDao.getCustomers()\n            .stream()\n            .map(c -> {\n                JSONObject customer = externalCustomers.get(c.getId());\n                JSONObject address = customer.getJSONObject(\"address\");\n                return new Customer(\n                    c.getId(),\n                    c.getName(),\n                    LocalDate.parse(customer.getString(\"date_of_birth\")),\n                    customer.getString(\"company\"),\n                    customer.getString(\"phone\"),\n                    address.getString(\"street_address\"),\n                    address.getString(\"city\"),\n                    address.getString(\"state\"),\n                    address.getInt(\"zip_code\"));\n            })\n            .sorted(Comparator.comparing(Customer::getId))\n            .collect(toUnmodifiableList());\n    }\n\n    public Collection<Order> getOrders() throws WarehouseException {\n        return orderDao.getOrders()\n            .stream()\n            .sorted(Comparator.comparing(Order::getId))\n            .collect(toUnmodifiableList());\n    }\n\n    public void addProduct(String name, int price) throws WarehouseException {\n        if (price < 0) {\n            throw new IllegalArgumentException(\"The product's price cannot be negative.\");\n        }\n        Product product = new Product(name, price);\n        productDao.addProduct(product);\n    }\n\n    public void addOrder(int customerId, Map<Integer, Integer> quantities) throws WarehouseException {\n        if (quantities.isEmpty()) {\n            throw new IllegalArgumentException(\"There has to items in the order, it cannot be empty.\");\n        }\n        Customer customer = customerDao.getCustomer(customerId);\n        if (customer == null) {\n            throw new IllegalArgumentException(\"Unknown customer ID: \" + customerId);\n        }\n        Map<Product, Integer> mappedQuantities = new HashMap<>();\n        for (var entry : quantities.entrySet()) {\n            Product product = productDao.getProduct(entry.getKey());\n            if (product == null) {\n                throw new IllegalArgumentException(\"Unknown product ID: \" + entry.getKey());\n            }\n            int quantity = entry.getValue();\n            if (quantity < 1) {\n                throw new IllegalArgumentException(\"Ordered quantity must be greater than 0.\");\n            }\n            mappedQuantities.put(product, quantity);\n        }\n        inventoryDao.updateStock(mappedQuantities);\n        Order order = new Order(customer, mappedQuantities);\n        // TODO: updating stock and adding order should be atomic.\n        orderDao.addOrder(order);\n    }\n\n    public Report generateReport(Report.Type type) throws WarehouseException {\n        return reportGeneration.generateReport(type);\n    }\n}\n"}
{"test_method": "@Test\n    void cantAddProductWithNegativePrice() {\n        // given\n        String name = \"test\";\n        int price = -123;\n\n        // when/then\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addProduct(name, price));\n    }", "focal_method": "public void addProduct(String name, int price) throws WarehouseException {\n        if (price < 0) {\n            throw new IllegalArgumentException(\"The product's price cannot be negative.\");\n        }\n        Product product = new Product(name, price);\n        productDao.addProduct(product);\n    }", "test_file": "package com.example.warehouse;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Collection;\nimport java.util.Map;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nclass WarehouseTest {\n\n    private Warehouse warehouse;\n\n    @BeforeEach\n    void beforeEach() {\n        warehouse = Warehouses.newInMemoryWarehouse(1);\n    }\n\n    @Test\n    void canAddNewProduct() throws Exception {\n        // given\n        Collection<Product> productsBefore = warehouse.getProducts();\n\n        // and\n        String name = \"test\";\n        int price = 123;\n\n        // when\n        warehouse.addProduct(name, price);\n\n        // then\n        Collection<Product> productsAfter = warehouse.getProducts();\n        assertEquals(productsBefore.size() + 1, productsAfter.size());\n    }\n\n    @Test\n    void cantAddProductWithNegativePrice() {\n        // given\n        String name = \"test\";\n        int price = -123;\n\n        // when/then\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addProduct(name, price));\n    }\n\n    @Test\n    void canPlaceCorrectOrder() throws Exception {\n        // given\n        Collection<Order> ordersBefore = warehouse.getOrders();\n        int customerId = 12;\n        var quantities = Map.of(2, 1);\n\n        // when\n        warehouse.addOrder(customerId, quantities);\n\n        // then\n        Collection<Order> ordersAfter = warehouse.getOrders();\n        assertEquals(ordersBefore.size() + 1, ordersAfter.size());\n    }\n\n    @Test\n    void cantOrderForNonExistentCustomer() {\n        // given\n        int customerId = 666;\n        var quantities = Map.of(2, 1);\n\n        // when\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addOrder(customerId, quantities));\n    }\n\n    @Test\n    void cantOrderMoreThanAvailableStock() {\n        // given\n        int customerId = 12;\n        var quantities = Map.of(2, 3);\n\n        // when\n        assertThrows(IllegalArgumentException.class, () -> warehouse.addOrder(customerId, quantities));\n    }\n}\n", "focal_file": "package com.example.warehouse;\n\nimport com.example.warehouse.dal.CustomerDao;\nimport com.example.warehouse.dal.InventoryDao;\nimport com.example.warehouse.dal.OrderDao;\nimport com.example.warehouse.dal.ProductDao;\n\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport static java.util.stream.Collectors.toUnmodifiableList;\n\npublic final class Warehouse {\n\n    private final ProductDao productDao;\n    private final CustomerDao customerDao;\n    private final InventoryDao inventoryDao;\n    private final OrderDao orderDao;\n\n    private final ReportGeneration reportGeneration;\n\n    public Warehouse(\n        ProductDao productDao,\n        CustomerDao customerDao,\n        InventoryDao inventoryDao,\n        OrderDao orderDao,\n        ReportGeneration reportGeneration) {\n        this.productDao = productDao;\n        this.customerDao = customerDao;\n        this.inventoryDao = inventoryDao;\n        this.orderDao = orderDao;\n        this.reportGeneration = reportGeneration;\n    }\n\n    public Collection<Product> getProducts() throws WarehouseException {\n        return productDao.getProducts()\n            .stream()\n            .sorted(Comparator.comparing(Product::getId))\n            .collect(toUnmodifiableList());\n    }\n\n    public Product getProduct(int id) throws WarehouseException {\n        return productDao.getProduct(id);\n    }\n\n    public Collection<Customer> getCustomers() throws WarehouseException {\n        return customerDao.getCustomers()\n            .stream()\n            .sorted(Comparator.comparing(Customer::getId))\n            .collect(toUnmodifiableList());\n    }\n\n    public Customer getCustomer(int id) throws WarehouseException {\n        return customerDao.getCustomer(id);\n    }\n\n    public Collection<Order> getOrders() throws WarehouseException {\n        return orderDao.getOrders()\n            .stream()\n            .sorted(Comparator.comparing(Order::getId))\n            .collect(toUnmodifiableList());\n    }\n\n    public Order getOrder(int id) throws WarehouseException {\n        return orderDao.getOrder(id);\n    }\n\n    public void addProduct(String name, int price) throws WarehouseException {\n        if (price < 0) {\n            throw new IllegalArgumentException(\"The product's price cannot be negative.\");\n        }\n        Product product = new Product(name, price);\n        productDao.addProduct(product);\n    }\n\n    public void addOrder(int customerId, Map<Integer, Integer> quantities) throws WarehouseException {\n        if (quantities.isEmpty()) {\n            throw new IllegalArgumentException(\"There has to items in the order, it cannot be empty.\");\n        }\n        Customer customer = customerDao.getCustomer(customerId);\n        if (customer == null) {\n            throw new IllegalArgumentException(\"Unknown customer ID: \" + customerId);\n        }\n        Map<Product, Integer> mappedQuantities = new HashMap<>();\n        for (var entry : quantities.entrySet()) {\n            Product product = productDao.getProduct(entry.getKey());\n            if (product == null) {\n                throw new IllegalArgumentException(\"Unknown product ID: \" + entry.getKey());\n            }\n            int quantity = entry.getValue();\n            if (quantity < 1) {\n                throw new IllegalArgumentException(\"Ordered quantity must be greater than 0.\");\n            }\n            mappedQuantities.put(product, quantity);\n        }\n        inventoryDao.updateStock(mappedQuantities);\n        Order order = new Order(customer, mappedQuantities);\n        // TODO: updating stock and adding order should be atomic.\n        orderDao.addOrder(order);\n    }\n\n    public Report generateReport(Report.Type type) throws WarehouseException {\n        return reportGeneration.generateReport(type);\n    }\n}\n"}
{"test_method": "@DisplayName(\"test_getLoader_NotInterface\")\n    @Test\n    void testGetLoaderNotInterface() {\n        try {\n            SpiLoader.getLoader(SimpleOutput.class);\n            fail();\n        } catch (IllegalArgumentException e) {\n            assertEquals(\"Spi type io.github.ukuz.piccolo.api.spi.SimpleOutput must an interface\", e.getMessage());\n        }\n    }", "focal_method": "@SuppressWarnings(\"unchecked\")\n    public static <T> SpiLoader<T> getLoader(Class<T> type) {\n        if (type == null) {\n            throw new IllegalArgumentException(\"Spi type must not be null\");\n        }\n        if (!type.isInterface()) {\n            throw new IllegalArgumentException(\"Spi type \" + type.getName() + \" must an interface\");\n        }\n        if (!type.isAnnotationPresent(Spi.class)) {\n            throw new IllegalArgumentException(\"Spi type \" + type.getName() + \" must annotated with @Spi\");\n        }\n        return LOADERS.computeIfAbsent(type, t -> new SpiLoader(t));\n    }", "test_file": "/*\n * Copyright 2019 ukuz90\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.ukuz.piccolo.api.spi;\n\nimport io.github.ukuz.piccolo.api.common.DefaultOrderComparator;\nimport io.github.ukuz.piccolo.api.common.OrderComparator;\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass SpiLoaderTest {\n\n    @DisplayName(\"test_getLoader_Null\")\n    @Test\n    void testGetLoaderNull() {\n        try {\n            SpiLoader.getLoader(null);\n            fail();\n        } catch (IllegalArgumentException e) {\n            assertEquals(\"Spi type must not be null\", e.getMessage());\n        }\n    }\n\n    @DisplayName(\"test_getLoader_NotInterface\")\n    @Test\n    void testGetLoaderNotInterface() {\n        try {\n            SpiLoader.getLoader(SimpleOutput.class);\n            fail();\n        } catch (IllegalArgumentException e) {\n            assertEquals(\"Spi type io.github.ukuz.piccolo.api.spi.SimpleOutput must an interface\", e.getMessage());\n        }\n    }\n\n    @DisplayName(\"test_getLoader_NotSpiAnnotation\")\n    @Test\n    void testGetLoaderNotSpiAnnotation() {\n        try {\n            SpiLoader.getLoader(Output.class);\n            fail();\n        } catch (IllegalArgumentException e) {\n            assertEquals(\"Spi type io.github.ukuz.piccolo.api.spi.Output must annotated with @Spi\", e.getMessage());\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @DisplayName(\"test_getLoader\")\n    @Test\n    void testGetLoader() {\n        SpiLoader<Input> loader = SpiLoader.getLoader(Input.class);\n        assertNotNull(loader);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @DisplayName(\"test_getExtension_NotPrimaryKey\")\n    @Test\n    void testGetExtensionNotPrimaryKey() {\n        SpiLoader<Input> loader = SpiLoader.getLoader(Input.class);\n        try {\n            loader.getExtension();\n            fail();\n        } catch (IllegalArgumentException e) {\n            assertEquals(\"Can not found default extension\", e.getMessage());\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @DisplayName(\"test_getExtension_PrimaryKeyNotMapping\")\n    @Test\n    void testGetExtensionPrimaryKeyNotMapping() {\n        SpiLoader<SpiPrimaryKeyNotMapping> loader = SpiLoader.getLoader(SpiPrimaryKeyNotMapping.class);\n        try {\n            loader.getExtension();\n            fail();\n        } catch (IllegalArgumentException e) {\n            assertEquals(\"Can not found default mapping class\", e.getMessage());\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @DisplayName(\"test_getExtension\")\n    @Test\n    void testGetExtensionWithPrimaryKey() {\n        SpiLoader<OrderComparator> loader = SpiLoader.getLoader(OrderComparator.class);\n        OrderComparator comparator = loader.getExtension();\n        assertEquals(DefaultOrderComparator.class, comparator.getClass());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @DisplayName(\"test_getExtensionWithOrder\")\n    @Test\n    void testGetExtensionWithOrder() {\n        SpiLoader<SpiWithOrder> loader = SpiLoader.getLoader(SpiWithOrder.class);\n        SpiWithOrder spiWithOrder = loader.getExtension();\n        assertEquals(SpiWithOrder.PrimarySpiWithOrder.class, spiWithOrder.getClass());\n    }\n\n    @DisplayName(\"test_getExtension_Null\")\n    @Test\n    void testGetExtensionNull() {\n        try {\n            SpiLoader.getLoader(Input.class).getExtension(\"default\");\n            fail();\n        } catch (IllegalArgumentException e) {\n            assertEquals(\"Can not found default mapping class\", e.getMessage());\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @DisplayName(\"test_getExtension_WithKey\")\n    @Test\n    void testGetExtensionWithKey() {\n        SpiLoader<Input> loader = SpiLoader.getLoader(Input.class);\n        Input input = loader.getExtension(\"hello\");\n        assertEquals(\"Hello, World!\", input.read());\n    }\n\n}", "focal_file": "/*\n * Copyright 2019 ukuz90\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.ukuz.piccolo.api.spi;\n\nimport io.github.ukuz.piccolo.api.annotation.AnnotationTypeFilter;\nimport io.github.ukuz.piccolo.api.annotation.Order;\nimport io.github.ukuz.piccolo.api.common.Holder;\nimport io.github.ukuz.piccolo.api.common.OrderComparator;\nimport io.github.ukuz.piccolo.api.external.common.utils.ClassUtils;\nimport io.netty.util.internal.StringUtil;\n\nimport java.util.List;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.URL;\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.stream.Collectors;\n\n/**\n * Extension Mechanism (Thread safe)\n *\n * @author ukuz90\n */\npublic class SpiLoader<T> {\n\n    private static final ConcurrentHashMap<Class<?>, SpiLoader> LOADERS = new ConcurrentHashMap<>();\n    private static final ConcurrentHashMap<Class<?>, Holder<Object>> INSTANCES = new ConcurrentHashMap<>();\n    private static final String PLUGIN_SERVICES = \"META-INF/services/\";\n    private static final String PLUGIN_PICCOLO = \"META-INF/piccolo/\";\n\n\n    private final Holder<Map<String, Class<T>>> cachedClassHolder = new Holder<>();\n    private final Holder<AnnotationTypeFilter> annotationTypeFilterHolder = new Holder<>();\n    private final Class<T> type;\n    private final String primaryExtensionKey;\n\n    private SpiLoader(Class<T> type) {\n        this.type = type;\n        Spi spi = type.getAnnotation(Spi.class);\n        primaryExtensionKey = spi.primary();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static <T> SpiLoader<T> getLoader(Class<T> type) {\n        if (type == null) {\n            throw new IllegalArgumentException(\"Spi type must not be null\");\n        }\n        if (!type.isInterface()) {\n            throw new IllegalArgumentException(\"Spi type \" + type.getName() + \" must an interface\");\n        }\n        if (!type.isAnnotationPresent(Spi.class)) {\n            throw new IllegalArgumentException(\"Spi type \" + type.getName() + \" must annotated with @Spi\");\n        }\n        return LOADERS.computeIfAbsent(type, t -> new SpiLoader(t));\n    }\n\n    public T getExtension() {\n        Map<String, Class<T>> extensionClassMap = getExtensionClass();\n        Class<T> primaryClass = null;\n        if (StringUtil.isNullOrEmpty(primaryExtensionKey)) {\n            //order\n            primaryClass = choosePrimaryClass(extensionClassMap);\n\n        } else {\n            primaryClass = extensionClassMap.get(primaryExtensionKey);\n            if (primaryClass == null) {\n                throw new IllegalArgumentException(\"Can not found \" + primaryExtensionKey + \" mapping class\");\n            }\n        }\n\n        if (primaryClass == null) {\n            throw new IllegalArgumentException(\"Can not found default extension\");\n        }\n\n        return getInstance(primaryClass);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private Class<T> choosePrimaryClass(Map<String, Class<T>> extensionClassMap) {\n        List<Class<T>> extensionClassList = new ArrayList<>(extensionClassMap.values());\n\n        AnnotationTypeFilter filter = annotationTypeFilterHolder.getValue();\n        if (filter == null) {\n            synchronized (annotationTypeFilterHolder) {\n                filter = annotationTypeFilterHolder.getValue();\n                if (filter == null) {\n                    filter = new AnnotationTypeFilter(Order.class);\n                    annotationTypeFilterHolder.setValue(filter);\n                }\n            }\n        }\n\n        //filter which annotated with @Order\n        List<Class<T>> orderExtensionClassList = extensionClassList.stream()\n                .filter(filter::match)\n                .collect(Collectors.toList());\n\n        if (orderExtensionClassList.isEmpty()) {\n            if (extensionClassList.size() == 1) {\n                return extensionClassList.get(0);\n            }\n            //Could not determine primary class\n            return null;\n        } else if (orderExtensionClassList.size() == 1) {\n            return orderExtensionClassList.get(0);\n        } else {\n            OrderComparator orderComparator = (OrderComparator) SpiLoader.getLoader(OrderComparator.class).getExtension();\n            orderExtensionClassList = orderComparator.compare(orderExtensionClassList);\n            return orderExtensionClassList.get(0);\n        }\n    }\n\n    public T getExtension(String key) {\n        Map<String, Class<T>> extensionClassMap = getExtensionClass();\n        if (StringUtil.isNullOrEmpty(key)) {\n            throw new IllegalArgumentException(\"Key must not be null\");\n        }\n        Class<T> clazz = extensionClassMap.get(key);\n        if (clazz == null) {\n            throw new IllegalArgumentException(\"Can not found \" + key + \" mapping class\");\n        }\n        return getInstance(clazz);\n    }\n\n    private T getInstance(Class<T> clazz) {\n        Holder holder = INSTANCES.computeIfAbsent(clazz, c -> new Holder());\n        return getInstance(holder, clazz);\n    }\n\n    private T getInstance(Holder holder, Class<T> clazz) {\n        Object obj = holder.getValue();\n        if (obj == null) {\n            synchronized (holder) {\n                if (obj == null) {\n                    try {\n                        obj = clazz.newInstance();\n                    } catch (InstantiationException e) {\n                        e.printStackTrace();\n                    } catch (IllegalAccessException e) {\n                        e.printStackTrace();\n                    }\n                    holder.setValue(obj);\n                }\n            }\n        }\n        return (T) obj;\n    }\n\n    /**\n     * lazy load(double check)\n     * @return\n     */\n    private Map<String, Class<T>> getExtensionClass() {\n        Map<String, Class<T>> extensionClassMap = cachedClassHolder.getValue();\n        if (extensionClassMap == null) {\n            synchronized (cachedClassHolder) {\n                extensionClassMap = cachedClassHolder.getValue();\n                if (extensionClassMap == null) {\n                    extensionClassMap = loadExtensionClass();\n                    cachedClassHolder.setValue(extensionClassMap);\n                }\n            }\n        }\n        return extensionClassMap;\n    }\n\n    private Map<String, Class<T>> loadExtensionClass() {\n        Map<String, Class<T>> extensionClassMap = new HashMap<>(16);\n        loadDirectory(extensionClassMap, PLUGIN_SERVICES);\n        loadDirectory(extensionClassMap, PLUGIN_PICCOLO);\n        return extensionClassMap;\n    }\n\n    private void loadDirectory(Map<String, Class<T>> extensionClassMap, String dir) {\n        String fileName = dir + type.getName();\n        Enumeration<URL> urls = null;\n\n        try {\n            ClassLoader classLoader = findClassLoader();\n            if (classLoader != null) {\n                urls = classLoader.getResources(fileName);\n            } else {\n                urls = ClassLoader.getSystemResources(fileName);\n            }\n            if (urls == null) {\n                return;\n            }\n            Collections.list(urls)\n                    .stream()\n                    .filter(url -> url != null)\n                    .forEach(url -> loadResource(extensionClassMap, url));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    private void loadResource(Map<String, Class<T>> extensionClassMap, URL url) {\n        try (BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()))) {\n            String line;\n            while ((line = br.readLine()) != null) {\n                int index = line.indexOf(\"#\");\n                line = index == -1 ? line.trim() : line.substring(0, index).trim();\n                String key = null;\n                index = line.indexOf(\"=\");\n                if (index != -1) {\n                    key = line.substring(0, index);\n                    line = line.substring(index+1);\n                }\n                if (line.length() > 0) {\n                    loadClass(extensionClassMap, key, line);\n                }\n            }\n\n        } catch (IOException e) {\n\n        }\n    }\n\n    private void loadClass(Map<String, Class<T>> extensionClassMap, String key, String className) {\n        try {\n            Class<T> clazz = (Class<T>) findClassLoader().loadClass(className);\n            if (StringUtil.isNullOrEmpty(key)) {\n                key = getPrefixClassName(clazz);\n            }\n            extensionClassMap.putIfAbsent(key, clazz);\n\n        } catch (ClassNotFoundException e) {\n            throw new IllegalArgumentException(\"Can not found class \" + className);\n        }\n\n    }\n\n    private String getPrefixClassName(Class clazz) {\n        String prefix;\n        int index = clazz.getSimpleName().indexOf(type.getSimpleName());\n        if (index != -1) {\n            prefix = clazz.getSimpleName().substring(0, index).toLowerCase();\n        } else {\n            prefix = clazz.getSimpleName().toLowerCase();\n        }\n        return prefix;\n    }\n\n    private ClassLoader findClassLoader() {\n        return ClassUtils.getClassLoader(SpiLoader.class);\n    }\n\n}\n"}
{"test_method": "@SuppressWarnings(\"unchecked\")\n    @DisplayName(\"test_getLoader\")\n    @Test\n    void testGetLoader() {\n        SpiLoader<Input> loader = SpiLoader.getLoader(Input.class);\n        assertNotNull(loader);\n    }", "focal_method": "@SuppressWarnings(\"unchecked\")\n    public static <T> SpiLoader<T> getLoader(Class<T> type) {\n        if (type == null) {\n            throw new IllegalArgumentException(\"Spi type must not be null\");\n        }\n        if (!type.isInterface()) {\n            throw new IllegalArgumentException(\"Spi type \" + type.getName() + \" must an interface\");\n        }\n        if (!type.isAnnotationPresent(Spi.class)) {\n            throw new IllegalArgumentException(\"Spi type \" + type.getName() + \" must annotated with @Spi\");\n        }\n        return LOADERS.computeIfAbsent(type, t -> new SpiLoader(t));\n    }", "test_file": "/*\n * Copyright 2019 ukuz90\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.ukuz.piccolo.api.spi;\n\nimport io.github.ukuz.piccolo.api.common.DefaultOrderComparator;\nimport io.github.ukuz.piccolo.api.common.OrderComparator;\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass SpiLoaderTest {\n\n    @DisplayName(\"test_getLoader_Null\")\n    @Test\n    void testGetLoaderNull() {\n        try {\n            SpiLoader.getLoader(null);\n            fail();\n        } catch (IllegalArgumentException e) {\n            assertEquals(\"Spi type must not be null\", e.getMessage());\n        }\n    }\n\n    @DisplayName(\"test_getLoader_NotInterface\")\n    @Test\n    void testGetLoaderNotInterface() {\n        try {\n            SpiLoader.getLoader(SimpleOutput.class);\n            fail();\n        } catch (IllegalArgumentException e) {\n            assertEquals(\"Spi type io.github.ukuz.piccolo.api.spi.SimpleOutput must an interface\", e.getMessage());\n        }\n    }\n\n    @DisplayName(\"test_getLoader_NotSpiAnnotation\")\n    @Test\n    void testGetLoaderNotSpiAnnotation() {\n        try {\n            SpiLoader.getLoader(Output.class);\n            fail();\n        } catch (IllegalArgumentException e) {\n            assertEquals(\"Spi type io.github.ukuz.piccolo.api.spi.Output must annotated with @Spi\", e.getMessage());\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @DisplayName(\"test_getLoader\")\n    @Test\n    void testGetLoader() {\n        SpiLoader<Input> loader = SpiLoader.getLoader(Input.class);\n        assertNotNull(loader);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @DisplayName(\"test_getExtension_NotPrimaryKey\")\n    @Test\n    void testGetExtensionNotPrimaryKey() {\n        SpiLoader<Input> loader = SpiLoader.getLoader(Input.class);\n        try {\n            loader.getExtension();\n            fail();\n        } catch (IllegalArgumentException e) {\n            assertEquals(\"Can not found default extension\", e.getMessage());\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @DisplayName(\"test_getExtension_PrimaryKeyNotMapping\")\n    @Test\n    void testGetExtensionPrimaryKeyNotMapping() {\n        SpiLoader<SpiPrimaryKeyNotMapping> loader = SpiLoader.getLoader(SpiPrimaryKeyNotMapping.class);\n        try {\n            loader.getExtension();\n            fail();\n        } catch (IllegalArgumentException e) {\n            assertEquals(\"Can not found default mapping class\", e.getMessage());\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @DisplayName(\"test_getExtension\")\n    @Test\n    void testGetExtensionWithPrimaryKey() {\n        SpiLoader<OrderComparator> loader = SpiLoader.getLoader(OrderComparator.class);\n        OrderComparator comparator = loader.getExtension();\n        assertEquals(DefaultOrderComparator.class, comparator.getClass());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @DisplayName(\"test_getExtensionWithOrder\")\n    @Test\n    void testGetExtensionWithOrder() {\n        SpiLoader<SpiWithOrder> loader = SpiLoader.getLoader(SpiWithOrder.class);\n        SpiWithOrder spiWithOrder = loader.getExtension();\n        assertEquals(SpiWithOrder.PrimarySpiWithOrder.class, spiWithOrder.getClass());\n    }\n\n    @DisplayName(\"test_getExtension_Null\")\n    @Test\n    void testGetExtensionNull() {\n        try {\n            SpiLoader.getLoader(Input.class).getExtension(\"default\");\n            fail();\n        } catch (IllegalArgumentException e) {\n            assertEquals(\"Can not found default mapping class\", e.getMessage());\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @DisplayName(\"test_getExtension_WithKey\")\n    @Test\n    void testGetExtensionWithKey() {\n        SpiLoader<Input> loader = SpiLoader.getLoader(Input.class);\n        Input input = loader.getExtension(\"hello\");\n        assertEquals(\"Hello, World!\", input.read());\n    }\n\n}", "focal_file": "/*\n * Copyright 2019 ukuz90\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.github.ukuz.piccolo.api.spi;\n\nimport io.github.ukuz.piccolo.api.annotation.AnnotationTypeFilter;\nimport io.github.ukuz.piccolo.api.annotation.Order;\nimport io.github.ukuz.piccolo.api.common.Holder;\nimport io.github.ukuz.piccolo.api.common.OrderComparator;\nimport io.github.ukuz.piccolo.api.external.common.utils.ClassUtils;\nimport io.netty.util.internal.StringUtil;\n\nimport java.util.List;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.URL;\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.stream.Collectors;\n\n/**\n * Extension Mechanism (Thread safe)\n *\n * @author ukuz90\n */\npublic class SpiLoader<T> {\n\n    private static final ConcurrentHashMap<Class<?>, SpiLoader> LOADERS = new ConcurrentHashMap<>();\n    private static final ConcurrentHashMap<Class<?>, Holder<Object>> INSTANCES = new ConcurrentHashMap<>();\n    private static final String PLUGIN_SERVICES = \"META-INF/services/\";\n    private static final String PLUGIN_PICCOLO = \"META-INF/piccolo/\";\n\n\n    private final Holder<Map<String, Class<T>>> cachedClassHolder = new Holder<>();\n    private final Holder<AnnotationTypeFilter> annotationTypeFilterHolder = new Holder<>();\n    private final Class<T> type;\n    private final String primaryExtensionKey;\n\n    private SpiLoader(Class<T> type) {\n        this.type = type;\n        Spi spi = type.getAnnotation(Spi.class);\n        primaryExtensionKey = spi.primary();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static <T> SpiLoader<T> getLoader(Class<T> type) {\n        if (type == null) {\n            throw new IllegalArgumentException(\"Spi type must not be null\");\n        }\n        if (!type.isInterface()) {\n            throw new IllegalArgumentException(\"Spi type \" + type.getName() + \" must an interface\");\n        }\n        if (!type.isAnnotationPresent(Spi.class)) {\n            throw new IllegalArgumentException(\"Spi type \" + type.getName() + \" must annotated with @Spi\");\n        }\n        return LOADERS.computeIfAbsent(type, t -> new SpiLoader(t));\n    }\n\n    public T getExtension() {\n        Map<String, Class<T>> extensionClassMap = getExtensionClass();\n        Class<T> primaryClass = null;\n        if (StringUtil.isNullOrEmpty(primaryExtensionKey)) {\n            //order\n            primaryClass = choosePrimaryClass(extensionClassMap);\n\n        } else {\n            primaryClass = extensionClassMap.get(primaryExtensionKey);\n            if (primaryClass == null) {\n                throw new IllegalArgumentException(\"Can not found \" + primaryExtensionKey + \" mapping class\");\n            }\n        }\n\n        if (primaryClass == null) {\n            throw new IllegalArgumentException(\"Can not found default extension\");\n        }\n\n        return getInstance(primaryClass);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private Class<T> choosePrimaryClass(Map<String, Class<T>> extensionClassMap) {\n        List<Class<T>> extensionClassList = new ArrayList<>(extensionClassMap.values());\n\n        AnnotationTypeFilter filter = annotationTypeFilterHolder.getValue();\n        if (filter == null) {\n            synchronized (annotationTypeFilterHolder) {\n                filter = annotationTypeFilterHolder.getValue();\n                if (filter == null) {\n                    filter = new AnnotationTypeFilter(Order.class);\n                    annotationTypeFilterHolder.setValue(filter);\n                }\n            }\n        }\n\n        //filter which annotated with @Order\n        List<Class<T>> orderExtensionClassList = extensionClassList.stream()\n                .filter(filter::match)\n                .collect(Collectors.toList());\n\n        if (orderExtensionClassList.isEmpty()) {\n            if (extensionClassList.size() == 1) {\n                return extensionClassList.get(0);\n            }\n            //Could not determine primary class\n            return null;\n        } else if (orderExtensionClassList.size() == 1) {\n            return orderExtensionClassList.get(0);\n        } else {\n            OrderComparator orderComparator = (OrderComparator) SpiLoader.getLoader(OrderComparator.class).getExtension();\n            orderExtensionClassList = orderComparator.compare(orderExtensionClassList);\n            return orderExtensionClassList.get(0);\n        }\n    }\n\n    public T getExtension(String key) {\n        Map<String, Class<T>> extensionClassMap = getExtensionClass();\n        if (StringUtil.isNullOrEmpty(key)) {\n            throw new IllegalArgumentException(\"Key must not be null\");\n        }\n        Class<T> clazz = extensionClassMap.get(key);\n        if (clazz == null) {\n            throw new IllegalArgumentException(\"Can not found \" + key + \" mapping class\");\n        }\n        return getInstance(clazz);\n    }\n\n    private T getInstance(Class<T> clazz) {\n        Holder holder = INSTANCES.computeIfAbsent(clazz, c -> new Holder());\n        return getInstance(holder, clazz);\n    }\n\n    private T getInstance(Holder holder, Class<T> clazz) {\n        Object obj = holder.getValue();\n        if (obj == null) {\n            synchronized (holder) {\n                if (obj == null) {\n                    try {\n                        obj = clazz.newInstance();\n                    } catch (InstantiationException e) {\n                        e.printStackTrace();\n                    } catch (IllegalAccessException e) {\n                        e.printStackTrace();\n                    }\n                    holder.setValue(obj);\n                }\n            }\n        }\n        return (T) obj;\n    }\n\n    /**\n     * lazy load(double check)\n     * @return\n     */\n    private Map<String, Class<T>> getExtensionClass() {\n        Map<String, Class<T>> extensionClassMap = cachedClassHolder.getValue();\n        if (extensionClassMap == null) {\n            synchronized (cachedClassHolder) {\n                extensionClassMap = cachedClassHolder.getValue();\n                if (extensionClassMap == null) {\n                    extensionClassMap = loadExtensionClass();\n                    cachedClassHolder.setValue(extensionClassMap);\n                }\n            }\n        }\n        return extensionClassMap;\n    }\n\n    private Map<String, Class<T>> loadExtensionClass() {\n        Map<String, Class<T>> extensionClassMap = new HashMap<>(16);\n        loadDirectory(extensionClassMap, PLUGIN_SERVICES);\n        loadDirectory(extensionClassMap, PLUGIN_PICCOLO);\n        return extensionClassMap;\n    }\n\n    private void loadDirectory(Map<String, Class<T>> extensionClassMap, String dir) {\n        String fileName = dir + type.getName();\n        Enumeration<URL> urls = null;\n\n        try {\n            ClassLoader classLoader = findClassLoader();\n            if (classLoader != null) {\n                urls = classLoader.getResources(fileName);\n            } else {\n                urls = ClassLoader.getSystemResources(fileName);\n            }\n            if (urls == null) {\n                return;\n            }\n            Collections.list(urls)\n                    .stream()\n                    .filter(url -> url != null)\n                    .forEach(url -> loadResource(extensionClassMap, url));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    private void loadResource(Map<String, Class<T>> extensionClassMap, URL url) {\n        try (BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()))) {\n            String line;\n            while ((line = br.readLine()) != null) {\n                int index = line.indexOf(\"#\");\n                line = index == -1 ? line.trim() : line.substring(0, index).trim();\n                String key = null;\n                index = line.indexOf(\"=\");\n                if (index != -1) {\n                    key = line.substring(0, index);\n                    line = line.substring(index+1);\n                }\n                if (line.length() > 0) {\n                    loadClass(extensionClassMap, key, line);\n                }\n            }\n\n        } catch (IOException e) {\n\n        }\n    }\n\n    private void loadClass(Map<String, Class<T>> extensionClassMap, String key, String className) {\n        try {\n            Class<T> clazz = (Class<T>) findClassLoader().loadClass(className);\n            if (StringUtil.isNullOrEmpty(key)) {\n                key = getPrefixClassName(clazz);\n            }\n            extensionClassMap.putIfAbsent(key, clazz);\n\n        } catch (ClassNotFoundException e) {\n            throw new IllegalArgumentException(\"Can not found class \" + className);\n        }\n\n    }\n\n    private String getPrefixClassName(Class clazz) {\n        String prefix;\n        int index = clazz.getSimpleName().indexOf(type.getSimpleName());\n        if (index != -1) {\n            prefix = clazz.getSimpleName().substring(0, index).toLowerCase();\n        } else {\n            prefix = clazz.getSimpleName().toLowerCase();\n        }\n        return prefix;\n    }\n\n    private ClassLoader findClassLoader() {\n        return ClassUtils.getClassLoader(SpiLoader.class);\n    }\n\n}\n"}
